;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var global=self;/**
 * @license
 * Lo-Dash 1.3.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.4.4 <http://underscorejs.org/>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * Available under MIT license <http://lodash.com/license>
 */
;(function(window) {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to detect functions containing a `this` reference */
  var reThis = (reThis = /\bthis\b/) && reThis.test(runInContext) && reThis;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to match HTML characters */
  var reUnescapedHtml = /[&<>"']/g;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setImmediate', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      errorClass = '[object Error]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && module.exports == freeExports && module;

  /** Detect free variable `global`, from Node.js or Browserified code, and use it as `window` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    window = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * A basic implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Number} [fromIndex=0] The index to search from.
   * @returns {Number} Returns the index of the matched value or `-1`.
   */
  function basicIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {Mixed} value The value to search for.
   * @returns {Number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value];
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = cache[type] || (cache[type] = {});

    return type == 'object'
      ? (cache[key] && basicIndexOf(cache[key], value) > -1 ? 0 : -1)
      : (cache[key] ? 0 : -1);
  }

  /**
   * Adds a given `value` to the corresponding cache object.
   *
   * @private
   * @param {Mixed} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        if ((typeCache[key] || (typeCache[key] = [])).push(value) == this.array.length) {
          cache[type] = false;
        }
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default `callback` when a given
   * `collection` is a string value.
   *
   * @private
   * @param {String} value The character to inspect.
   * @returns {Number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` values, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {Number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ai = a.index,
        bi = b.index;

    a = a.criteria;
    b = b.criteria;

    // ensure a stable sort in V8 and other engines
    // http://code.google.com/p/v8/issues/detail?id=90
    if (a !== b) {
      if (a > b || typeof a == 'undefined') {
        return 1;
      }
      if (a < b || typeof b == 'undefined') {
        return -1;
      }
    }
    return ai < bi ? -1 : 1;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {Null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length;

    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return cache.object === false
      ? (releaseObject(result), null)
      : result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {String} match The matched character to escape.
   * @returns {String} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'leading': false,
      'maxWait': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'trailing': false,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * A no-operation function.
   *
   * @private
   */
  function noop() {
    // no operation performed
  }

  /**
   * Releases the given `array` back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given `object` back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used, instead of `Array#slice`, to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|String} collection The collection to slice.
   * @param {Number} start The start index.
   * @param {Number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=window] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.com/#x11.1.5.
    context = context ? _.defaults(window.Object(), context, _.pick(window, contextProps)) : window;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(objectProto.valueOf)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/valueOf|for [^\]]+/g, '.+?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        concat = arrayRef.concat,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        setImmediate = context.setImmediate,
        setTimeout = context.setTimeout,
        toString = objectProto.toString;

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind,
        nativeCreate = reNative.test(nativeCreate =  Object.create) && nativeCreate,
        nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeSlice = arrayRef.slice;

    /** Detect various environments */
    var isIeOpera = reNative.test(context.attachEvent),
        isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object, which wraps the given `value`, to enable method
     * chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `createCallback`, `debounce`, `defaults`,
     * `defer`, `delay`, `difference`, `filter`, `flatten`, `forEach`, `forIn`,
     * `forOwn`, `functions`, `groupBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `push`, `range`,
     * `reject`, `rest`, `reverse`, `shuffle`, `slice`, `sort`, `sortBy`, `splice`,
     * `tap`, `throttle`, `times`, `toArray`, `transform`, `union`, `uniq`, `unshift`,
     * `unzip`, `values`, `where`, `without`, `wrap`, and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `has`,
     * `identity`, `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`,
     * `isElement`, `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`,
     * `isNull`, `isNumber`, `isObject`, `isPlainObject`, `isRegExp`, `isString`,
     * `isUndefined`, `join`, `lastIndexOf`, `mixin`, `noConflict`, `parseInt`,
     * `pop`, `random`, `reduce`, `reduceRight`, `result`, `shift`, `size`, `some`,
     * `sortedIndex`, `runInContext`, `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * passed, otherwise they return unwrapped values.
     *
     * @name _
     * @constructor
     * @alias chain
     * @category Chaining
     * @param {Mixed} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {Mixed} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value) {
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if `Function#bind` exists and is inferred to be fast (all but V8).
     *
     * @memberOf _.support
     * @type Boolean
     */
    support.fastBind = nativeBind && !isV8;

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type String
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that, when called, invokes `func` with the `this` binding
     * of `thisArg` and prepends any `partialArgs` to the arguments passed to the
     * bound function.
     *
     * @private
     * @param {Function|String} func The function to bind or the method name.
     * @param {Mixed} [thisArg] The `this` binding of `func`.
     * @param {Array} partialArgs An array of arguments to be partially applied.
     * @param {Object} [idicator] Used to indicate binding by key or partially
     *  applying arguments from the right.
     * @returns {Function} Returns the new bound function.
     */
    function createBound(func, thisArg, partialArgs, indicator) {
      var isFunc = isFunction(func),
          isPartial = !partialArgs,
          key = thisArg;

      // juggle arguments
      if (isPartial) {
        var rightIndicator = indicator;
        partialArgs = thisArg;
      }
      else if (!isFunc) {
        if (!indicator) {
          throw new TypeError;
        }
        thisArg = func;
      }

      function bound() {
        // `Function#bind` spec
        // http://es5.github.com/#x15.3.4.5
        var args = arguments,
            thisBinding = isPartial ? this : thisArg;

        if (!isFunc) {
          func = thisArg[key];
        }
        if (partialArgs.length) {
          args = args.length
            ? (args = nativeSlice.call(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args))
            : partialArgs;
        }
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          thisBinding = createObject(func.prototype);

          // mimic the constructor's `return` behavior
          // http://es5.github.com/#x13.2.2
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      return bound;
    }

    /**
     * Creates a new object with the specified `prototype`.
     *
     * @private
     * @param {Object} prototype The prototype object.
     * @returns {Object} Returns the new object.
     */
    function createObject(prototype) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {String} match The matched character to escape.
     * @returns {String} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `basicIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf(array, value, fromIndex) {
      var result = (result = lodash.indexOf) === indexOf ? basicIndexOf : result;
      return result;
    }

    /**
     * Creates a function that juggles arguments, allowing argument overloading
     * for `_.flatten` and `_.uniq`, before passing them to the given `func`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @returns {Function} Returns the new function.
     */
    function overloadWrapper(func) {
      return function(array, flag, callback, thisArg) {
        // juggle arguments
        if (typeof flag != 'boolean' && flag != null) {
          thisArg = callback;
          callback = !(thisArg && thisArg[flag] === array) ? flag : undefined;
          flag = false;
        }
        if (callback != null) {
          callback = lodash.createCallback(callback, thisArg);
        }
        return func(array, flag, callback, thisArg);
      };
    }

    /**
     * A fallback implementation of `isPlainObject` which checks if a given `value`
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return result === undefined || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {String} match The matched character to unescape.
     * @returns {String} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return toString.call(value) == argsClass;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray;

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property names.
     */
    var shimKeys = function (object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;    
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);    
          }
        }    
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (order is not guaranteed)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a `callback` function is passed, it will be executed to produce
     * the assigned values. The `callback` is bound to `thisArg` and invoked with
     * two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {Object} [source1, source2, ...] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'moe' }, { 'age': 40 });
     * // => { 'name': 'moe', 'age': 40 }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var food = { 'name': 'apple' };
     * defaults(food, { 'name': 'banana', 'type': 'fruit' });
     * // => { 'name': 'apple', 'type': 'fruit' }
     */
    var assign = function (object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = lodash.createCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {    
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];    
        }    
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `deep` is `true`, nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a `callback`
     * function is passed, it will be executed to produce the cloned values. If
     * `callback` returns `undefined`, cloning will be handled by the method instead.
     * The `callback` is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to clone.
     * @param {Boolean} [deep=false] A flag to indicate a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @param- {Array} [stackA=[]] Tracks traversed source objects.
     * @param- {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {Mixed} Returns the cloned `value`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * var shallow = _.clone(stooges);
     * shallow[0] === stooges[0];
     * // => true
     *
     * var deep = _.clone(stooges, true);
     * deep[0] === stooges[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, deep, callback, thisArg, stackA, stackB) {
      var result = value;

      // allows working with "Collections" methods without using their `callback`
      // argument, `index|key`, for this method's `callback`
      if (typeof deep != 'boolean' && deep != null) {
        thisArg = callback;
        callback = deep;
        deep = false;
      }
      if (typeof callback == 'function') {
        callback = (typeof thisArg == 'undefined')
          ? callback
          : lodash.createCallback(callback, thisArg, 1);

        result = callback(result);
        if (typeof result != 'undefined') {
          return result;
        }
        result = value;
      }
      // inspect [[Class]]
      var isObj = isObject(result);
      if (isObj) {
        var className = toString.call(result);
        if (!cloneableClasses[className]) {
          return result;
        }
        var isArr = isArray(result);
      }
      // shallow clone
      if (!isObj || !deep) {
        return isObj
          ? (isArr ? slice(result) : assign({}, result))
          : result;
      }
      var ctor = ctorByClass[className];
      switch (className) {
        case boolClass:
        case dateClass:
          return new ctor(+result);

        case numberClass:
        case stringClass:
          return new ctor(result);

        case regexpClass:
          return ctor(result.source, reFlags.exec(result));
      }
      // check for circular references and return corresponding clone
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // init cloned object
      result = isArr ? ctor(result.length) : {};

      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * Creates a deep clone of `value`. If a `callback` function is passed,
     * it will be executed to produce the cloned values. If `callback` returns
     * `undefined`, cloning will be handled by the method instead. The `callback`
     * is bound to `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the deep cloned `value`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * var deep = _.cloneDeep(stooges);
     * deep[0] === stooges[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return clone(value, true, callback, thisArg);
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {Object} [source1, source2, ...] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  callback's `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var food = { 'name': 'apple' };
     * _.defaults(food, { 'name': 'banana', 'type': 'fruit' });
     * // => { 'name': 'apple', 'type': 'fruit' }
     */
    var defaults = function (object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {    
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];    
        }    
        }
      }
      return result
    };

    /**
     * This method is similar to `_.find`, except that it returns the key of the
     * element that passes the callback check, instead of the element itself.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the key of the found element, else `undefined`.
     * @example
     *
     * _.findKey({ 'a': 1, 'b': 2, 'c': 3, 'd': 4 }, function(num) {
     *   return num % 2 == 0;
     * });
     * // => 'b'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over `object`'s own and inherited enumerable properties, executing
     * the `callback` for each property. The `callback` is bound to `thisArg` and
     * invoked with three arguments; (value, key, object). Callbacks may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Dog(name) {
     *   this.name = name;
     * }
     *
     * Dog.prototype.bark = function() {
     *   alert('Woof, woof!');
     * };
     *
     * _.forIn(new Dog('Dagny'), function(value, key) {
     *   alert(key);
     * });
     * // => alerts 'name' and 'bark' (order is not guaranteed)
     */
    var forIn = function (collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);    
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;    
        }    
      return result
    };

    /**
     * Iterates over an object's own enumerable properties, executing the `callback`
     * for each property. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
     * returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   alert(key);
     * });
     * // => alerts '0', '1', and 'length' (order is not guaranteed)
     */
    var forOwn = function (collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);    
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;    
        }    
      return result
    };

    /**
     * Creates a sorted array of all enumerable properties, own and inherited,
     * of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified object `property` exists and is a direct property,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to check.
     * @param {String} property The property to check for.
     * @returns {Boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, property) {
      return object ? hasOwnProperty.call(object, property) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     *  _.invert({ 'first': 'moe', 'second': 'larry' });
     * // => { 'moe': 'first', 'larry': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false || toString.call(value) == boolClass;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value ? (typeof value == 'object' && toString.call(value) == dateClass) : false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value ? value.nodeType === 1 : false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|String} value The value to inspect.
     * @returns {Boolean} Returns `true`, if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If `callback` is passed, it will be executed to
     * compare values. If `callback` returns `undefined`, comparisons will be handled
     * by the method instead. The `callback` is bound to `thisArg` and invoked with
     * two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} a The value to compare.
     * @param {Mixed} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @param- {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param- {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {Boolean} Returns `true`, if the values are equivalent, else `false`.
     * @example
     *
     * var moe = { 'name': 'moe', 'age': 40 };
     * var copy = { 'name': 'moe', 'age': 40 };
     *
     * moe == copy;
     * // => false
     *
     * _.isEqual(moe, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      var whereIndicator = callback === indicatorObject;
      if (typeof callback == 'function' && !whereIndicator) {
        callback = lodash.createCallback(callback, thisArg, 2);
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          (!a || (type != 'function' && type != 'object')) &&
          (!b || (otherType != 'function' && otherType != 'object'))) {
        return false;
      }
      // exit early for `null` and `undefined`, avoiding ES3's Function#call behavior
      // http://es5.github.com/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        if (hasOwnProperty.call(a, '__wrapped__ ') || hasOwnProperty.call(b, '__wrapped__')) {
          return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB && !(
              isFunction(ctorA) && ctorA instanceof ctorA &&
              isFunction(ctorB) && ctorB instanceof ctorB
            )) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        length = a.length;
        size = b.length;

        // compare lengths to determine if a deep comparison is necessary
        result = size == a.length;
        if (!result && !whereIndicator) {
          return result;
        }
        // deep compare the contents, ignoring non-numeric properties
        while (size--) {
          var index = length,
              value = b[size];

          if (whereIndicator) {
            while (index--) {
              if ((result = isEqual(a[index], value, callback, thisArg, stackA, stackB))) {
                break;
              }
            }
          } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
            break;
          }
        }
        return result;
      }
      // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
      // which, in this case, is more costly
      forIn(b, function(value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          // count the number of properties.
          size++;
          // deep compare each property value.
          return (result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB));
        }
      });

      if (result && !whereIndicator) {
        // ensure both objects have the same number of properties
        forIn(a, function(value, key, a) {
          if (hasOwnProperty.call(a, key)) {
            // `size` will be `-1` if `a` has more properties than `b`
            return (result = --size > -1);
          }
        });
      }
      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite`, which will return true for
     * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.com/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN`, which will return `true` for
     * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' || toString.call(value) == numberClass;
    }

    /**
     * Checks if a given `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
     * @example
     *
     * function Stooge(name, age) {
     *   this.name = name;
     *   this.age = age;
     * }
     *
     * _.isPlainObject(new Stooge('moe', 40));
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'name': 'moe', 'age': 40 });
     * // => true
     */
    var isPlainObject = function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/moe/);
     * // => true
     */
    function isRegExp(value) {
      return value ? (typeof value == 'object' && toString.call(value) == regexpClass) : false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('moe');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' || toString.call(value) == stringClass;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Mixed} value The value to check.
     * @returns {Boolean} Returns `true`, if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined`, into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a `callback` function
     * is passed, it will be executed to produce the merged values of the destination
     * and source properties. If `callback` returns `undefined`, merging will be
     * handled by the method instead. The `callback` is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {Object} [source1, source2, ...] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @param- {Object} [deepIndicator] Indicates that `stackA` and `stackB` are
     *  arrays of traversed objects, instead of source objects.
     * @param- {Array} [stackA=[]] Tracks traversed source objects.
     * @param- {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'stooges': [
     *     { 'name': 'moe' },
     *     { 'name': 'larry' }
     *   ]
     * };
     *
     * var ages = {
     *   'stooges': [
     *     { 'age': 40 },
     *     { 'age': 50 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'stooges': [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object, source, deepIndicator) {
      var args = arguments,
          index = 0,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      if (deepIndicator === indicatorObject) {
        var callback = args[3],
            stackA = args[4],
            stackB = args[5];
      } else {
        var initedStack = true;
        stackA = getArray();
        stackB = getArray();

        // allows working with `_.reduce` and `_.reduceRight` without
        // using their `callback` arguments, `index|key` and `collection`
        if (typeof deepIndicator != 'number') {
          length = args.length;
        }
        if (length > 3 && typeof args[length - 2] == 'function') {
          callback = lodash.createCallback(args[--length - 1], args[length--], 2);
        } else if (length > 2 && typeof args[length - 1] == 'function') {
          callback = args[--length];
        }
      }
      while (++index < length) {
        (isArray(args[index]) ? forEach : forOwn)(args[index], function(source, key) {
          var found,
              isArr,
              result = source,
              value = object[key];

          if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
            // avoid merging previously merged cyclic sources
            var stackLength = stackA.length;
            while (stackLength--) {
              if ((found = stackA[stackLength] == source)) {
                value = stackB[stackLength];
                break;
              }
            }
            if (!found) {
              var isShallow;
              if (callback) {
                result = callback(value, source);
                if ((isShallow = typeof result != 'undefined')) {
                  value = result;
                }
              }
              if (!isShallow) {
                value = isArr
                  ? (isArray(value) ? value : [])
                  : (isPlainObject(value) ? value : {});
              }
              // add `source` and associated `value` to the stack of traversed objects
              stackA.push(source);
              stackB.push(value);

              // recursively merge objects and arrays (susceptible to call stack limits)
              if (!isShallow) {
                value = merge(value, source, indicatorObject, callback, stackA, stackB);
              }
            }
          }
          else {
            if (callback) {
              result = callback(value, source);
              if (typeof result == 'undefined') {
                result = source;
              }
            }
            if (typeof result != 'undefined') {
              value = result;
            }
          }
          object[key] = value;
        });
      }

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a `callback` function is passed, it will be executed
     * for each property in the `object`, omitting the properties `callback`
     * returns truthy for. The `callback` is bound to `thisArg` and invoked
     * with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit
     *  or the function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'moe', 'age': 40 }, 'age');
     * // => { 'name': 'moe' }
     *
     * _.omit({ 'name': 'moe', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'moe' }
     */
    function omit(object, callback, thisArg) {
      var indexOf = getIndexOf(),
          isFunc = typeof callback == 'function',
          result = {};

      if (isFunc) {
        callback = lodash.createCallback(callback, thisArg);
      } else {
        var props = concat.apply(arrayRef, nativeSlice.call(arguments, 1));
      }
      forIn(object, function(value, key, object) {
        if (isFunc
              ? !callback(value, key, object)
              : indexOf(props, key) < 0
            ) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Creates a two dimensional array of the given object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'moe': 30, 'larry': 40 });
     * // => [['moe', 30], ['larry', 40]] (order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of property
     * names. If `callback` is passed, it will be executed for each property in the
     * `object`, picking the properties `callback` returns truthy for. The `callback`
     * is bound to `thisArg` and invoked with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Array|Function|String} callback|[prop1, prop2, ...] The function called
     *  per iteration or properties to pick, either as individual arguments or arrays.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'moe', '_userid': 'moe1' }, 'name');
     * // => { 'name': 'moe' }
     *
     * _.pick({ 'name': 'moe', '_userid': 'moe1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'moe' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce`, this method transforms an `object` to a new
     * `accumulator` object which is the result of running each of its elements
     * through the `callback`, with each `callback` execution potentially mutating
     * the `accumulator` object. The `callback` is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [accumulator] The custom accumulator value.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      callback = lodash.createCallback(callback, thisArg, 4);

      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = createObject(proto);
        }
      }
      (isArr ? forEach : forOwn)(object, function(value, index, object) {
        return callback(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (order is not guaranteed)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Array|Number|String} [index1, index2, ...] The indexes of
     *  `collection` to retrieve, either as individual arguments or arrays.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['moe', 'larry', 'curly'], 0, 2);
     * // => ['moe', 'curly']
     */
    function at(collection) {
      var index = -1,
          props = concat.apply(arrayRef, nativeSlice.call(arguments, 1)),
          length = props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given `target` element is present in a `collection` using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Mixed} target The value to check for.
     * @param {Number} [fromIndex=0] The index to search from.
     * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');
     * // => true
     *
     * _.contains('curly', 'ur');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (length && typeof length == 'number') {
        result = (isString(collection)
          ? collection.indexOf(target, fromIndex)
          : indexOf(collection, target, fromIndex)
        ) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys returned from running each element of the
     * `collection` through the given `callback`. The corresponding value of each key
     * is the number of times the key was returned by the `callback`. The `callback`
     * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    function countBy(collection, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg);

      forEach(collection, function(value, key, collection) {
        key = String(callback(value, key, collection));
        (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
      });
      return result;
    }

    /**
     * Checks if the `callback` returns a truthy value for **all** elements of a
     * `collection`. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Boolean} Returns `true` if all elements pass the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(stooges, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(stooges, { 'age': 50 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Examines each element in a `collection`, returning an array of all elements
     * the `callback` returns truthy for. The `callback` is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(food, 'organic');
     * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
     *
     * // using "_.where" callback shorthand
     * _.filter(food, { 'type': 'fruit' });
     * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Examines each element in a `collection`, returning the first that the `callback`
     * returns truthy for. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the found element, else `undefined`.
     * @example
     *
     * _.find([1, 2, 3, 4], function(num) {
     *   return num % 2 == 0;
     * });
     * // => 2
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },
     *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.find(food, { 'type': 'vegetable' });
     * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }
     *
     * // using "_.pluck" callback shorthand
     * _.find(food, 'organic');
     * // => { 'name': 'banana', 'organic': true, 'type': 'fruit' }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * Iterates over a `collection`, executing the `callback` for each element in
     * the `collection`. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection). Callbacks may exit iteration early
     * by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|String} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(alert).join(',');
     * // => alerts each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, alert);
     * // => alerts each number value (order is not guaranteed)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : lodash.createCallback(callback, thisArg);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * Creates an object composed of keys returned from running each element of the
     * `collection` through the `callback`. The corresponding value of each key is
     * an array of elements passed to `callback` that returned the key. The `callback`
     * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    function groupBy(collection, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg);

      forEach(collection, function(value, key, collection) {
        key = String(callback(value, key, collection));
        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
      });
      return result;
    }

    /**
     * Invokes the method named by `methodName` on each element in the `collection`,
     * returning an array of the results of each invoked method. Additional arguments
     * will be passed to each invoked method. If `methodName` is a function, it will
     * be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|String} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = nativeSlice.call(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the `collection`
     * through the `callback`. The `callback` is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (order is not guaranteed)
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(stooges, 'name');
     * // => ['moe', 'larry']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of an `array`. If `callback` is passed,
     * it will be executed for each value in the `array` to generate the
     * criterion by which the value is ranked. The `callback` is bound to
     * `thisArg` and invoked with three arguments; (value, index, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.max(stooges, function(stooge) { return stooge.age; });
     * // => { 'name': 'larry', 'age': 50 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(stooges, 'age');
     * // => { 'name': 'larry', 'age': 50 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      if (!callback && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (!callback && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of an `array`. If `callback` is passed,
     * it will be executed for each value in the `array` to generate the
     * criterion by which the value is ranked. The `callback` is bound to `thisArg`
     * and invoked with three arguments; (value, index, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.min(stooges, function(stooge) { return stooge.age; });
     * // => { 'name': 'moe', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(stooges, 'age');
     * // => { 'name': 'moe', 'age': 40 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      if (!callback && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (!callback && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the `collection`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {String} property The property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.pluck(stooges, 'name');
     * // => ['moe', 'larry']
     */
    function pluck(collection, property) {
      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = collection[index][property];
        }
      }
      return result || map(collection, property);
    }

    /**
     * Reduces a `collection` to a value which is the accumulated result of running
     * each element in the `collection` through the `callback`, where each successive
     * `callback` execution consumes the return value of the previous execution.
     * If `accumulator` is not passed, the first element of the `collection` will be
     * used as the initial `accumulator` value. The `callback` is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [accumulator] Initial value of the accumulator.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is similar to `_.reduce`, except that it iterates over a
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {Mixed} [accumulator] Initial value of the accumulator.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var iterable = collection,
          length = collection ? collection.length : 0,
          noaccum = arguments.length < 3;

      if (typeof length != 'number') {
        var props = keys(collection);
        length = props.length;
      }
      callback = lodash.createCallback(callback, thisArg, 4);
      forEach(collection, function(value, index, collection) {
        index = props ? props[--length] : --length;
        accumulator = noaccum
          ? (noaccum = false, iterable[index])
          : callback(accumulator, iterable[index], index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter`, this method returns the elements of a
     * `collection` that `callback` does **not** return truthy for.
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that did **not** pass the
     *  callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(food, 'organic');
     * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
     *
     * // using "_.where" callback shorthand
     * _.reject(food, { 'type': 'fruit' });
     * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Creates an array of shuffled `array` values, using a version of the
     * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = floor(nativeRandom() * (++index + 1));
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to inspect.
     * @returns {Number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('curly');
     * // => 5
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the `callback` returns a truthy value for **any** element of a
     * `collection`. The function returns as soon as it finds passing value, and
     * does not iterate over the entire `collection`. The `callback` is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Boolean} Returns `true` if any element passes the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(food, 'organic');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(food, { 'type': 'meat' });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in the `collection` through the `callback`. This method
     * performs a stable sort, that is, it will preserve the original sort order of
     * equal elements. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * // using "_.pluck" callback shorthand
     * _.sortBy(['banana', 'strawberry', 'apple'], 'length');
     * // => ['apple', 'banana', 'strawberry']
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      callback = lodash.createCallback(callback, thisArg);
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        object.criteria = callback(value, key, collection);
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|String} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Examines each element in a `collection`, returning an array of all elements
     * that have the given `properties`. When checking `properties`, this method
     * performs a deep comparison between values to determine if they are equivalent
     * to each other.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|String} collection The collection to iterate over.
     * @param {Object} properties The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given `properties`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.where(stooges, { 'age': 40 });
     * // => [{ 'name': 'moe', 'age': 40 }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values of `array` removed. The values
     * `false`, `null`, `0`, `""`, `undefined` and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new filtered array.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array of `array` elements not present in the other arrays
     * using strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {Array} [array1, array2, ...] Arrays to check.
     * @returns {Array} Returns a new array of `array` elements not present in the
     *  other arrays.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          seen = concat.apply(arrayRef, nativeSlice.call(arguments, 1)),
          result = [];

      var isLarge = length >= largeArraySize && indexOf === basicIndexOf;

      if (isLarge) {
        var cache = createCache(seen);
        if (cache) {
          indexOf = cacheIndexOf;
          seen = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(seen, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(seen);
      }
      return result;
    }

    /**
     * This method is similar to `_.find`, except that it returns the index of
     * the element that passes the callback check, instead of the element itself.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the index of the found element, else `-1`.
     * @example
     *
     * _.findIndex(['apple', 'banana', 'beet'], function(food) {
     *   return /^b/.test(food);
     * });
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Gets the first element of the `array`. If a number `n` is passed, the first
     * `n` elements of the `array` are returned. If a `callback` function is passed,
     * elements at the beginning of the array are returned as long as the `callback`
     * returns truthy. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var food = [
     *   { 'name': 'banana', 'organic': true },
     *   { 'name': 'beet',   'organic': false },
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(food, 'organic');
     * // => [{ 'name': 'banana', 'organic': true }]
     *
     * var food = [
     *   { 'name': 'apple',  'type': 'fruit' },
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.first(food, { 'type': 'fruit' });
     * // => [{ 'name': 'apple', 'type': 'fruit' }, { 'name': 'banana', 'type': 'fruit' }]
     */
    function first(array, callback, thisArg) {
      if (array) {
        var n = 0,
            length = array.length;

        if (typeof callback != 'number' && callback != null) {
          var index = -1;
          callback = lodash.createCallback(callback, thisArg);
          while (++index < length && callback(array[index], index, array)) {
            n++;
          }
        } else {
          n = callback;
          if (n == null || thisArg) {
            return array[0];
          }
        }
        return slice(array, 0, nativeMin(nativeMax(0, n), length));
      }
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truthy, `array` will only be flattened a single level. If `callback`
     * is passed, each element of `array` is passed through a `callback` before
     * flattening. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {Boolean} [isShallow=false] A flag to indicate only flattening a single level.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var stooges = [
     *   { 'name': 'curly', 'quotes': ['Oh, a wise guy, eh?', 'Poifect!'] },
     *   { 'name': 'moe', 'quotes': ['Spread out!', 'You knucklehead!'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(stooges, 'quotes');
     * // => ['Oh, a wise guy, eh?', 'Poifect!', 'Spread out!', 'You knucklehead!']
     */
    var flatten = overloadWrapper(function flatten(array, isShallow, callback) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (callback) {
          value = callback(value, index, array);
        }
        // recursively flatten arrays (susceptible to call stack limits)
        if (isArray(value)) {
          push.apply(result, isShallow ? value : flatten(value));
        } else {
          result.push(value);
        }
      }
      return result;
    });

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the `array` is already
     * sorted, passing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Mixed} value The value to search for.
     * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to
     *  perform a binary search on a sorted `array`.
     * @returns {Number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return array ? basicIndexOf(array, value, fromIndex) : -1;
    }

    /**
     * Gets all but the last element of `array`. If a number `n` is passed, the
     * last `n` elements are excluded from the result. If a `callback` function
     * is passed, elements at the end of the array are excluded from the result
     * as long as the `callback` returns truthy. The `callback` is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var food = [
     *   { 'name': 'beet',   'organic': false },
     *   { 'name': 'carrot', 'organic': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(food, 'organic');
     * // => [{ 'name': 'beet',   'organic': false }]
     *
     * var food = [
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' },
     *   { 'name': 'carrot', 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.initial(food, { 'type': 'vegetable' });
     * // => [{ 'name': 'banana', 'type': 'fruit' }]
     */
    function initial(array, callback, thisArg) {
      if (!array) {
        return [];
      }
      var n = 0,
          length = array.length;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Computes the intersection of all the passed-in arrays using strict equality
     * for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} [array1, array2, ...] Arrays to process.
     * @returns {Array} Returns a new array of unique elements that are present
     *  in **all** of the arrays.
     * @example
     *
     * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2]
     */
    function intersection(array) {
      var args = arguments,
          argsLength = args.length,
          argsIndex = -1,
          caches = getArray(),
          index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [],
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = args[argsIndex];
        caches[argsIndex] = indexOf === basicIndexOf &&
          (value ? value.length : 0) >= largeArraySize &&
          createCache(argsIndex ? args[argsIndex] : seen);
      }
      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element of the `array`. If a number `n` is passed, the
     * last `n` elements of the `array` are returned. If a `callback` function
     * is passed, elements at the end of the array are returned as long as the
     * `callback` returns truthy. The `callback` is bound to `thisArg` and
     * invoked with three arguments;(value, index, array).
     *
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Mixed} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var food = [
     *   { 'name': 'beet',   'organic': false },
     *   { 'name': 'carrot', 'organic': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.last(food, 'organic');
     * // => [{ 'name': 'carrot', 'organic': true }]
     *
     * var food = [
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' },
     *   { 'name': 'carrot', 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.last(food, { 'type': 'vegetable' });
     * // => [{ 'name': 'beet', 'type': 'vegetable' }, { 'name': 'carrot', 'type': 'vegetable' }]
     */
    function last(array, callback, thisArg) {
      if (array) {
        var n = 0,
            length = array.length;

        if (typeof callback != 'number' && callback != null) {
          var index = length;
          callback = lodash.createCallback(callback, thisArg);
          while (index-- && callback(array[index], index, array)) {
            n++;
          }
        } else {
          n = callback;
          if (n == null || thisArg) {
            return array[length - 1];
          }
        }
        return slice(array, nativeMax(0, length - n));
      }
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Mixed} value The value to search for.
     * @param {Number} [fromIndex=array.length-1] The index to search from.
     * @returns {Number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Number} [start=0] The start of the range.
     * @param {Number} end The end of the range.
     * @param {Number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(10);
     * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     *
     * _.range(1, 11);
     * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     *
     * _.range(0, 30, 5);
     * // => [0, 5, 10, 15, 20, 25]
     *
     * _.range(0, -10, -1);
     * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = +step || 1;

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so V8 will avoid the slower "dictionary" mode
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / step)),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The opposite of `_.initial`, this method gets all but the first value of
     * `array`. If a number `n` is passed, the first `n` values are excluded from
     * the result. If a `callback` function is passed, elements at the beginning
     * of the array are excluded from the result as long as the `callback` returns
     * truthy. The `callback` is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|Number|String} [callback|n=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is passed, it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var food = [
     *   { 'name': 'banana', 'organic': true },
     *   { 'name': 'beet',   'organic': false },
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.rest(food, 'organic');
     * // => [{ 'name': 'beet', 'organic': false }]
     *
     * var food = [
     *   { 'name': 'apple',  'type': 'fruit' },
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.rest(food, { 'type': 'fruit' });
     * // => [{ 'name': 'beet', 'type': 'vegetable' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which the `value`
     * should be inserted into `array` in order to maintain the sort order of the
     * sorted `array`. If `callback` is passed, it will be executed for `value` and
     * each element in `array` to compute their sort ranking. The `callback` is
     * bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {Mixed} value The value to evaluate.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Number} Returns the index at which the value should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Computes the union of the passed-in arrays using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} [array1, array2, ...] Arrays to process.
     * @returns {Array} Returns a new array of unique values, in order, that are
     *  present in one or more of the arrays.
     * @example
     *
     * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2, 3, 101, 10]
     */
    function union(array) {
      if (!isArray(array)) {
        arguments[0] = array ? nativeSlice.call(array) : arrayRef;
      }
      return uniq(concat.apply(arrayRef, arguments));
    }

    /**
     * Creates a duplicate-value-free version of the `array` using strict equality
     * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`
     * for `isSorted` will run a faster algorithm. If `callback` is passed, each
     * element of `array` is passed through the `callback` before uniqueness is computed.
     * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is passed for `callback`, the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is passed for `callback`, the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.
     * @param {Function|Object|String} [callback=identity] The function called per
     *  iteration. If a property name or object is passed, it will be used to create
     *  a "_.pluck" or "_.where" style callback, respectively.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var uniq = overloadWrapper(function(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === basicIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        if (cache) {
          indexOf = cacheIndexOf;
          seen = cache;
        } else {
          isLarge = false;
          seen = callback ? seen : (releaseArray(seen), result);
        }
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    });

    /**
     * The inverse of `_.zip`, this method splits groups of elements into arrays
     * composed of elements from each group at their corresponding indexes.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @returns {Array} Returns a new array of the composed arrays.
     * @example
     *
     * _.unzip([['moe', 30, true], ['larry', 40, false]]);
     * // => [['moe', 'larry'], [30, 40], [true, false]];
     */
    function unzip(array) {
      var index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an array with all occurrences of the passed values removed using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {Mixed} [value1, value2, ...] Values to remove.
     * @returns {Array} Returns a new filtered array.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return difference(array, nativeSlice.call(arguments, 1));
    }

    /**
     * Groups the elements of each array at their corresponding indexes. Useful for
     * separate data sources that are coordinated through matching array indexes.
     * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix
     * in a similar fashion.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} [array1, array2, ...] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['moe', 'larry'], [30, 40], [true, false]);
     * // => [['moe', 30, true], ['larry', 40, false]]
     */
    function zip(array) {
      return array ? unzip(arguments) : [];
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Pass either
     * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or
     * two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['moe', 'larry'], [30, 40]);
     * // => { 'moe': 30, 'larry': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * If `n` is greater than `0`, a function is created that is restricted to
     * executing `func`, with the `this` binding and arguments of the created
     * function, only after it is called `n` times. If `n` is less than `1`,
     * `func` is executed immediately, without a `this` binding or additional
     * arguments, and its result is returned.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Number} n The number of times the function must be called before
     * it is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var renderNotes = _.after(notes.length, render);
     * _.forEach(notes, function(note) {
     *   note.asyncSave({ 'success': renderNotes });
     * });
     * // `renderNotes` is run once, after all notes have saved
     */
    function after(n, func) {
      if (n < 1) {
        return func();
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * passed to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {Mixed} [thisArg] The `this` binding of `func`.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'moe' }, 'hi');
     * func();
     * // => 'hi moe'
     */
    function bind(func, thisArg) {
      // use `Function#bind` if it exists and is fast
      // (in V8 `Function#bind` is slower except when partially applied)
      return support.fastBind || (nativeBind && arguments.length > 2)
        ? nativeBind.call.apply(nativeBind, arguments)
        : createBound(func, thisArg, nativeSlice.call(arguments, 2));
    }

    /**
     * Binds methods on `object` to `object`, overwriting the existing method.
     * Method names may be specified as individual arguments or as arrays of method
     * names. If no method names are provided, all the function properties of `object`
     * will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *  'label': 'docs',
     *  'onClick': function() { alert('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => alerts 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? concat.apply(arrayRef, nativeSlice.call(arguments, 1)) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = bind(object[key], object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those passed to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {String} key The key of the method.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'moe',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi moe'
     *
     * object.greet = function(greeting) {
     *   return greeting + ', ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hi, moe!'
     */
    function bindKey(object, key) {
      return createBound(object, key, nativeSlice.call(arguments, 2), indicatorObject);
    }

    /**
     * Creates a function that is the composition of the passed functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} [func1, func2, ...] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var greet = function(name) { return 'hi ' + name; };
     * var exclaim = function(statement) { return statement + '!'; };
     * var welcome = _.compose(exclaim, greet);
     * welcome('moe');
     * // => 'hi moe!'
     */
    function compose() {
      var funcs = arguments;
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name, the created callback will return the property value for a given element.
     * If `func` is an object, the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * Note: All Lo-Dash methods, that accept a `callback` argument, use `_.createCallback`.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Mixed} [func=identity] The value to convert to a callback.
     * @param {Mixed} [thisArg] The `this` binding of the created callback.
     * @param {Number} [argCount=3] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(stooges, 'age__gt45');
     * // => [{ 'name': 'larry', 'age': 50 }]
     *
     * // create mixins with support for "_.pluck" and "_.where" callback shorthands
     * _.mixin({
     *   'toLookup': function(collection, callback, thisArg) {
     *     callback = _.createCallback(callback, thisArg);
     *     return _.reduce(collection, function(result, value, index, collection) {
     *       return (result[callback(value, index, collection)] = value, result);
     *     }, {});
     *   }
     * });
     *
     * _.toLookup(stooges, 'name');
     * // => { 'moe': { 'name': 'moe', 'age': 40 }, 'larry': { 'name': 'larry', 'age': 50 } }
     */
    function createCallback(func, thisArg, argCount) {
      if (func == null) {
        return identity;
      }
      var type = typeof func;
      if (type != 'function') {
        if (type != 'object') {
          return function(object) {
            return object[func];
          };
        }
        var props = keys(func);
        return function(object) {
          var length = props.length,
              result = false;
          while (length--) {
            if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
              break;
            }
          }
          return result;
        };
      }
      if (typeof thisArg == 'undefined' || (reThis && !reThis.test(fnToString.call(func)))) {
        return func;
      }
      if (argCount === 1) {
        return function(value) {
          return func.call(thisArg, value);
        };
      }
      if (argCount === 2) {
        return function(a, b) {
          return func.call(thisArg, a, b);
        };
      }
      if (argCount === 4) {
        return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked. Pass
     * an `options` object to indicate that `func` should be invoked on the leading
     * and/or trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true`, `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {Number} wait The number of milliseconds to delay.
     * @param {Object} options The options object.
     *  [leading=false] A boolean to specify execution on the leading edge of the timeout.
     *  [maxWait] The maximum time `func` is allowed to be delayed before it's called.
     *  [trailing=true] A boolean to specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * var lazyLayout = _.debounce(calculateLayout, 300);
     * jQuery(window).on('resize', lazyLayout);
     *
     * jQuery('#postbox').on('click', _.debounce(sendMail, 200, {
     *   'leading': true,
     *   'trailing': false
     * });
     */
    function debounce(func, wait, options) {
      var args,
          result,
          thisArg,
          callCount = 0,
          lastCalled = 0,
          maxWait = false,
          maxTimeoutId = null,
          timeoutId = null,
          trailing = true;

      function clear() {
        clearTimeout(maxTimeoutId);
        clearTimeout(timeoutId);
        callCount = 0;
        maxTimeoutId = timeoutId = null;
      }

      function delayed() {
        var isCalled = trailing && (!leading || callCount > 1);
        clear();
        if (isCalled) {
          if (maxWait !== false) {
            lastCalled = new Date;
          }
          result = func.apply(thisArg, args);
        }
      }

      function maxDelayed() {
        clear();
        if (trailing || (maxWait !== wait)) {
          lastCalled = new Date;
          result = func.apply(thisArg, args);
        }
      }

      wait = nativeMax(0, wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(wait, options.maxWait || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      return function() {
        args = arguments;
        thisArg = this;
        callCount++;

        // avoid issues with Titanium and `undefined` timeout ids
        // https://github.com/appcelerator/titanium_mobile/blob/3_1_0_GA/android/titanium/src/java/ti/modules/titanium/TitaniumModule.java#L185-L192
        clearTimeout(timeoutId);

        if (maxWait === false) {
          if (leading && callCount < 2) {
            result = func.apply(thisArg, args);
          }
        } else {
          var now = new Date;
          if (!maxTimeoutId && !leading) {
            lastCalled = now;
          }
          var remaining = maxWait - (now - lastCalled);
          if (remaining <= 0) {
            clearTimeout(maxTimeoutId);
            maxTimeoutId = null;
            lastCalled = now;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be passed to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
     * @returns {Number} Returns the timer id.
     * @example
     *
     * _.defer(function() { alert('deferred'); });
     * // returns from the function before `alert` is called
     */
    function defer(func) {
      var args = nativeSlice.call(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }
    // use `setImmediate` if it's available in Node.js
    if (isV8 && freeModule && typeof setImmediate == 'function') {
      defer = bind(setImmediate, context);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be passed to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {Number} wait The number of milliseconds to delay execution.
     * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
     * @returns {Number} Returns the timer id.
     * @example
     *
     * var log = _.bind(console.log, console);
     * _.delay(log, 1000, 'logged later');
     * // => 'logged later' (Appears after one second.)
     */
    function delay(func, wait) {
      var args = nativeSlice.call(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * passed, it will be used to determine the cache key for storing the result
     * based on the arguments passed to the memoized function. By default, the first
     * argument passed to the memoized function is used as the cache key. The `func`
     * is executed with the `this` binding of the memoized function. The result
     * cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     */
    function memoize(func, resolver) {
      function memoized() {
        var cache = memoized.cache,
            key = keyPrefix + (resolver ? resolver.apply(this, arguments) : arguments[0]);

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those passed to the new function. This
     * method is similar to `_.bind`, except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('moe');
     * // => 'hi moe'
     */
    function partial(func) {
      return createBound(func, nativeSlice.call(arguments, 1));
    }

    /**
     * This method is similar to `_.partial`, except that `partial` arguments are
     * appended to those passed to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createBound(func, nativeSlice.call(arguments, 1), null, indicatorObject);
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Pass an `options` object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true`, `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {Number} wait The number of milliseconds to throttle executions to.
     * @param {Object} options The options object.
     *  [leading=true] A boolean to specify execution on the leading edge of the timeout.
     *  [trailing=true] A boolean to specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      options = getObject();
      options.leading = leading;
      options.maxWait = wait;
      options.trailing = trailing;

      var result = debounce(func, wait, options);
      releaseObject(options);
      return result;
    }

    /**
     * Creates a function that passes `value` to the `wrapper` function as its
     * first argument. Additional arguments passed to the function are appended
     * to those passed to the `wrapper` function. The `wrapper` is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Mixed} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var hello = function(name) { return 'hello ' + name; };
     * hello = _.wrap(hello, function(func) {
     *   return 'before, ' + func('moe') + ', after';
     * });
     * hello();
     * // => 'before, hello moe, after'
     */
    function wrap(value, wrapper) {
      return function() {
        var args = [value];
        push.apply(args, arguments);
        return wrapper.apply(this, args);
      };
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} string The string to escape.
     * @returns {String} Returns the escaped string.
     * @example
     *
     * _.escape('Moe, Larry & Curly');
     * // => 'Moe, Larry &amp; Curly'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument passed to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Mixed} value Any value.
     * @returns {Mixed} Returns `value`.
     * @example
     *
     * var moe = { 'name': 'moe' };
     * moe === _.identity(moe);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds functions properties of `object` to the `lodash` function and chainable
     * wrapper.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object of function properties to add to `lodash`.
     * @example
     *
     * _.mixin({
     *   'capitalize': function(string) {
     *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     *   }
     * });
     *
     * _.capitalize('moe');
     * // => 'Moe'
     *
     * _('moe').capitalize();
     * // => 'Moe'
     */
    function mixin(object) {
      forEach(functions(object), function(methodName) {
        var func = lodash[methodName] = object[methodName];

        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__,
              args = [value];

          push.apply(args, arguments);
          var result = func.apply(lodash, args);
          return (value && typeof value == 'object' && value === result)
            ? this
            : new lodashWrapper(result);
        };
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * Converts the given `value` into an integer of the specified `radix`.
     * If `radix` is `undefined` or `0`, a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.com/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} value The value to parse.
     * @param {Number} [radix] The radix used to interpret the value to parse.
     * @returns {Number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox and Opera still follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is passed, a number between `0` and the given number will be returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Number} [min=0] The minimum possible value.
     * @param {Number} [max=1] The maximum possible value.
     * @returns {Number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => a number between 0 and 5
     *
     * _.random(5);
     * // => also a number between 0 and 5
     */
    function random(min, max) {
      if (min == null && max == null) {
        max = 1;
      }
      min = +min || 0;
      if (max == null) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      var rand = nativeRandom();
      return (min % 1 || max % 1)
        ? min + nativeMin(rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1))), max)
        : min + floor(rand * (max - min + 1));
    }

    /**
     * Resolves the value of `property` on `object`. If `property` is a function,
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey, then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {String} property The property to get the value of.
     * @returns {Mixed} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, property) {
      var value = object ? object[property] : undefined;
      return isFunction(value) ? object[property]() : value;
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/#custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} options The options object.
     *  escape - The "escape" delimiter regexp.
     *  evaluate - The "evaluate" delimiter regexp.
     *  interpolate - The "interpolate" delimiter regexp.
     *  sourceURL - The sourceURL of the template's compiled source.
     *  variable - The data object variable name.
     * @returns {Function|String} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'moe' });
     * // => 'hello moe'
     *
     * var list = '<% _.forEach(people, function(name) { %><li><%= name %></li><% }); %>';
     * _.template(list, { 'people': ['moe', 'larry'] });
     * // => '<li>moe</li><li>larry</li>'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'curly' });
     * // => 'hello curly'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + epithet); %>!', { 'epithet': 'stooge' });
     * // => 'hello stooge!'
     *
     * // using custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text || (text = '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging and wrap in a multi-line comment to
      // avoid issues with Narwhal, IE conditional compilation, and the JS engine
      // embedded in Adobe products.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source via its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the `callback` function `n` times, returning an array of the results
     * of each `callback` execution. The `callback` is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {Mixed} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = lodash.createCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape`, this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} string The string to unescape.
     * @returns {String} Returns the unescaped string.
     * @example
     *
     * _.unescape('Moe, Larry &amp; Curly');
     * // => 'Moe, Larry & Curly'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is passed, the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {String} [prefix] The value to prefix the ID with.
     * @returns {String} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Invokes `interceptor` with the `value` as the first argument, and then
     * returns `value`. The purpose of this method is to "tap into" a method chain,
     * in order to perform operations on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {Mixed} value The value to pass to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {Mixed} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .filter(function(num) { return num % 2 == 0; })
     *  .tap(alert)
     *  .map(function(num) { return num * num; })
     *  .value();
     * // => // [2, 4] (alerted)
     * // => [4, 16]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {String} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {Mixed} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.countBy = countBy;
    lodash.createCallback = createCallback;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forIn = forIn;
    lodash.forOwn = forOwn;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.range = range;
    lodash.reject = reject;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // add functions to `lodash.prototype`
    mixin(lodash);

    // add Underscore compat
    lodash.chain = lodash;
    lodash.prototype.chain = function() { return this; };

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    forOwn(lodash, function(func, methodName) {
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName] = function() {
          var args = [this.__wrapped__];
          push.apply(args, arguments);
          return func.apply(lodash, args);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(callback, thisArg) {
          var result = func(this.__wrapped__, callback, thisArg);
          return callback == null || (thisArg && typeof callback != 'function')
            ? result
            : new lodashWrapper(result);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type String
     */
    lodash.VERSION = '1.3.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return func.apply(this.__wrapped__, arguments);
      };
    });

    // add `Array` functions that return the wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments));
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash was injected by a third-party script and not intended to be
    // loaded as a module. The global assignment can be reverted in the Lo-Dash
    // module via its `noConflict()` method.
    window._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && !freeExports.nodeType) {
    // in Node.js or RingoJS v0.8.0+
    if (freeModule) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or RingoJS v0.7.0-
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    window._ = _;
  }
}(this));

},{}],2:[function(require,module,exports){
'use strict';

exports.intFromBoolean = function (b) {
    return b ? 1 : 0;
};

exports.booleanFromInt = function (i) {
    return (i === null) ? false : i > 0;
};
},{}],3:[function(require,module,exports){
/**
 * Copyright (c) 2010, Jeash contributors.
 * 
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*

   Contrary to any adobe documentation , points transform with:


   [ X'  Y'  ]   =  [ X  Y  1 ] [  a   b ]
   [  c   d ]
   [  tx  ty]


 */

'use strict';

var core = require('../janicek/core');
var def = core.def;
var matrix = require('./matrix');

module.exports = function (inA, inB, inC, inD, inTx, inTy) {
    
    var pub = {

        a: def(inA, 1.0),
        b: def(inB, 0.0),
        c: def(inC, 0.0),
        d: def(inD, 1.0),
        tx: def(inTx, 0.0),
        ty: def(inTy, 0.0),

        clone: function () { return matrix(pub.a, pub.b, pub.c, pub.d, pub.tx, pub.ty); },

        createGradientBox: function (inWidth, inHeight, rotation, inTx, inTy) {
            pub.a = inWidth / 1638.4;
            pub.d = inHeight / 1638.4;

            // rotation is clockwise
            if (!core.isUndefinedOrNull(rotation) && rotation !== 0.0) {
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);
                pub.b = sin * pub.d;
                pub.c = -sin * pub.a;
                pub.a *= cos;
                pub.d *= cos;
            } else {
                pub.b = pub.c = 0;
            }

            pub.tx = !core.isUndefinedOrNull(inTx) ? inTx + inWidth / 2 : inWidth / 2;
            pub.ty = !core.isUndefinedOrNull(inTy) ? inTy + inHeight / 2 : inHeight / 2;
        },

        setRotation: function (inTheta, inScale) {
            var scale = core.isUndefinedOrNull(inScale) ? 1.0 : inScale;
            pub.a = Math.cos(inTheta) * scale;
            pub.c = Math.sin(inTheta) * scale;
            pub.b = -pub.c;
            pub.d = pub.a;
        },

        invert: function () {
            var norm = pub.a * pub.d - pub.b * pub.c;
            if (norm === 0) {
                pub.a = pub.b = pub.c = pub.d = 0;
                pub.tx = -pub.tx;
                pub.ty = -pub.ty;
            } else {
                norm = 1.0 / norm;
                var a1 = pub.d * norm;
                pub.d = pub.a * norm;
                pub.a = a1;
                pub.b *= -norm;
                pub.c *= -norm;

                var tx1 = - pub.a * pub.tx - pub.c * pub.ty;
                pub.ty = - pub.b * pub.tx - pub.d * pub.ty;
                pub.tx = tx1;
            }
            return this;
        },

        transformPoint: function (inPos) {
            return {x: inPos.x * pub.a + inPos.y * pub.c + pub.tx, y: inPos.x * pub.b + inPos.y * pub.d + pub.ty };
        },

        translate: function (inDX, inDY) {
            pub.tx += inDX;
            pub.ty += inDY;
        },

        /*
           Rotate object "after" other transforms

           [  a  b   0 ][  ma mb  0 ]
           [  c  d   0 ][  mc md  0 ]
           [  tx ty  1 ][  mtx mty 1 ]

           ma = md = cos
           mb = -sin
           mc = sin
           mtx = my = 0

         */

        rotate: function (inTheta) {
            var cos = Math.cos(inTheta);
            var sin = Math.sin(inTheta);

            var a1 = pub.a * cos - pub.b * sin;
            pub.b = pub.a * sin + pub.b * cos;
            pub.a = a1;

            var c1 = pub.c * cos - pub.d * sin;
            pub.d = pub.c * sin + pub.d * cos;
            pub.c = c1;

            var tx1 = pub.tx * cos - pub.ty * sin;
            pub.ty = pub.tx * sin + pub.ty * cos;
            pub.tx = tx1;
        },

        /*

           Scale object "after" other transforms

           [  a  b   0 ][  sx  0   0 ]
           [  c  d   0 ][  0   sy  0 ]
           [  tx ty  1 ][  0   0   1 ]
         */
        scale: function (inSX, inSY) {
            pub.a *= inSX;
            pub.b *= inSY;

            pub.c *= inSX;
            pub.d *= inSY;

            pub.tx *= inSX;
            pub.ty *= inSY;
        },

        /*

           A "translate" . concat "rotate" rotates the translation component.
           ie,

           [X'] = [X][trans][rotate]


           Multiply "after" other transforms ...


           [  a  b   0 ][  ma mb  0 ]
           [  c  d   0 ][  mc md  0 ]
           [  tx ty  1 ][  mtx mty 1 ]


         */
        concat: function (m) {
            var a1 = pub.a * m.a + pub.b * m.c;
            pub.b = pub.a * m.b + pub.b * m.d;
            pub.a = a1;

            var c1 = pub.c * m.a + pub.d * m.c;
            pub.d = pub.c * m.b + pub.d * m.d;
            pub.c = c1;

            var tx1 = pub.tx * m.a + pub.ty * m.c + m.tx;
            pub.ty = pub.tx * m.b + pub.ty * m.d + m.ty;
            pub.tx = tx1;
        },

        mult: function (m) {
            var result = matrix();
            result.a = pub.a * m.a + pub.b * m.c;
            result.b = pub.a * m.b + pub.b * m.d;
            result.c = pub.c * m.a + pub.d * m.c;
            result.d = pub.c * m.b + pub.d * m.d;

            result.tx = pub.tx * m.a + pub.ty * m.c + m.tx;
            result.ty = pub.tx * m.b + pub.ty * m.d + m.ty;
            return result;
        },

        identity: function () {
            pub.a = 1;
            pub.b = 0;
            pub.c = 0;
            pub.d = 1;
            pub.tx = 0;
            pub.ty = 0;
        },

        toMozString: function () {
            var m = 'matrix(';
            m += pub.a + ', ';
            m += pub.b + ', ';
            m += pub.c + ', ';
            m += pub.d + ', ';
            m += pub.tx + 'px, ';
            m += pub.ty + 'px)';
            return m;
        },

        toString: function () {
            var m = 'matrix(';
            m += pub.a + ', ';
            m += pub.b + ', ';
            m += pub.c + ', ';
            m += pub.d + ', ';
            m += pub.tx + ', ';
            m += pub.ty + ')';
            return m;
        }
    };

    return pub;
};
},{"../janicek/core":10,"./matrix":3}],4:[function(require,module,exports){
'use strict';

module.exports = {

    /**
     * The length of the line segment from (0,0) to this point.
     */
    distanceFromOrigin: function (p) {
        return Math.sqrt(p.x * p.x + p.y * p.y);
    },

    distance: function (a, b) {
        return Math.sqrt(Math.pow((a.x - b.x), 2) + Math.pow((a.y - b.y), 2));
    },

    /**
     * Determines a point between two specified points. The parameter f determines where the new interpolated point is 
     * located relative to the two end points specified by parameters pt1 and pt2. The closer the value of the parameter f 
     * is to 1.0, the closer the interpolated point is to the first point (parameter pt1). The closer the value of the
     * parameter f is to 0, the closer the interpolated point is to the second point (parameter pt2).
     * @param   pt1 The first point.
     * @param   pt2 The second point.
     * @param   f The level of interpolation between the two points. Indicates where the new point will be, along the line between pt1 and pt2. If f=1, pt1 is returned; if f=0, pt2 is returned.
     * @return The new, interpolated point.
     */
    interpolate: function (pt1, pt2, f) {
        return { x: (pt1.x - pt2.x) * f + pt2.x, y: (pt1.y - pt2.y) * f + pt2.y };
    },

    /**
     * Scales the line segment between (0,0) and the current point to a set length.
     * @param   thickness The scaling value. For example, if the current point is (0,5), and you normalize it to 1, the point returned is at (0,1).
     */
    normalize: function (p, thickness) {
        if (p.x === 0 && p.y === 0) {
            p.x = thickness;
        }
        else {
            var norm = thickness / Math.sqrt(p.x * p.x + p.y * p.y);
            p.x *= norm;
            p.y *= norm;
        }
    },

    /**
     * Adds the coordinates of 2 points to create a new point.
     */
    add: function (p1, p2) {
        return { x: p2.x + p1.x, y: p2.y + p1.y };
    },

    /**
     * subtract first point and second point
     * @param   p0
     * @param   p1
     * @return
     */
    subtract: function (p0, p1) {
        return { x: p0.x - p1.x, y: p0.y - p1.y };
    },

    hash: function (p) {
        return p.x + ',' + p.y;
    }

};
},{}],5:[function(require,module,exports){
'use strict';

module.exports = function (x, y, width, height) {
    return {
        x: x || 0,
        y: y || 0,
        width: width || 0,
        height: height || 0
    };
};

module.exports.core = function (rectangle) {
    return {
        left: function () { return rectangle.x; },
        right: function () { return rectangle.x + rectangle.width; },
        top: function () { return rectangle.y; },
        bottom: function () { return rectangle.y + rectangle.height; }
    };
};
},{}],6:[function(require,module,exports){
/**
 * Copyright (c) 2010, Jeash contributors.
 * 
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// @r587

/* jshint es3:false */

'use strict';

var def = require('../janicek/core').def;

var Vector3D = function (x, y, z, w) {
    this.w = def(w, 0);
    this.x = def(x, 0);
    this.y = def(y, 0);
    this.z = def(z, 0);
};

Vector3D.prototype = {

    getLength: function () {
        return Math.abs(module.exports.distance(this, module.exports.make()));
    },
    get length() { return this.getLength(); },

    getLengthSquared: function () {
        return this.length * this.length;
    },
    get lengthSquared() { return this.getLengthSquared(); },

    add: function (a) {
        return module.exports.make(this.x + a.x, this.y + a.y, this.z + a.z);
    },

    clone: function () {
        return module.exports.make(this.x, this.y, this.z, this.w);
    },

    crossProduct: function (a) {
        return module.exports.make(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
    },

    decrementBy: function (a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
    },

    dotProduct: function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
    },

    equals: function (toCompare, allFour) {
        allFour = def(allFour, false);
        return this.x === toCompare.x && this.y === toCompare.y && this.z === toCompare.z && (!allFour || this.w === toCompare.w);
    },

    incrementBy: function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
    },

    nearEquals: function (toCompare, tolerance, allFour) {
        allFour = def(allFour, false);
        return Math.abs(this.x - toCompare.x) < tolerance &&
            Math.abs(this.y - toCompare.y) < tolerance &&
            Math.abs(this.z - toCompare.z) < tolerance &&
            (!allFour || Math.abs(this.w - toCompare.w) < tolerance);
    },

    negate: function () {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
    },

    normalize: function () {
        var l = this.length;
        if (l !== 0) {
            this.x /= l;
            this.y /= l;
            this.z /= l;
        }
        return l;
    },

    project: function () {
        this.x /= this.w;
        this.y /= this.w;
        this.z /= this.w;
    },

    scaleBy: function (s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
    },

    subtract: function (a) {
        return module.exports.make(this.x - a.x, this.y - a.y, this.z - a.z);
    },

    toString: function () {
        return 'Vector3D(' + this.x + ', ' + this.y + ', ' + this.z + ')';
    }
};

module.exports = {
    make: function (x, y, z, w) {
        return new Vector3D(x, y, z, w);
    },

    angleBetween: function (a, b) {
        var a0 = a.clone();
        a0.normalize();
        var b0 = b.clone();
        b0.normalize();
        return Math.acos(a0.dotProduct(b0));
    },

    distance: function (pt1, pt2) {
        var x = pt2.x - pt1.x;
        var y = pt2.y - pt1.y;
        var z = pt2.z - pt1.z;
        
        return Math.sqrt(x * x + y * y + z * z);
    },

    get X_AXIS() { return this.make(1, 0, 0); },
    get Y_AXIS() { return this.make(0, 1, 0); },
    get Z_AXIS() { return this.make(0, 0, 1); }
};

},{"../janicek/core":10}],7:[function(require,module,exports){
/* jshint camelcase:false */
'use strict';

var _ = require('lodash');
var canvasCore = require('./janicek/canvas');
var canvasRenderModule = require('./voronoimap/canvas-render');
var colorModule = require('./janicek/html-color');
var islandShapeModule = require('./voronoimap/island-shape');
var lavaModule = require('./voronoimap/lava');
var mapModule = require('./voronoimap/map');
var noisyEdgesModule = require('./voronoimap/noisy-edges');
var prng = require('./janicek/pseudo-random-number-generators');
var roadsModule = require('./voronoimap/roads');
var string = require('./janicek/string');
var style = require('./voronoimap/style');
var watershedsModule = require('./voronoimap/watersheds');
var timer = require('./janicek/timer')();

var html = {
    ID_map: 'map',

    S_addNoise: '#addNoise',
    S_edgeNoise: '#edgeNoise',
    S_fields: '#fields',
    S_fieldset: '#fieldset',
    S_generate: '#generate',
    S_height: '#height',
    S_imageFile: '#imageFile',
    S_imageThreshold: '#imageThreshold',
    S_imageThumb: '#imageThumb',
    S_invertImage: '#invertImage',
    S_islandFactor: '#islandFactor',
    S_islandShape: '#islandShape',
    S_lakeThreshold: '#lakeThreshold',
    S_lloydIterations: '#lloydIterations',
    S_map: '#map',
    S_numberOfLands: '#numberOfLands',
    S_numberOfPoints: '#numberOfPoints',
    S_oceanRatio: '#oceanRatio',
    S_random: '#random',
    S_riverChance: '#riverChance',
    S_roadElevationThresholds: '#roadElevationThresholds',
    S_seed: '#seed',
    S_shapeRandom: '#shapeRandom',
    S_shapeSeed: '#shapeSeed',
    S_toggle: '#toggle',
    S_view: '#view',
    S_viewBridges: '#viewBridges',
    S_viewEdges: '#viewEdges',
    S_viewRivers: '#viewRivers',
    S_viewRoads: '#viewRoads',
    S_viewWatersheds: '#viewWatersheds',
    S_width: '#width'
};

var image;
var state;

function updateThumb() {
    var threshold = $(html.S_imageThreshold).val();
    var color1 = style.displayColors.OCEAN;
    var color2 = style.displayColors.GRASSLAND;
    if ($(html.S_invertImage).is(':checked')) {
        var colorHold = color1;
        color1 = color2;
        color2 = colorHold;
    }
    var thresholdImageData = canvasCore.makeAverageThresholdImageData(canvasCore.getImageData(image), threshold, color1, color2);
    var imageDataUrl = canvasCore.makeImageDataUrlFromImageData(thresholdImageData);
    $(html.S_imageThumb).attr('src', imageDataUrl);
}

function render(state) {
    var c = exports.getContext();
    canvasRenderModule.graphicsReset(c, state.map.SIZE.width, state.map.SIZE.height, style.displayColors);
    switch ($(html.S_view).val()) {
    case 'debug polygons':
        canvasRenderModule.renderDebugPolygons(c, state.map, style.displayColors);
        break;
    case 'smooth':
        canvasRenderModule.renderPolygons(c, style.displayColors, null, canvasRenderModule.colorWithSlope, state.map, state.noisyEdges);
        canvasRenderModule.renderEdges(c, style.displayColors, state.map, state.noisyEdges, state.lava, $(html.S_viewRivers).is(':checked'));
        break;
    }

    if ($(html.S_viewEdges).is(':checked')) {
        canvasRenderModule.renderAllEdges(c, colorModule.rgba(0xd0, 0xd0, 0xd0, 0.25), state.map, state.noisyEdges);
    }

    if ($(html.S_viewRoads).is(':checked')) {
        canvasRenderModule.renderRoads(c, state.map, state.roads, style.displayColors);
    }
    
    if ($(html.S_viewBridges).is(':checked')) {
        canvasRenderModule.renderBridges(c, state.map, state.roads, style.displayColors);
    }
    
    if ($(html.S_viewWatersheds).is(':checked')) {
        canvasRenderModule.renderWatersheds(c, state.map, state.watersheds);
    }
    
    if ($(html.S_addNoise).is(':checked')) {
        canvasCore.addNoiseToCanvas(c, 666, 10, true);
    }
}

exports.initializeUi = function () {
    image = new Image();
    image.onload = function () {
        $(html.S_imageThumb).attr('src', image.src);
        updateThumb();
    };
    image.src = 'world-map.jpg';
    
    $(html.S_random).click(function () {
        $(html.S_seed).val(String(prng.makeRandomSeed()));
    });
    $(html.S_shapeRandom).click(function () {
        $(html.S_shapeSeed).val(String(prng.makeRandomSeed()));
    });
    
    $(html.S_islandShape).change(function (e) {
        $([html.S_islandFactor, html.S_oceanRatio, html.S_shapeSeed, html.S_imageFile, html.S_imageThumb, html.S_invertImage, html.S_imageThreshold].toString()).parent().hide();
        switch ($(html.S_islandShape).val()) {
        case 'bitmap':
            $([html.S_imageFile, html.S_imageThumb, html.S_invertImage, html.S_imageThreshold].toString()).parent().show();
            break;
        case 'noise':
            $(html.S_shapeSeed).parent().show();
            break;
        case 'perlin':
            $([html.S_oceanRatio, html.S_shapeSeed].toString()).parent().show();
            break;
        case 'radial':
            $([html.S_islandFactor, html.S_shapeSeed].toString()).parent().show();
            break;
        }
    });
    
    $(html.S_imageFile).change(function (e) {
        console.log('file changed');
        var fileUpload = $(html.S_imageFile).get()[0];
        var files = fileUpload.files;
        if (files.length === 1) {
            var file = files[0];
            if (string(file.type).startsWith('image')) {
                canvasCore.loadFileIntoImage(file, image);
            }
        }
    });

    $([html.S_invertImage, html.S_imageThreshold].toString()).change(function (e) { updateThumb(); });
    
    if ($(html.S_width).val().length === 0) {
        $(html.S_width).val(String(window.innerWidth));
    }
    if ($(html.S_height).val().length === 0) {
        $(html.S_height).val(String(window.innerHeight));
    }
    
    $(html.S_view).change(function (e) {
        switch ($(html.S_view).val()) {
        case 'debug polygons':
            $(html.S_addNoise).removeAttr('checked');
            break;
        case 'smooth':
            $(html.S_addNoise).attr('checked', 'true');
            break;
        }
    });
    
    $([html.S_view, html.S_viewRivers, html.S_viewRoads, html.S_viewBridges, html.S_viewWatersheds, html.S_viewEdges, html.S_addNoise].toString()).change(function (e) {
        render(state);
    });

    $(html.S_viewRoads).change(function (e) {
        $(html.S_roadElevationThresholds).parent().toggle();
    });
    
    $(html.S_generate).click(function () { state = exports.generate(); });
    
    $(html.S_toggle).click(function () {
        var fields = $(html.S_fields);
        fields.toggle(500, function () {
            $(html.S_toggle).text(fields.is(':visible') ? 'hide' : 'show');
        });
    });
};

exports.getContext = function () {
    var canvas = document.getElementById(html.ID_map);
    return canvas.getContext('2d');
};

function findOrCreateCanvas() {
    var canvas = document.getElementById(html.ID_map);
    if (canvas === null) {
        canvas = document.createElement('canvas');
        canvas.id = html.ID_map;
        document.body.appendChild(canvas);
    }
    
    return canvas;
}

function getIntegerOrStringSeed(s) {
    if (_(s).isNumber()) {
        return _(s).parseInt();
    }
    
    return Math.abs(prng.stringToSeed(s));
}

exports.generate = function () {
    timer.start();

    var state = { map : null, noisyEdges : null, roads : null, watersheds : null, lava : null };
    
    var canvas = findOrCreateCanvas();
    canvas.width = _($(html.S_width).val()).parseInt();
    canvas.height = _($(html.S_height).val()).parseInt();
    
    state.map = mapModule.make({ width: canvas.width + 0.0, height: canvas.height + 0.0 });
    var seed = getIntegerOrStringSeed($(html.S_seed).val());
    var shapeSeed = getIntegerOrStringSeed($(html.S_shapeSeed).val());
    
    var islandShape = $(html.S_islandShape).val();
    
    switch (islandShape) {
    case 'bitmap' :
        var imageData = canvasCore.getImageData(image);
        console.log($(html.S_imageThreshold).val());
        var bitmap = canvasCore.makeAverageThresholdBitmap(imageData, $(html.S_imageThreshold).val());
        if ($(html.S_invertImage).is(':checked')) {
            bitmap = bitmap.invertBitmap();
        }
        state.map.newIsland(islandShapeModule.makeBitmap(bitmap), seed);
        break;
    case 'blob' :
        state.map.newIsland(islandShapeModule.makeBlob(), seed);
        break;
    case 'noise' :
        state.map.newIsland(islandShapeModule.makeNoise(shapeSeed), seed);
        break;
    case 'perlin' :
        state.map.newIsland(islandShapeModule.makePerlin(shapeSeed, $(html.S_oceanRatio).val()), seed);
        break;
    case 'radial' :
        state.map.newIsland(islandShapeModule.makeRadial(shapeSeed, $(html.S_islandFactor).val()), seed);
        break;
    case 'square' :
        state.map.newIsland(islandShapeModule.makeSquare(), seed);
        break;
    }
    
    state.watersheds = watershedsModule();
    state.noisyEdges = noisyEdgesModule.make();
    state.lava = lavaModule.make();
    state.roads = roadsModule();
    
    var numberOfLands = $(html.S_numberOfLands).val();
    if (_(numberOfLands).isNumber()) {
        mapModule.tryMutateMapPointsToGetNumberLands(state.map, numberOfLands, 30, numberOfLands * 2);
    }
    else {
        state.map.go0PlacePoints($(html.S_numberOfPoints).val());
        state.map.go1ImprovePoints($(html.S_lloydIterations).val());
        state.map.go2BuildGraph();
        state.map.go3AssignElevations($(html.S_lakeThreshold).val());
    }
    state.map.go4AssignMoisture($(html.S_riverChance).val());
    state.map.go5DecorateMap();
    
    var thresholds = $(html.S_roadElevationThresholds).val().split(',');
    state.roads.createRoads(state.map, thresholds);
    state.watersheds.createWatersheds(state.map);
    state.noisyEdges.buildNoisyEdges(state.map, state.lava, seed, $(html.S_edgeNoise).val());

    timer.log('generate');
    
    render(state);

    timer.log('render');

    return state;
};

// ----------------------------------------------------------------------------
// Main

function main() {
    exports.initializeUi();
    state = exports.generate();
    require('./janicek/log').logCounters();
}

main();
},{"./janicek/canvas":9,"./janicek/html-color":12,"./janicek/log":13,"./janicek/pseudo-random-number-generators":16,"./janicek/string":17,"./janicek/timer":18,"./voronoimap/canvas-render":39,"./voronoimap/island-shape":43,"./voronoimap/lava":44,"./voronoimap/map":45,"./voronoimap/noisy-edges":46,"./voronoimap/roads":47,"./voronoimap/style":48,"./voronoimap/watersheds":49,"lodash":1}],8:[function(require,module,exports){
/* jshint bitwise:false */

'use strict';

var core = require('./core');
var _ = require('lodash');

/**
 * Two dimensional array functions.
 */
module.exports = function (array) {
    array = core.def(array, []);
    return {

        value: array,

         /**
         * Get value at index.
         */
        get: function (x, y) {
            if (_(array[y]).isUndefined()) {
                return null;
            }
            return array[y][x];
        },

        /**
         * Set value at index.
         */
        set: function (x, y, value) {
            array[y] = core.def(array[y], []);
            array[y][x] = value;
            return array;
        },

        /**
         * Compute two dimensional indices of a flat index based on array width and block size.
         * @param {int} index
         * @param {int} width
         * @param {int} blockSize
         */
        getIndices: function (index, width, blockSize) {
            blockSize = core.def(blockSize, 1);
            return {
                x : (index / blockSize) % width,
                y : core.toInt((index / blockSize) / width)
            };
        },

        /**
         * Iterate rows.
         * @param  {function} returnRow
         */
        foreachY: function (returnRow) {
            _(array).each(function (y) {
                if (!_(y).isUndefined()) {
                    returnRow(y);
                }
            });
        },

        /**
         * Iterate cells.
         * @param  {function} returnXYAndValue
         */
        foreachXY: function (returnXYAndValue) {
            var yIndex;
            for (yIndex = 0; yIndex < array.length; yIndex++) {
                if (!_(array[yIndex]).isUndefined()) {
                    var xIndex;
                    for (xIndex = 0; xIndex < array[yIndex].length; xIndex++) {
                        if (!_(array[yIndex][xIndex]).isUndefined()) {
                            var value = array[yIndex][xIndex];
                            if (value !== null) {
                                returnXYAndValue(xIndex, yIndex, value);
                            }
                        }
                    }
                }
            }
        },

        /**
         * Find index of anything in array.
         * @param  {function} testValue Function should return true for match, else false.
         */
        any: function (testValue) {
            var yIndex;
            for (yIndex = 0; yIndex < array.length; yIndex++) {
                if (!_(array[yIndex]).isUndefined()) {
                    var xIndex;
                    for (xIndex = 0; xIndex < array[yIndex].length; xIndex++) {
                        if (!_(array[yIndex][xIndex]).isUndefined()) {
                            var value = array[yIndex][xIndex];
                            if (value !== null) {
                                if (testValue(value)) {
                                    return {x: xIndex, y: yIndex };
                                }
                            }
                        }
                    }
                }
            }
            return null;
        },

        /**
         * Get dimensions of array.
         * @return {object} x is width, y is height
         */
        dimensions: function () {
            var height = array.length;
            var width = 0;
            
            this.foreachY(function (y) {
                width = Math.max(width, y.length);
            });

            return {x: width, y: height};
        }
    };
};
},{"./core":10,"lodash":1}],9:[function(require,module,exports){
'use strict';

var core = require('./core');
var htmlColor = require('./html-color');
var math = require('./math');
var prng = require('./pseudo-random-number-generators');


var CANVAS_ELEMENTS_PER_PIXEL = 4;
var CANVAS_RED_OFFSET = 0;
var CANVAS_GREEN_OFFSET = 1;
var CANVAS_BLUE_OFFSET = 2;
var CANVAS_ALPHA_OFFSET = 3;


/**
 * Iterate canvas pixel array color channels.
 * Functor is called with red, green, blue, and alpha channel values for each pixel.
 * Functor can return new color channel values which will be assigned to pixel. Null values are ignored.
 * 
 * Can be used to analyze and transform a canvas pixel array.
 */
exports.renderCanvasPixelArray = function (imageData, f) {
    var pixels = imageData.data;
    var index;
    for (var i = 0; i < core.toInt(pixels.length / CANVAS_ELEMENTS_PER_PIXEL); i++) {
        index = i * CANVAS_ELEMENTS_PER_PIXEL;
        var newValues = f(index, pixels[index + CANVAS_RED_OFFSET], pixels[index + CANVAS_GREEN_OFFSET], pixels[index + CANVAS_BLUE_OFFSET], pixels[index + CANVAS_ALPHA_OFFSET]);
        if (newValues !== null) {
            if (newValues.red !== null) {
                pixels[index + CANVAS_RED_OFFSET] = newValues.red;
            }
            if (newValues.green !== null) {
                pixels[index + CANVAS_GREEN_OFFSET] = newValues.green;
            }
            if (newValues.blue !== null) {
                pixels[index + CANVAS_BLUE_OFFSET] = newValues.blue;
            }
            if (newValues.alpha !== null) {
                pixels[index + CANVAS_ALPHA_OFFSET] = newValues.alpha;
            }
        }
    }
};

/**
 * Add random noise to image data by modifying each pixel color channel by a random amount between + and - noiseLevel.
 * @param   noiseLevel Value between 1 and 255
 * @param   grayScale True to change all color channels by same amount so only brightness of pixel is changed and not color. Doesn't affect alpha. (Default = false)
 * @param   red Add noise to red channel. (Default = true)
 * @param   green Add noise to green channel. (Default = true)
 * @param   blue Add noise to blue channel. (Default = true)
 * @param   alpha Add noise to alpha channel. (Default = false)
 * @return  New bitmap containing the bitmap passed in with noise added.
 */
exports.addNoise = function (pixelData, randomSeed, noiseLevel, grayScale, changeRed, changeGreen, changeBlue, changeAlpha) {

    grayScale = core.def(grayScale, false);
    changeRed = core.def(changeRed, true);
    changeGreen = core.def(changeGreen, true);
    changeBlue = core.def(changeBlue, true);
    changeAlpha = core.def(changeAlpha, false);

    var gen = prng.randomGenerator(randomSeed, prng.nextParkMiller);

    noiseLevel = math.clamp(noiseLevel, 1, 255);
    var delta;
    
    exports.renderCanvasPixelArray(pixelData, function (index, red, green, blue, alpha) {
        delta = prng.toIntRange(gen(), -noiseLevel, noiseLevel);
        var newColors = { red: null, green: null, blue: null, alpha: null };
        if (changeRed) {
            newColors.red = red + delta;
        }
        if (changeGreen) {
            newColors.green = green + (grayScale ? delta : prng.toIntRange(gen(), -noiseLevel, noiseLevel));
        }
        if (changeBlue) {
            newColors.blue = blue + (grayScale ? delta : prng.toIntRange(gen(), -noiseLevel, noiseLevel));
        }
        if (changeAlpha) {
            newColors.alpha = alpha + prng.toIntRange(gen(), -noiseLevel, noiseLevel);
        }
        return newColors;
    });
    
    return pixelData;
};

/**
 * Add noise to canvas.
 * @param   context Canvas drawing context.
 * @param   randomSeed Random seed to use to make random noise.
 * @param   noiseLevel Value between 1 and 255
 * @param   grayScale True to change all color channels by same amount so only brightness of pixel is changed and not color. Doesn't affect alpha. (Default = false)
 * @param   red Add noise to red channel. (Default = true)
 * @param   green Add noise to green channel. (Default = true)
 * @param   blue Add noise to blue channel. (Default = true)
 * @param   alpha Add noise to alpha channel. (Default = false)
 */
exports.addNoiseToCanvas = function (context, randomSeed, noiseLevel, grayScale, red, green, blue, alpha) {
    grayScale = core.def(grayScale, false);
    red = core.def(red, true);
    green = core.def(green, true);
    blue = core.def(blue, true);
    alpha = core.def(alpha, false);

    var imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    imageData = exports.addNoise(imageData, randomSeed, noiseLevel, grayScale, red, green, blue, alpha);
    context.putImageData(imageData, 0, 0);
};

// ------------------------------------------------------------------------
// Images

/**
 * Load a file into an image.
 */
exports.loadFileIntoImage = function (file, img) {
    var reader = new FileReader();
    reader.onload = function (event) {
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
};

/**
 * Get image data from an HTML image.
 */
exports.getImageData = function (image) {
    var canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(image, 0, 0);
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    return imageData;
};

/**
 * Make image data URL from image data.
 */
exports.makeImageDataUrlFromImageData = function (imageData) {
    var canvas = document.createElement('canvas');
    canvas.width = imageData.width;
    canvas.height = imageData.height;
    canvas.getContext('2d').putImageData(imageData, 0, 0);
    return canvas.toDataURL();
};

// ------------------------------------------------------------------------
// Monochrome Converters

/**
 * Converts HTML5 image data to monochrome image data by comparing the average of each color channel to a
 * threshold value to determine which color channels are converted to target monochrome colors.
 * @param   threshold Value between 0 and 255.
 * @param   lessthanThresholdColor Color to use for pixels below threshold.
 * @param   greaterthanOrEqualToThresholdColor Color to use for pixels equal to or above threshold.
 * @param   alpha Optioal alpha to assign to result pixels. (default = 1.0)
 */
exports.makeAverageThresholdImageData = function (imageData, threshold, lessthanThresholdColor, greaterthanOrEqualToThresholdColor, alpha) {
    alpha = core.def(alpha, 1.0);
    var intAlpha = htmlColor.colorFraction(alpha);
    exports.renderCanvasPixelArray(imageData, function (index, red, green, blue, alpha) {
        var color = math.average([red, green, blue]) >= threshold ? greaterthanOrEqualToThresholdColor : lessthanThresholdColor;
        return {
            red : htmlColor.getRedComponent(color),
            green : htmlColor.getGreenComponent(color),
            blue : htmlColor.getBlueComponent(color),
            alpha : intAlpha
        };
    });
    return imageData;
};
},{"./core":10,"./html-color":12,"./math":14,"./pseudo-random-number-generators":16}],10:[function(require,module,exports){
/* jshint bitwise:false */

'use strict';

var _ = require('lodash');

module.exports = {
    /**
     * Return value or default if undefined.
     * Usefull for assigning argument default values.
     */
    def: function (value, defaultValue) {
        return _.isUndefined(value) ? defaultValue : value;
    },

    toInt: function (something) {
        return something | 0;
    },

    /**
     * Return first argument that is not undefined and not null.
     */
    coalesce: function () {
        return _.find(arguments, function (arg) {
            return !_.isNull(arg) && !_.isUndefined(arg);
        });
    },

    isUndefinedOrNull: function (thing) {
        return _.isUndefined(thing) || _.isNull(thing);
    }
};
},{"lodash":1}],11:[function(require,module,exports){
/**
 * janicek-core-js
 * ------------------
 * My personal collection of JavaScript core libraries.
 * Copyright (c) 2013 Richard Janicek, http://www.janicek.co
 * 
 * The MIT License (MIT) http://www.opensource.org/licenses/mit-license.php
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* jshint bitwise:false */

'use strict';

/**
 * Compute string hash using djb2 algorithm.
 * 
 * Has a good balance of being extremely fast, while providing a reasonable distribution of hash values.
 * @see http://www.cse.yorku.ca/~oz/hash.html
 */
exports.djb2 = function (string) {
    var hash = 5381;
    var i;
    for (i = 0; i < string.length; i++) {
        hash = ((hash << 5) + hash) + string.charCodeAt(i);
    }
    return hash;
};

/**
 * Compute string hash using sdbm algorithm.
 * 
 * This algorithm was created for sdbm (a public-domain reimplementation of ndbm) database library.
 * It was found to do well in scrambling bits, causing better distribution of the keys and fewer splits.
 * It also happens to be a good general hashing function with good distribution.
 * @see http://www.cse.yorku.ca/~oz/hash.html
 */
exports.sdbm = function (string) {
    var hash = 0;
    var i;
    for (i = 0; i < string.length; i++) {
        hash = string.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;
    }
    return hash;
};

/**
 * Java's String.hashCode() method implemented in Haxe.
 * @see http://docs.oracle.com/javase/1.4.2/docs/api/java/lang/String.html#hashCode%28%29
 */
exports.javaHashCode = function (string) {
    var hash = 0;
    if (string.length === 0) { return hash; }
    for (var i = 0; i < string.length; i++) {
        hash = ((hash << 5) - hash) + string.charCodeAt(i);
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
};
},{}],12:[function(require,module,exports){
/* jshint bitwise:false */

'use strict';

var core = require('./core');

exports.MAX_COLOR_COMPONENT = 0xff;

/**
 * Get red component of Int color.
 */
exports.getRedComponent = function (c) {
    return (c >> 16) & 0xff;
};

/**
 * Get green component of Int color.
 */
exports.getGreenComponent = function (c) {
    return (c >> 8) & 0xff;
};

/**
 * Get blue component of Int color.
 */
exports.getBlueComponent = function (c) {
    return c & 0xff;
};

/**
 * Interpolate color between color0 and color1 using fraction f. When f==0, result is color0. When f==1, result is color1.
 * @author Amit Patel
 */
exports.interpolateColor = function (color0, color1, f) {
    var r = core.toInt((1 - f) * (color0 >> 16) + f * (color1 >> 16));
    var g = core.toInt((1 - f) * ((color0 >> 8) & 0xff) + f * ((color1 >> 8) & 0xff));
    var b = core.toInt((1 - f) * (color0 & 0xff) + f * (color1 & 0xff));
    if (r > 255) { r = 255; }
    if (g > 255) { g = 255; }
    if (b > 255) { b = 255; }
    return (r << 16) | (g << 8) | b;
};

/**
 * Convert a fraction (0.0 - 1.0) to a color value (0 - 0xff).
 */
exports.colorFraction = function (fraction) {
    return core.toInt(exports.MAX_COLOR_COMPONENT * fraction);
};

/**
 * Make HTML hex color string from Int value. Example: 0 -> #000000
 * @param   color Int color value.
 * @return  HTML color string.
 */
exports.intToHexColor = function (color) {
    return '#' + ('00000' + color.toString(16).toUpperCase()).substr(-6);
};

/**
 * Make HTML rgb(r,g,b,a) color string.
 * @param   red Red channel (0 - 0xff).
 * @param   green Green channel (0 - 0xff).
 * @param   blue Blue channel (0 - 0xff).
 */
exports.rgb = function (red, green, blue) {
    return 'rgb(' + red + ',' + green + ',' + blue + ')';
};

/**
 * Make HTML rgba(r,g,b,a) color string.
 * @param   red Red channel (0 - 0xff).
 * @param   green Green channel (0 - 0xff).
 * @param   blue Blue channel (0 - 0xff).
 * @param   alpha Alpha channel (0.0 - 1.0).
 */
exports.rgba = function (red, green, blue, alpha) {
    return 'rgba(' + red + ',' + green + ',' + blue + ',' + alpha + ')';
};

/**
 * Make HTML rgb(r,g,b) color string using fractions.
 * @param   red Red channel (0.0 - 1.0).
 * @param   green Green channel (0.0 - 1.0).
 * @param   blue Blue channel (0.0 - 1.0).
 */
exports.rgbF = function (red, green, blue) {
    return 'rgb(' + red * 100 + '%,' + green * 100 + '%,' + blue * 100 + '%)';
};

/**
 * Make HTML rgba(r,g,b,a) color string using fractions.
 * @param   red Red channel (0.0 - 1.0).
 * @param   green Green channel (0.0 - 1.0).
 * @param   blue Blue channel (0.0 - 1.0).
 * @param   alpha Alpha channel (0.0 - 1.0).
 */
exports.rgbaF = function (red, green, blue, alpha) {
    return 'rgba(' + red * 100 + '%,' + green * 100 + '%,' + blue * 100 + '%,' + alpha + ')';
};

/**
 * Make HTML hsl(h,s,l) color string.
 * @param   hue A degree on the color wheel (from 0 to 360) - 0 (or 360) is red, 120 is green, 240 is blue. 
 * @param   saturation A percentage value; 0.0 means a shade of gray and 1.0 is the full color.
 * @param   lightness Lightness is also a percentage; 0.0 is black, 1.0 is white.
 * @return  HTML color string.
 */
exports.hsl = function (hue, saturation, lightness) {
    return 'hsl(' + hue + ',' + saturation * 100 + '%,' + lightness * 100 + '%)';
};

/**
 * Make HTML hsla(h,s,l,a) color string.
 * @param   hue A degree on the color wheel (from 0 to 360) - 0 (or 360) is red, 120 is green, 240 is blue. 
 * @param   saturation A percentage value; 0.0 means a shade of gray and 1.0 is the full color.
 * @param   lightness Lightness is also a percentage; 0.0 is black, 1.0 is white.
 * @param   alpha Number between 0.0 (fully transparent) and 1.0 (fully opaque).
 * @return  HTML color string.
 */
exports.hsla = function (hue, saturation, lightness, alpha) {
    return 'hsla(' + hue + ',' + saturation * 100 + '%,' + lightness * 100 + '%,' + alpha + ')';
};
},{"./core":10}],13:[function(require,module,exports){
'use strict';

var _ = require('lodash');

exports.counters = {};

exports.bumpCounter = function (counter) {
    if (!exports.counters[counter]) {
        exports.counters[counter] = 0;
    }
    exports.counters[counter]++;
};

exports.logCounters = function () {
    _.each(exports.counters, function (counter, key) {
        console.log(key, counter);
    });
};
},{"lodash":1}],14:[function(require,module,exports){
'use strict';

var _ = require('lodash');

exports.average = function (numbers) {
    return _.reduce(numbers, function (total, number) {
        return total + number;
    }) / _.size(numbers);
};

/**
 * clamp a Float to an interval
 * interval endpoints are compared to get min and max, so it doesn't matter what order they are passed in
 * @param   value value to clamp
 * @param   minOrMax1 interval endpoint
 * @param   minOrMax2 interval endpoint
 * @return  clamped value to given interval
 */
exports.clamp = function (value, minOrMax1, minOrMax2) {
    var min = Math.min(minOrMax1, minOrMax2);
    var max = Math.max(minOrMax1, minOrMax2);
    return value < min ? min : value > max ? max : value;
};
},{"lodash":1}],15:[function(require,module,exports){
/* jshint bitwise:false */

/**
Title:          Perlin noise
Version:        1.3
Author:         Ron Valstar
Author URI:     http://www.sjeiti.com/
Original code port from http://mrl.nyu.edu/~perlin/noise/
and some help from http://freespace.virgin.net/hugo.elias/models/m_perlin.htm
AS3 optimizations by Mario Klingemann http://www.quasimondo.com
Haxe port and optimization by Nicolas Cannasse http://haxe.org
JavaScript port and simplified by Richard Janicek http://janicek.co
*/

'use strict';

var def = require('./core').def;
var array2d = require('./array2d');

var p = [
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
    96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69,
    142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148,
    247, 120, 234, 75, 0, 26, 197, 62, 94, 252,
    219, 203, 117, 35, 11, 32, 57, 177, 33, 88,
    237, 149, 56, 87, 174, 20, 125, 136, 171,
    168, 68, 175, 74, 165, 71, 134, 139, 48, 27,
    166, 77, 146, 158, 231, 83, 111, 229, 122,
    60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
    245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
    1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
    18, 169, 200, 196, 135, 130, 116, 188, 159,
    86, 164, 100, 109, 198, 173, 186, 3, 64, 52,
    217, 226, 250, 124, 123, 5, 202, 38, 147, 118,
    126, 255, 82, 85, 212, 207, 206, 59, 227, 47,
    16, 58, 17, 182, 189, 28, 42, 223, 183, 170,
    213, 119, 248, 152, 2, 44, 154, 163, 70, 221,
    153, 101, 155, 167, 43, 172, 9, 129, 22, 39,
    253, 19, 98, 108, 110, 79, 113, 224, 232,
    178, 185, 112, 104, 218, 246, 97, 228, 251,
    34, 242, 193, 238, 210, 144, 12, 191, 179,
    162, 241, 81, 51, 145, 235, 249, 14, 239,
    107, 49, 192, 214, 31, 181, 199, 106, 157,
    184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
    150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
    24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
    156, 180, 151, 160, 137, 91, 90, 15, 131, 13,
    201, 95, 96, 53, 194, 233, 7, 225, 140, 36,
    103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
    190, 6, 148, 247, 120, 234, 75, 0, 26, 197,
    62, 94, 252, 219, 203, 117, 35, 11, 32, 57,
    177, 33, 88, 237, 149, 56, 87, 174, 20, 125,
    136, 171, 168, 68, 175, 74, 165, 71, 134, 139,
    48, 27, 166, 77, 146, 158, 231, 83, 111, 229,
    122, 60, 211, 133, 230, 220, 105, 92, 41, 55,
    46, 245, 40, 244, 102, 143, 54, 65, 25, 63,
    161, 1, 216, 80, 73, 209, 76, 132, 187, 208,
    89, 18, 169, 200, 196, 135, 130, 116, 188,
    159, 86, 164, 100, 109, 198, 173, 186, 3, 64,
    52, 217, 226, 250, 124, 123, 5, 202, 38, 147,
    118, 126, 255, 82, 85, 212, 207, 206, 59,
    227, 47, 16, 58, 17, 182, 189, 28, 42, 223,
    183, 170, 213, 119, 248, 152, 2, 44, 154,
    163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
    129, 22, 39, 253, 19, 98, 108, 110, 79, 113,
    224, 232, 178, 185, 112, 104, 218, 246, 97,
    228, 251, 34, 242, 193, 238, 210, 144, 12,
    191, 179, 162, 241, 81, 51, 145, 235, 249,
    14, 239, 107, 49, 192, 214, 31, 181, 199,
    106, 157, 184, 84, 204, 176, 115, 121, 50,
    45, 127, 4, 150, 254, 138, 236, 205, 93,
    222, 114, 67, 29, 24, 72, 243, 141, 128,
    195, 78, 66, 215, 61, 156, 180
];

/*
 * Makes some Perlin Noise.
 * @returns [[int]] A bitmap of Perlin Noise.
 */
exports.makePerlinNoise = function (width, height, _x, _y, _z, seed, octaves, falloff) {
    seed = def(seed, 666);
    octaves = def(octaves, 4);
    falloff = def(falloff, 0.5);

    var baseFactor = 1 / 64;
    
    var iXoffset = seed = (seed * 16807.0) % 2147483647;
    var iYoffset = seed = (seed * 16807.0) % 2147483647;
    var iZoffset = seed = (seed * 16807.0) % 2147483647;
  
    var aOctFreq = []; // frequency per octave
    var aOctPers = []; // persistence per octave
    var fPersMax = 0.0; // 1 / max persistence

    var fFreq, fPers;

    var i;
    for (i = 0; i < octaves; i++) {
        fFreq = Math.pow(2, i);
        fPers = Math.pow(falloff, i);
        fPersMax += fPers;
        aOctFreq.push(fFreq);
        aOctPers.push(fPers);
    }

    fPersMax = 1 / fPersMax;

    var bitmap = array2d([]); // Array<Array<Int>>
    
    var baseX = _x * baseFactor + iXoffset;
    _y = _y * baseFactor + iYoffset;
    _z = _z * baseFactor + iZoffset;

    var py;
    for (py = 0; py < height; py++) {
        _x = baseX;
        
        var px;
        for (px = 0; px < width; px++) {
            var s = 0.0;

            for (i = 0; i < octaves; i++) {
                var fFreq2 = aOctFreq[i];
                var fPers2 = aOctPers[i];

                var x = _x * fFreq2;
                var y = _y * fFreq2;
                var z = _z * fFreq2;

                var xf = x - (x % 1);
                var yf = y - (y % 1);
                var zf = z - (z % 1);

                var X = xf & 255;
                var Y = yf & 255;
                var Z = zf & 255;

                x -= xf;
                y -= yf;
                z -= zf;

                var u = x * x * x * (x * (x * 6 - 15) + 10);
                var v = y * y * y * (y * (y * 6 - 15) + 10);
                var w = z * z * z * (z * (z * 6 - 15) + 10);

                var A  = (p[X]) + Y;
                var AA = (p[A]) + Z;
                var AB = (p[A + 1]) + Z;
                var B  = (p[X + 1]) + Y;
                var BA = (p[B]) + Z;
                var BB = (p[B + 1]) + Z;

                var x1 = x - 1;
                var y1 = y - 1;
                var z1 = z - 1;

                var hash = (p[BB + 1]) & 15;
                var g1 = ((hash&1) === 0 ? (hash < 8 ? x1 : y1) : (hash < 8 ? -x1 : -y1)) + ((hash&2) === 0 ? hash < 4 ? y1 : (hash === 12 ? x1 : z1) : hash < 4 ? -y1 : (hash === 14 ? -x1 : -z1));

                hash = (p[AB + 1]) & 15;
                var g2 = ((hash&1) === 0 ? (hash < 8 ? x  : y1) : (hash < 8 ? -x  : -y1)) + ((hash&2) === 0 ? hash < 4 ? y1 : (hash === 12 ? x  : z1) : hash < 4 ? -y1 : (hash === 14 ? -x : -z1));

                hash = (p[BA + 1]) & 15;
                var g3 = ((hash&1) === 0 ? (hash < 8 ? x1 : y) : (hash < 8 ? -x1 : -y)) + ((hash&2) === 0 ? hash < 4 ? y  : (hash === 12 ? x1 : z1) : hash < 4 ? -y  : (hash === 14 ? -x1 : -z1));

                hash = (p[AA + 1]) & 15;
                var g4 = ((hash&1) === 0 ? (hash < 8 ? x  : y) : (hash < 8 ? -x  : -y)) + ((hash&2) === 0 ? hash < 4 ? y  : (hash === 12 ? x  : z1) : hash < 4 ? -y  : (hash === 14 ? -x  : -z1));

                hash = (p[BB]) & 15;
                var g5 = ((hash&1) === 0 ? (hash < 8 ? x1 : y1) : (hash < 8 ? -x1 : -y1)) + ((hash&2) === 0 ? hash < 4 ? y1 : (hash === 12 ? x1 : z) : hash < 4 ? -y1 : (hash === 14 ? -x1 : -z));

                hash = (p[AB]) & 15;
                var g6 = ((hash&1) === 0 ? (hash < 8 ? x  : y1) : (hash < 8 ? -x  : -y1)) + ((hash&2) === 0 ? hash < 4 ? y1 : (hash === 12 ? x  : z) : hash < 4 ? -y1 : (hash === 14 ? -x  : -z));

                hash = (p[BA]) & 15;
                var g7 = ((hash&1) === 0 ? (hash < 8 ? x1 : y) : (hash < 8 ? -x1 : -y)) + ((hash&2) === 0 ? hash < 4 ? y  : (hash === 12 ? x1 : z) : hash < 4 ? -y  : (hash === 14 ? -x1 : -z));

                hash = (p[AA]) & 15;
                var g8 = ((hash&1) === 0 ? (hash < 8 ? x  : y) : (hash < 8 ? -x  : -y)) + ((hash&2) === 0 ? hash < 4 ? y  : (hash === 12 ? x  : z) : hash < 4 ? -y  : (hash === 14 ? -x  : -z));

                g2 += u * (g1 - g2);
                g4 += u * (g3 - g4);
                g6 += u * (g5 - g6);
                g8 += u * (g7 - g8);

                g4 += v * (g2 - g4);
                g8 += v * (g6 - g8);

                s += (g8 + w * (g4 - g8)) * fPers2;
            }

            var color = (s * fPersMax + 1) * 128;

            bitmap.set(px, py, 0xff000000 | color << 16 | color << 8 | color);

            _x += baseFactor;
        }

        _y += baseFactor;
    }
    return bitmap.value;
};
},{"./array2d":8,"./core":10}],16:[function(require,module,exports){
/* jshint bitwise:false */

'use strict';

var hash = require('./hash');

/**
 * (a Mersenne prime M31) modulus constant = 2^31 - 1 = 0x7ffffffe
 */
var MPM = 2147483647.0;

/**
 * (a primitive root modulo M31)
 */
var MINSTD = 16807.0;

/**
 * Make a non deterministic random seed using standard libraries.
 * @return Non deterministic random seed.
 */
exports.makeRandomSeed = function () {
    return Math.floor(Math.random() * MPM);
};

/**
 * Park-Miller-Carta algorithm.
 * @see <a href="http://lab.polygonal.de/?p=162">http://lab.polygonal.de/?p=162</a>
 * @see <a href="http://code.google.com/p/polygonal/source/browse/trunk/src/lib/de/polygonal/core/math/random/ParkMiller.hx?r=547">http://code.google.com/p/polygonal/source/browse/trunk/src/lib/de/polygonal/core/math/random/ParkMiller.hx?r=547</a> 
 * @see <a href="http://en.wikipedia.org/wiki/Lehmer_random_number_generator">http://en.wikipedia.org/wiki/Lehmer_random_number_generator</a>
 * @return Returns the next pseudo-random int value.
 */
exports.nextParkMiller = function (seed) {
    return (seed * MINSTD) % MPM;
};

/**
 * <p>A Park-Miller-Carta PRNG (pseudo random number generator).</p>
 * <p>Integer implementation, using only 32 bit integer maths and no divisions.</p>
 * @see <a href="https://github.com/polygonal/core/blob/dev/src/de/polygonal/core/math/random/ParkMiller31.hx">POLYGONAL - A HAXE LIBRARY FOR GAME DEVELOPERS</a>
 * @see <a href="http://www.firstpr.com.au/dsp/rand31/rand31-park-miller-carta.cc.txt" target="_blank">http://www.firstpr.com.au/dsp/rand31/rand31-park-miller-carta.cc.txt</a>
 * @see <a href="http://en.wikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator" target="_blank">Park-Miller random number generator</a>.
 * @see <a href="http://lab.polygonal.de/?p=162" target="_blank">A good Pseudo-Random Number Generator (PRNG)</a>.
 */
exports.nextParkMiller31 = function (seed) {
    var lo = 16807 * (seed & 0xffff);
    var hi = 16807 * (seed >>> 16);
    lo += (hi & 0x7fff) << 16;
    lo += hi >>> 15;
    if (lo > 0x7fffffff) { lo -= 0x7fffffff; }
    return lo;
};

/**
 * Linear congruential generator using GLIBC constants.
 * 
 * @see <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator">http://en.wikipedia.org/wiki/Linear_congruential_generator</a>
 * @see <a href="https://github.com/aduros/flambe/blob/master/src/flambe/util/Random.hx">https://github.com/aduros/flambe/blob/master/src/flambe/util/Random.hx</a>
 * @return Returns an integer in [0, INT_MAX)
 */
exports.nextLCG = function (seed) {
    // These constants borrowed from glibc
    // Force float multiplication here to avoid overflow in Flash (and keep parity with JS)
    return (1103515245.0 * seed + 12345) % MPM;
};

/**
 * Returns the pseudo-random double value x in the range 0 <= x < 1.
 */
exports.toFloat = function (seed) {
    return seed / MPM;
};

/**
 * Returns a pseudo-random boolean value (coin flip).
 */
exports.toBool = function (seed) {
    return exports.toFloat(seed) > 0.5;
};

/**
 * Returns a pseudo-random double value x in the range min <= x <= max.
 */
exports.toFloatRange = function (seed, min, max) {
    return min + (max - min) * exports.toFloat(seed);
};

/**
 * Returns a pseudo-random integral value x in the range min <= x <= max.
 */
exports.toIntRange = function (seed, min, max) {
    return Math.round((min - 0.4999) + ((max + 0.4999) - (min - 0.4999)) * exports.toFloat(seed));
};

/**
 * Converts a string to a seed.
 * Lets you use words as seeds.
 */
exports.stringToSeed = function (s) {
    return hash.djb2(s) % MPM;
};

/**
 * Closure for tracking random number state.
 * @param   seed
 * @param   algorithm
 */
exports.randomGenerator = function (seed, nextRandomNumberAlgorithm) {
    return function () {
        seed = nextRandomNumberAlgorithm(seed);
        return seed;
    };
};
},{"./hash":11}],17:[function(require,module,exports){
'use strict';

module.exports = function (string) {
    return {
        startsWith: function (pattern) {
            return string.indexOf(pattern) === 0;
        }
    };
};
},{}],18:[function(require,module,exports){
'use strict';

module.exports = function () {

    var start;
    var last;

    return {
        start: function () {
            start = last = Date.now();
        },

        log: function (label) {
            var now = Date.now();
            console.log(label, now - last, now - start);
            last = now;
        }
    };
};


},{}],19:[function(require,module,exports){
/* jshint bitwise: false */

'use strict';

module.exports = {
    TOP: 1,
    BOTTOM: 2,
    LEFT: 4,
    RIGHT: 8,

    /**
     * 
     * @param point
     * @param bounds
     * @return an int with the appropriate bits set if the Point lies on the corresponding bounds lines
     * 
     */
    check: function (point, bounds) {
        bounds = require('../../as3/rectangle').core(bounds);
        var value = 0;
        if (point.x === bounds.left()) {
            value |= this.LEFT;
        }
        if (point.x === bounds.right()) {
            value |= this.RIGHT;
        }
        if (point.y === bounds.top()) {
            value |= this.TOP;
        }
        if (point.y === bounds.bottom()) {
            value |= this.BOTTOM;
        }
        return value;
    }
};
},{"../../as3/rectangle":5}],20:[function(require,module,exports){
'use strict';

module.exports = {
    vertex: 'vertex',
    site: 'site'
};
},{}],21:[function(require,module,exports){
'use strict';

var _ = require('lodash');

module.exports = {

    delaunayLinesForEdges: function (edges) {
        var segments = [];
        _(edges).each(function (edge) {
            segments.push(edge.delaunayLine());
        });
        return segments;
    },

    selectEdgesForSitePoint: function (coord, edgesToTest) {
        return _(edgesToTest).filter(function (edge) {
            return ((edge.leftSite !== null && edge.leftSite.coord === coord) ||
                (edge.rightSite !== null && edge.rightSite.coord === coord));
        });
    },

    selectNonIntersectingEdges: function (keepOutMask, edgesToTest) {
        if (keepOutMask === null) {
            return edgesToTest;
        }
        
        var zeroPoint = {x: 0.0, y: 0.0};
        return _(edgesToTest).filter(function (edge) {
            var delaunayLineBmp = edge.makeDelaunayLineBmp();
            var notIntersecting = !(keepOutMask.hitTest(zeroPoint, 1, delaunayLineBmp, zeroPoint, 1));
            delaunayLineBmp.dispose();
            return notIntersecting;
        });
    },

    visibleLineSegments: function (edges) {
        var lr = require('./lr');
        var lineSegment = require('../geom/line-segment');
        var segments = [];
        
        _(edges).each(function (edge) {
            if (edge.visible) {
                var p1 = edge.clippedEnds[lr.LEFT];
                var p2 = edge.clippedEnds[lr.RIGHT];
                segments.push(lineSegment.make(p1, p2));
            }
        });
        
        return segments;
    }

};
},{"../geom/line-segment":35,"./lr":28,"lodash":1}],22:[function(require,module,exports){
/* jshint bitwise:false */

'use strict';

var halfedgeModule = require('./halfedge');
var edgeModule = require('./edge');

module.exports = function (xmin, deltax, sqrtNsites) {
    var pub = {};

    var _deltax = 0.0;
    var _xmin  = 0.0;
    
    var _hashsize = 0;
    var _hash = []; // Vector<Halfedge>;

    var _leftEnd = null; //Halfedge;
    pub.getLeftEnd = function () {
        return _leftEnd;
    };
    Object.defineProperties(pub, {
        'leftEnd': {get: function () { return pub.getLeftEnd(); }}
    });

    var _rightEnd = null; //Halfedge;
    pub.getRightEnd = function () {
        return _rightEnd;
    };
    Object.defineProperties(pub, {
        'rightEnd': {get: function () { return pub.getRightEnd(); }}
    });

    pub.dispose = function () {
        var halfEdge = _leftEnd;
        var prevHe;
        while (halfEdge !== _rightEnd) {
            prevHe = halfEdge;
            halfEdge = halfEdge.edgeListRightNeighbor;
            prevHe.dispose();
        }
        _leftEnd = null;
        _rightEnd.dispose();
        _rightEnd = null;

        var i;
        for (i = 0; i < _hashsize; i++) {
            _hash[i] = null;
        }
        _hash = null;
    };

    /**
     * Insert newHalfedge to the right of lb 
     * @param lb
     * @param newHalfedge
     * 
     */
    pub.insert = function (lb, newHalfedge) {
        newHalfedge.edgeListLeftNeighbor = lb;
        newHalfedge.edgeListRightNeighbor = lb.edgeListRightNeighbor;
        lb.edgeListRightNeighbor.edgeListLeftNeighbor = newHalfedge;
        lb.edgeListRightNeighbor = newHalfedge;
    };

    /**
     * This function only removes the Halfedge from the left-right list.
     * We cannot dispose it yet because we are still using it. 
     * @param halfEdge
     * 
     */
    pub.remove = function (halfEdge) {
        halfEdge.edgeListLeftNeighbor.edgeListRightNeighbor = halfEdge.edgeListRightNeighbor;
        halfEdge.edgeListRightNeighbor.edgeListLeftNeighbor = halfEdge.edgeListLeftNeighbor;
        halfEdge.edge = edgeModule.DELETED;
        halfEdge.edgeListLeftNeighbor = halfEdge.edgeListRightNeighbor = null;
    };


    /* Get entry from hash table, pruning any deleted nodes */
    function getHash(b) {
        var halfEdge;
    
        if (b < 0 || b >= _hashsize) {
            return null;
        }
        halfEdge = _hash[b];
        if (halfEdge !== null && halfEdge.edge === edgeModule.DELETED) {
            /* Hash table points to deleted halfedge.  Patch as necessary. */
            _hash[b] = null;
            // still can't dispose halfEdge yet!
            return null;
        } else {
            return halfEdge;
        }
    }

    /**
     * Find the rightmost Halfedge that is still left of p 
     * @param p
     * @return 
     * 
     */
    pub.edgeListLeftNeighbor = function (p) {
        var bucket;
        var halfEdge;
    
        /* Use hash table to get close to desired halfedge */
        bucket = ((p.x - _xmin) / _deltax) * _hashsize;
        if (bucket < 0) {
            bucket = 0;
        }
        if (bucket >= _hashsize) {
            bucket = _hashsize - 1;
        }
        halfEdge = getHash(bucket);
        if (halfEdge === null) {
            var i = 1;
            while (true) {
                if ((halfEdge = this.getHash(bucket - i)) !== null) {
                    break;
                }
                if ((halfEdge = this.getHash(bucket + i)) !== null) {
                    break;
                }
                
                i++;
            }
        }
        /* Now search linear list of halfedges for the correct one */
        if (halfEdge === this.getLeftEnd()  || (halfEdge !== this.getRightEnd() && halfEdge.isLeftOf(p))) {
            do {
                halfEdge = halfEdge.edgeListRightNeighbor;
            } while (halfEdge !== this.getRightEnd() && halfEdge.isLeftOf(p));
            halfEdge = halfEdge.edgeListLeftNeighbor;
        } else {
            do {
                halfEdge = halfEdge.edgeListLeftNeighbor;
            } while (halfEdge !== this.getLeftEnd() && !halfEdge.isLeftOf(p));
        }
    
        /* Update hash table and reference counts */
        if (bucket > 0 && bucket < _hashsize - 1) {
            _hash[bucket] = halfEdge;
        }
        return halfEdge;
    };

    _xmin = xmin;
    _deltax = deltax;
    _hashsize = 2 * sqrtNsites;

    //var i:Int;
    _hash = [];
    
    // two dummy Halfedges:
    _leftEnd = halfedgeModule.createDummy();
    _rightEnd = halfedgeModule.createDummy();
    _leftEnd.edgeListLeftNeighbor = null;
    _leftEnd.edgeListRightNeighbor = _rightEnd;
    _rightEnd.edgeListLeftNeighbor = _leftEnd;
    _rightEnd.edgeListRightNeighbor = null;
    _hash[0] = _leftEnd;
    _hash[_hashsize - 1] = _rightEnd;

    return pub;
};
},{"./edge":24,"./halfedge":26}],23:[function(require,module,exports){
'use strict';

var criterionModule = require('./criterion');
var lr = require('./lr');
var vertex = require('./vertex');

var EdgeReorderer = function (origEdges, criterion) {
    if (criterion !== criterionModule.vertex && criterion !== criterionModule.site) {
        throw 'Edges: criterion must be Vertex or Site';
    }
    this.edges = [];
    this.edgeOrientations = [];
    if (origEdges.length > 0) {
        this.edges = this._reorderEdges(origEdges, criterion);
    }
};

EdgeReorderer.prototype = {

    edges: null, // Vector<Edge>
    edgeOrientations: null, // Vector<LR>

    dispose: function () {
        this.edges = null;
        this.edgeOrientations = null;
    },

    _reorderEdges: function (origEdges, criterion) {
        var i;
        var n = origEdges.length;
        var edge;
        // we're going to reorder the edges in order of traversal
        var done = []; // Vector<Boolean>
        var nDone = 0;
        
        var newEdges = []; // Vector<Edge>
        
        i = 0;
        edge = origEdges[i];
        newEdges.push(edge);
        this.edgeOrientations.push(lr.LEFT);
        var firstPoint;
        var lastPoint;
        if (criterion === criterionModule.vertex) {
            firstPoint = edge.leftVertex;
            lastPoint = edge.rightVertex;
        } else {
            firstPoint = edge.leftSite;
            lastPoint = edge.rightSite;
        }
        
        if (firstPoint === vertex.VERTEX_AT_INFINITY || lastPoint === vertex.VERTEX_AT_INFINITY) {
            return []; // Vector<Edge>;
        }
        
        done[i] = true;
        ++nDone;
        
        while (nDone < n) {
            for (i = 1; i < n; i++) {
                if (done[i]) {
                    continue;
                }
                edge = origEdges[i];
                var leftPoint;
                var rightPoint;
                if (criterion === criterionModule.vertex) {
                    leftPoint = edge.leftVertex;
                    rightPoint = edge.rightVertex;
                } else {
                    leftPoint = edge.leftSite;
                    rightPoint = edge.rightSite;
                }
                
                if (leftPoint === vertex.VERTEX_AT_INFINITY || rightPoint === vertex.VERTEX_AT_INFINITY) {
                    return []; //Vector<Edge>()
                }
                if (leftPoint === lastPoint) {
                    lastPoint = rightPoint;
                    this.edgeOrientations.push(lr.LEFT);
                    newEdges.push(edge);
                    done[i] = true;
                }
                else if (rightPoint === firstPoint) {
                    firstPoint = leftPoint;
                    this.edgeOrientations.unshift(lr.LEFT);
                    newEdges.unshift(edge);
                    done[i] = true;
                }
                else if (leftPoint === firstPoint) {
                    firstPoint = rightPoint;
                    this.edgeOrientations.unshift(lr.RIGHT);
                    newEdges.unshift(edge);
                    done[i] = true;
                }
                else if (rightPoint === lastPoint) {
                    lastPoint = leftPoint;
                    this.edgeOrientations.push(lr.RIGHT);
                    newEdges.push(edge);
                    done[i] = true;
                }
                if (done[i]) {
                    ++nDone;
                }
            }
        }
        
        return newEdges;
    }

};

module.exports = function (origEdges, criterion) {
    return new EdgeReorderer(origEdges, criterion);
};
},{"./criterion":20,"./lr":28,"./vertex":32}],24:[function(require,module,exports){
/* jshint es3:false */

'use strict';

var lineSegment = require('../geom/line-segment');
var lr = require('./lr');
var pointCore = require('../../as3/point-core');
var rectangle = require('../../as3/rectangle');

var _pool = [];
var _nedges = 0;

exports.Edge = function () {
    this._edgeIndex = _nedges++;
    this.init();
};

exports.Edge.prototype = {
    _delaunayLineBmp: null,
    getDelaunayLineBmp: function () {
        if (this._delaunayLineBmp === null) {
            this._delaunayLineBmp = this.makeDelaunayLineBmp();
        }
        return this._delaunayLineBmp;
    },
    get delaunayLineBmp() { return this.getDelaunayLineBmp(); },

    // making this available to Voronoi; running out of memory in AIR so I cannot cache the bmp
    makeDelaunayLineBmp: function () {
        throw 'unimplemented';
        
        var p0 = this.leftSite.coord;
        var p1 = this.rightSite.coord;
        
        var w = Math.ceil(Math.max(p0.x, p1.x));
        if (w < 1) {
            w = 1;
        }
        var h = Math.ceil(Math.max(p0.y, p1.y));
        if (h < 1) {
            h = 1;
        }
        //var bmp:BitmapData = new BitmapData(w, h, true, 0);
        var bmp = new BitmapData();

        //GRAPHICS.clear();
        // clear() resets line style back to undefined!
        //GRAPHICS.lineStyle(0, 0, 1.0, false, LineScaleMode.NONE, CapsStyle.NONE);
        //GRAPHICS.moveTo(p0.x, p0.y);
        //GRAPHICS.lineTo(p1.x, p1.y);
        
        bmp.drawLine(p0, p1);
        
        //bmp.draw(LINESPRITE);
        return bmp;
    },

    delaunayLine: function () {
        // draw a line connecting the input Sites for which the edge is a bisector:
        return lineSegment.make(this.leftSite.coord, this.rightSite.coord);
    },

    voronoiEdge: function () {
        if (!this.visible) {
            return lineSegment.make(null, null);
        }
        return lineSegment.make(this.clippedEnds[lr.LEFT], this.clippedEnds[lr.RIGHT]);
    },

    // the equation of the edge: ax + by = c
    a: null,
    b: null,
    c: null,

    // the two Voronoi vertices that the edge connects
    //      (if one of them is null, the edge extends to infinity)
    leftVertex: null,
    rightVertex: null,

    vertex: function (leftRight) {
        return (leftRight === lr.LEFT) ? this.leftVertex : this.rightVertex;
    },

    setVertex: function (leftRight, v) {
        if (leftRight === lr.LEFT) {
            this.leftVertex = v;
        } else {
            this.rightVertex = v;
        }
    },

    isPartOfConvexHull: function () {
        return (this.leftVertex === null || this.rightVertex === null);
    },

    sitesDistance: function () {
        return pointCore.distance(this.leftSite.coord, this.rightSite.coord);
    },

    // Once clipVertices() is called, this Dictionary will hold two Points
    // representing the clipped coordinates of the left and right ends...
    //private var _clippedVertices:Dictionary;
    clippedEnds: null, // Dictionary<Point>

    // unless the entire Edge is outside the bounds.
    // In that case visible will be false:
    get visible() { return this.clippedEnds !== null; },

    // the two input Sites for which this Edge is a bisector:
    //private var _sites:Dictionary<Site>;
    // the two input Sites for which this Edge is a bisector:               
    leftSite: null,
    rightSite: null,

    site: function (leftRight) {
        return (leftRight === lr.LEFT) ? this.leftSite : this.rightSite;
    },

    _edgeIndex: 0,

    dispose: function () {
        if (this._delaunayLineBmp !== null) {
            this._delaunayLineBmp.dispose();
            this._delaunayLineBmp = null;
        }
        this.leftVertex = null;
        this.rightVertex = null;
        if (this.clippedEnds !== null) {
            this.clippedEnds[lr.LEFT] = null;
            this.clippedEnds[lr.RIGHT] = null;
            this.clippedEnds = null;
        }

        this.leftSite = null;
        this.rightSite = null;
        
        _pool.push(this);
    },

    toString: function () {
        return 'Edge ' + this._edgeIndex + '; sites ' + this.leftSite + ', ' + this.rightSite +
            '; endVertices ' + (this.leftVertex !== null ? String(this.leftVertex.vertexIndex) : 'null') + ', ' +
            (this.rightVertex !== null ? String(this.rightVertex.vertexIndex) : 'null') + '::';
    },

    /**
     * Set _clippedVertices to contain the two ends of the portion of the Voronoi edge that is visible
     * within the bounds.  If no part of the Edge falls within the bounds, leave _clippedVertices null. 
     * @param bounds
     * 
     */
    clipVertices: function (bounds) {
        var boundsCore = rectangle.core(bounds);
        var xmin = bounds.x;
        var ymin = bounds.y;
        var xmax = boundsCore.right();
        var ymax = boundsCore.bottom();
        
        var vertex0, vertex1;
        var x0, x1, y0, y1;
        
        if (this.a === 1.0 && this.b >= 0.0) {
            vertex0 = this.rightVertex;
            vertex1 = this.leftVertex;
        } else {
            vertex0 = this.leftVertex;
            vertex1 = this.rightVertex;
        }
    
        if (this.a === 1.0) {
            y0 = ymin;
            if (vertex0 !== null && vertex0.y > ymin) {
                y0 = vertex0.y;
            }
            if (y0 > ymax) {
                return;
            }
            x0 = this.c - this.b * y0;
            
            y1 = ymax;
            if (vertex1 !== null && vertex1.y < ymax) {
                y1 = vertex1.y;
            }
            if (y1 < ymin) {
                return;
            }
            x1 = this.c - this.b * y1;
            
            if ((x0 > xmax && x1 > xmax) || (x0 < xmin && x1 < xmin)) {
                return;
            }
            
            if (x0 > xmax) {
                x0 = xmax;
                y0 = (this.c - x0) / this.b;
            }
            else if (x0 < xmin) {
                x0 = xmin;
                y0 = (this.c - x0) / this.b;
            }
            
            if (x1 > xmax) {
                x1 = xmax;
                y1 = (this.c - x1) / this.b;
            }
            else if (x1 < xmin) {
                x1 = xmin;
                y1 = (this.c - x1) / this.b;
            }
        } else {
            x0 = xmin;
            if (vertex0 !== null && vertex0.x > xmin) {
                x0 = vertex0.x;
            }
            if (x0 > xmax) {
                return;
            }
            y0 = this.c - this.a * x0;
            
            x1 = xmax;
            if (vertex1 !== null && vertex1.x < xmax) {
                x1 = vertex1.x;
            }
            if (x1 < xmin) {
                return;
            }
            y1 = this.c - this.a * x1;
            
            if ((y0 > ymax && y1 > ymax) || (y0 < ymin && y1 < ymin)) {
                return;
            }
            
            if (y0 > ymax) {
                y0 = ymax;
                x0 = (this.c - y0) / this.a;
            }
            else if (y0 < ymin) {
                y0 = ymin;
                x0 = (this.c - y0) / this.a;
            }
            
            if (y1 > ymax) {
                y1 = ymax;
                x1 = (this.c - y1) / this.a;
            }
            else if (y1 < ymin) {
                y1 = ymin;
                x1 = (this.c - y1) / this.a;
            }
        }

        this.clippedEnds = {};
        if (vertex0 === this.leftVertex) {
            this.clippedEnds[lr.LEFT] = {x: x0, y: y0};
            this.clippedEnds[lr.RIGHT] = {x: x1, y: y1};
        } else {
            this.clippedEnds[lr.RIGHT] = {x: x0, y: y0};
            this.clippedEnds[lr.LEFT] = {x: x1, y: y1};
        }
    },

    init: function () {
        this.leftSite = null;
        this.rightSite = null;
    }

};

function create() {
    var edge;
    if (_pool.length > 0) {
        edge = _pool.pop();
        edge.init();
    } else {
        edge = new exports.Edge();
    }
    return edge;
}

exports.DELETED = new exports.Edge();

/**
 * This is the only way to create a new Edge 
 * @param site0
 * @param site1
 * @return 
 * 
 */
exports.createBisectingEdge = function (site0, site1) {
    var dx, dy, absdx, absdy;
    var a, b, c;

    dx = site1.x - site0.x;
    dy = site1.y - site0.y;
    absdx = dx > 0 ? dx : -dx;
    absdy = dy > 0 ? dy : -dy;
    c = site0.x * dx + site0.y * dy + (dx * dx + dy * dy) * 0.5;
    if (absdx > absdy) {
        a = 1.0;
        b = dy / dx;
        c /= dx;
    } else {
        b = 1.0;
        a = dx / dy;
        c /= dy;
    }
    
    var edge = create();

    edge.leftSite = site0;
    edge.rightSite = site1;
    site0.addEdge(edge);
    site1.addEdge(edge);
    
    edge.leftVertex = null;
    edge.rightVertex = null;
    
    edge.a = a;
    edge.b = b;
    edge.c = c;
    //trace("createBisectingEdge: a ", edge.a, "b", edge.b, "c", edge.c);
    
    return edge;
};

exports.compareSitesDistancesMax = function (edge0, edge1) {
    var length0 = edge0.sitesDistance();
    var length1 = edge1.sitesDistance();
    if (length0 < length1) {
        return 1;
    }
    if (length0 > length1) {
        return -1;
    }
    return 0;
};

exports.compareSitesDistances = function (edge0, edge1) {
    return - exports.compareSitesDistancesMax(edge0, edge1);
};
},{"../../as3/point-core":4,"../../as3/rectangle":5,"../geom/line-segment":35,"./lr":28}],25:[function(require,module,exports){
/* jshint bitwise:false */

'use strict';

var halfedgeModule = require('./halfedge');
var core = require('../../janicek/core');

module.exports = function (ymin, deltay, sqrtNsites) {
    var pub = {};

    var _hash = null; //Vector<Halfedge>
    var _count = 0;
    var _minBucket = 0;
    var _hashsize = 0;
    
    var _ymin = 0.0;
    var _deltay = 0.0;

    function initialize() {
        var i;

        _count = 0;
        _minBucket = 0;
        _hash = [];
        // dummy Halfedge at the top of each hash
        for (i = 0; i < _hashsize; i++) {
            _hash[i] = halfedgeModule.createDummy();
            _hash[i].nextInPriorityQueue = null;
        }
    }

    function bucket(halfEdge) {
        var theBucket = core.toInt((halfEdge.ystar - _ymin) / _deltay * _hashsize);
        if (theBucket < 0) {
            theBucket = 0;
        }
        if (theBucket >= _hashsize) {
            theBucket = _hashsize - 1;
        }
        return theBucket;
    }

    pub.dispose = function () {
        // get rid of dummies
        var i;
        for (i = 0; i < _hashsize; i++) {
            _hash[i].dispose();
            _hash[i] = null;
        }
        _hash = null;
    };

    pub.insert = function (halfEdge) {
        var previous, next;
        var insertionBucket = bucket(halfEdge);

        if (insertionBucket < _minBucket) {
            _minBucket = insertionBucket;
        }
        previous = _hash[insertionBucket];
        while ((next = previous.nextInPriorityQueue) !== null &&
            (halfEdge.ystar  > next.ystar || (halfEdge.ystar === next.ystar && halfEdge.vertex.x > next.vertex.x))) {
            previous = next;
        }
        halfEdge.nextInPriorityQueue = previous.nextInPriorityQueue;
        previous.nextInPriorityQueue = halfEdge;
        ++_count;
    };

    pub.remove = function (halfEdge) {
        var previous;
        var removalBucket = bucket(halfEdge);
        
        if (halfEdge.vertex !== null) {
            previous = _hash[removalBucket];
            while (previous.nextInPriorityQueue !== halfEdge) {
                previous = previous.nextInPriorityQueue;
            }
            previous.nextInPriorityQueue = halfEdge.nextInPriorityQueue;
            _count--;
            halfEdge.vertex = null;
            halfEdge.nextInPriorityQueue = null;
            halfEdge.dispose();
        }
    };

    function isEmpty(bucket) {
        return (_hash[bucket].nextInPriorityQueue === null);
    }

     /**
     * move _minBucket until it contains an actual Halfedge (not just the dummy at the top); 
     * 
     */
    function adjustMinBucket() {
        while (_minBucket < _hashsize - 1 && isEmpty(_minBucket)) {
            ++_minBucket;
        }
    }

    pub.empty = function () {
        return _count === 0;
    };

    /**
     * @return coordinates of the Halfedge's vertex in V*, the transformed Voronoi diagram
     * 
     */
    pub.min = function () {
        adjustMinBucket();
        var answer = _hash[_minBucket].nextInPriorityQueue;
        return {x: answer.vertex.x, y: answer.ystar};
    };

    /**
     * remove and return the min Halfedge
     * @return 
     * 
     */
    pub.extractMin = function () {
        var answer;
    
        // get the first real Halfedge in _minBucket
        answer = _hash[_minBucket].nextInPriorityQueue;
        
        _hash[_minBucket].nextInPriorityQueue = answer.nextInPriorityQueue;
        _count--;
        answer.nextInPriorityQueue = null;
        
        return answer;
    };


    _ymin = ymin;
    _deltay = deltay;
    _hashsize = 4 * sqrtNsites;
    initialize();

    return pub;
};
},{"../../janicek/core":10,"./halfedge":26}],26:[function(require,module,exports){
'use strict';

var def = require('../../janicek/core').def;
var lrModule = require('./lr');

var _pool = []; // Vector<Halfedge>

var Halfedge = function (edge, lr) {
    edge = def(edge, null);
    lr = def(lr, null);
    this.init(edge, lr);
};

Halfedge.prototype = {
    edgeListLeftNeighbor: null,
    edgeListRightNeighbor: null,
    nextInPriorityQueue: null,
    
    edge: null,
    leftRight: null,
    vertex: null,

    // the vertex's y-coordinate in the transformed Voronoi space V*
    ystar: 0.0,

    toString: function () {
        return 'Halfedge (leftRight: ' + this.leftRight + '; vertex: ' + this.vertex + ')';
    },

    dispose: function () {
        if (this.edgeListLeftNeighbor !== null || this.edgeListRightNeighbor !== null) {
            // still in EdgeList
            return;
        }
        if (this.nextInPriorityQueue !== null) {
            // still in PriorityQueue
            return;
        }
        this.edge = null;
        this.leftRight = null;
        this.vertex = null;
        _pool.push(this);
    },

    reallyDispose: function () {
        this.edgeListLeftNeighbor = null;
        this.edgeListRightNeighbor = null;
        this.nextInPriorityQueue = null;
        this.edge = null;
        this.leftRight = null;
        this.vertex = null;
        _pool.push(this);
    },

    isLeftOf: function (p) {
        var topSite;
        var rightOfSite, above, fast;
        var dxp, dyp, dxs, t1, t2, t3, yl;
        
        topSite = this.edge.rightSite;
        rightOfSite = p.x > topSite.x;
        if (rightOfSite && this.leftRight === lrModule.LEFT) {
            return true;
        }
        if (!rightOfSite && this.leftRight === lrModule.RIGHT) {
            return false;
        }
        
        if (this.edge.a === 1.0) {
            dyp = p.y - topSite.y;
            dxp = p.x - topSite.x;
            fast = false;
            if ((!rightOfSite && this.edge.b < 0.0) || (rightOfSite && this.edge.b >= 0.0)) {
                above = dyp >= (this.edge.b * dxp);
                fast = above;
            } else {
                above = p.x + p.y * this.edge.b > this.edge.c;
                if (this.edge.b < 0.0) {
                    above = !above;
                }
                if (!above) {
                    fast = true;
                }
            }
            if (!fast) {
                dxs = topSite.x - this.edge.leftSite.x;
                above = this.edge.b * (dxp * dxp - dyp * dyp) < (dxs * dyp * (1.0 + 2.0 * dxp / dxs + this.edge.b * this.edge.b));
                if (this.edge.b < 0.0) {
                    above = !above;
                }
            }
        }
        else  { /* this.edge.b == 1.0 */
            yl = this.edge.c - this.edge.a * p.x;
            t1 = p.y - yl;
            t2 = p.x - topSite.x;
            t3 = yl - topSite.y;
            above = (t1 * t1) > (t2 * t2 + t3 * t3);
        }
        return this.leftRight === lrModule.LEFT ? above : !above;
    },

    init: function (edge, lr) {
        this.edge = edge;
        this.leftRight = lr;
        this.nextInPriorityQueue = null;
        this.vertex = null;
        return this;
    }

};

exports.create = function (edge, lr) {
    if (_pool.length > 0) {
        return _pool.pop().init(edge, lr);
    }
    else {
        return new Halfedge(edge, lr);
    }
};

exports.createDummy = function () {
    return exports.create(null, null);
};
},{"../../janicek/core":10,"./lr":28}],27:[function(require,module,exports){
/* jshint camelcase:false */

'use strict';

var _ = require('lodash');
var def = require('../../janicek/core').def;
var lineSegmentCore = require('../geom/line-segment').core;
var nodeModule = require('./node');
var pointCore = require('../../as3/point-core');

exports.find = function (node) {
    if (node.parent === node) {
        return node;
    } else {
        var root = exports.find(node.parent);
        // this line is just to speed up subsequent finds by keeping the tree depth low:
        node.parent = root;
        return root;
    }
};

/**
*  Kruskal's spanning tree algorithm with union-find
 * Skiena: The Algorithm Design Manual, p. 196ff
 * Note: the sites are implied: they consist of the end points of the line segments
*/
exports.kruskal = function (lineSegments, type) {
    type = def(type, 'minimum');

    var nodes = {}; // Dictionary<Node>
    var mst = []; // Vector<LineSegment>
    var nodePool = []; // Vector<Node>
    
    switch (type) {
        // note that the compare functions are the reverse of what you'd expect
        // because (see below) we traverse the lineSegments in reverse order for speed
    case 'maximum':
        lineSegments.sort(lineSegmentCore.compareLengths);
        break;
    default:
        lineSegments.sort(lineSegmentCore.compareLengthsMax);
    }

    var i = lineSegments.length - 1;
    //for (var i:int = lineSegments.length; --i > -1;)
    while (i >= 0) {
        var lineSegment = lineSegments[i];
        i--;
        
        var node0 = nodes[pointCore.hash(lineSegment.p0)];
        var rootOfSet0;
        if (node0 === null) {
            node0 = nodePool.length > 0 ? nodePool.pop() : nodeModule.make();
            // intialize the node:
            rootOfSet0 = node0.parent = node0;
            node0.treeSize = 1;
        
            nodes[pointCore.hash(lineSegment.p0)] = node0;
        } else {
            rootOfSet0 = exports.find(node0);
        }
        
        var node1 = nodes[pointCore.hash(lineSegment.p1)];
        var rootOfSet1;
        if (node1 === null) {
            node1 = nodePool.length > 0 ? nodePool.pop() : nodeModule.make();
            // intialize the node:
            rootOfSet1 = node1.parent = node1;
            node1.treeSize = 1;
        
            nodes[pointCore.hash(lineSegment.p1)] = node1;
        } else {
            rootOfSet1 = exports.find(node1);
        }
        
        if (rootOfSet0 !== rootOfSet1) {   // nodes not in same set
            mst.push(lineSegment);
            
            // merge the two sets:
            var treeSize0 = rootOfSet0.treeSize;
            var treeSize1 = rootOfSet1.treeSize;
            if (treeSize0 >= treeSize1) {
                // set0 absorbs set1:
                rootOfSet1.parent = rootOfSet0;
                rootOfSet0.treeSize += treeSize1;
            } else {
                // set1 absorbs set0:
                rootOfSet0.parent = rootOfSet1;
                rootOfSet1.treeSize += treeSize0;
            }
        }
    }
    
    _(nodes).each(function (node) {
        nodePool.push(node);
    });
    
    return mst;
};
},{"../../as3/point-core":4,"../../janicek/core":10,"../geom/line-segment":35,"./node":29,"lodash":1}],28:[function(require,module,exports){
'use strict';

module.exports = {
    LEFT: 'left',
    RIGHT: 'right',

    other: function (leftRight) {
        return leftRight === this.LEFT ? this.RIGHT : this.LEFT;
    }
};
},{}],29:[function(require,module,exports){
'use strict';

exports.make = function () {
    return {
        parent: null,
        treeSize: 0
    };
};

exports.pool = [];
},{}],30:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var circle = require('../geom/circle');
var def = require('../../janicek/core').def;
var rectangle = require('../../as3/rectangle');
var siteModule = require('./site');

module.exports = function () {
    var _sites = []; // Vector<Site>
    var _currentIndex = 0;
    var _sorted = false;

    var pub = {};

    pub.dispose = function () {
        if (_sites !== null) {
            _(_sites).each(function (site) {
                site.dispose();
            });
            _sites = null;
        }
    };

    pub.push = function (site) {
        _sorted = false;
        return _sites.push(site);
    };

    Object.defineProperties(pub, {
        'length': {get: function () { return _sites.length; }}
    });

    pub.next = function () {
        if (_sorted === false) {
            throw 'SiteList::next():  sites have not been sorted';
        }
        if (_currentIndex < _sites.length) {
            return _sites[_currentIndex++];
        } else {
            return null;
        }
    };

    pub.getSitesBounds = function () {
        if (_sorted === false) {
            siteModule.sortSites(_sites);
            _currentIndex = 0;
            _sorted = true;
        }
        var xmin, xmax, ymin, ymax;
        if (_sites.length === 0) {
            return rectangle(0, 0, 0, 0);
        }
        
        xmin = Number.POSITIVE_INFINITY;
        xmax = Number.POSITIVE_INFINITY;
        _(_sites).each(function (site) {
            if (site.x < xmin) {
                xmin = site.x;
            }
            if (site.x > xmax) {
                xmax = site.x;
            }
        });
        // here's where we assume that the sites have been sorted on y:
        ymin = _sites[0].y;
        ymax = _sites[_sites.length - 1].y;
        
        return rectangle(xmin, ymin, xmax - xmin, ymax - ymin);
    };

    pub.siteColors = function (referenceImage) {
        referenceImage = def(referenceImage, null);

        var colors = []; // Vector<Int>
        _(_sites).each(function (site) {
            colors.push(referenceImage !== null ? referenceImage.getPixel(site.x, site.y) : site.color);
        });
        return colors;
    };

    pub.siteCoords = function () {
        var coords = []; // Vector<Point>
        _(_sites).each(function (site) {
            coords.push(site.coord);
        });
        return coords;
    };

    /**
     * 
     * @return the largest circle centered at each site that fits in its region;
     * if the region is infinite, return a circle of radius 0.
     * 
     */
    pub.circles = function () {
        var circles = []; // Vector<Circle>
        _(_sites).each(function (site) {
            //var radius:Number = 0;
            var nearestEdge = site.nearestEdge();
            
            var radius = (!nearestEdge.isPartOfConvexHull()) ? (nearestEdge.sitesDistance() * 0.5): 0;
            //!nearestEdge.isPartOfConvexHull() && (radius = nearestEdge.sitesDistance() * 0.5);
            circles.push(circle(site.x, site.y, radius));
        });
        return circles;
    };

    pub.regions = function (plotBounds) {
        var regions = []; // Vector<Vector<Point>>
        _(_sites).each(function (site) {
            regions.push(site.region(plotBounds));
        });
        return regions;
    };

    /**
     * 
     * @param proximityMap a BitmapData whose regions are filled with the site index values; see PlanePointsCanvas::fillRegions()
     * @param x
     * @param y
     * @return coordinates of nearest Site to (x, y)
     * 
     */
    pub.nearestSitePoint = function (proximityMap, x, y) {
        var index = proximityMap.getPixel(x, y);
        if (index > _sites.length - 1) {
            return null;
        }
        return _sites[index].coord;
    };

    return pub;
};
},{"../../as3/rectangle":5,"../../janicek/core":10,"../geom/circle":34,"./site":31,"lodash":1}],31:[function(require,module,exports){
/* jshint bitwise:false, es3:false */

'use strict';

var _ = require('lodash');
var boundsCheck = require('./bounds-check');
var criterion = require('./criterion');
var def = require('../../janicek/core').def;
var edgeModule = require('./edge');
var edgeReordererModule = require('./edge-reorderer');
var lr = require('./lr');
var pointCore = require('../../as3/point-core');
var polygon = require('../geom/polygon');
var rect = require('../../as3/rectangle').core;
var voronoiModule = require('./voronoi');
var winding = require('../geom/winding');

var _pool = []; // Vector<Site>


var EPSILON = 0.005;
function closeEnough(p0, p1) {
    return pointCore.distance(p0, p1) < EPSILON;
}

var Site = function (p, index, weight, color) {
    this.init(p, index, weight, color);
};

Site.prototype = {
    _coord: null,
    get coord() { return this._coord; },
    color: 0,
    weight: 0.0,
    _siteIndex: 0,

    // the edges that define this Site's Voronoi region:
    _edges: null, // Vector<Edge>
    get edges() { return this._edges; },

    // which end of each edge hooks up with the previous edge in _edges:
    _edgeOrientations: null, // Vector<LR>;
    // ordered list of points that define the region clipped to bounds:
    _region: null, // Vector<Point>

    init: function (p, index, weight, color) {
        this._coord = p;
        this._siteIndex = index;
        this.weight = weight;
        this.color = color;
        this._edges = [];
        this._region = null;
        return this;
    },

    toString: function () {
        return 'Site ' + this._siteIndex + ': ' + String(this.coord);
    },

    dispose: function () {
        this._coord = null;
        this._clear();
        _pool.push(this);
    },

    _clear: function () {
        if (this._edges !== null) {
            this._edges = null;
        }
        if (this._edgeOrientations !== null) {
            this._edgeOrientations = null;
        }
        if (this._region !== null) {
            this._region = null;
        }
    },

    addEdge: function (edge) {
        this._edges.push(edge);
    },

    nearestEdge: function () {
        this._edges.sort(edgeModule.compareSitesDistances);
        return this._edges[0];
    },

    neighborSites: function () {
        if (this._edges === null || this._edges.length === 0) {
            return [];
        }
        if (this._edgeOrientations === null) {
            this._reorderEdges();
        }
        var list = []; // Vector<Site>

        _.each(this._edges, function (edge) {
            list.push(this._neighborSite(edge));
        });

        return list;
    },

    _neighborSite: function (edge) {
        if (this === edge.leftSite) {
            return edge.rightSite;
        }
        if (this === edge.rightSite) {
            return edge.leftSite;
        }
        return null;
    },

    region: function (clippingBounds) {
        if (this._edges === null || this._edges.length === 0) {
            return [];
        }
        if (this._edgeOrientations === null) {
            this._reorderEdges();
            this._region = this._clipToBounds(clippingBounds);
            if ((polygon(this._region)).winding() === winding.CLOCKWISE) {
                this._region.reverse();
            }
        }
        return this._region;
    },

    _reorderEdges: function () {
        var reorderer = edgeReordererModule(this._edges, criterion.vertex);
        this._edges = reorderer.edges;
        this._edgeOrientations = reorderer.edgeOrientations;
        reorderer.dispose();
    },

    _clipToBounds: function (bounds) {
        var points = []; // Vector<Point>
        var n = this._edges.length;
        var i = 0;
        var edge = null;
        while (i < n && (this._edges[i].visible === false)) {
            ++i;
        }
        
        if (i === n) {
            // no edges visible
            return [];
        }
        edge = this._edges[i];
        var orientation = this._edgeOrientations[i];
        points.push(edge.clippedEnds[orientation]);
        points.push(edge.clippedEnds[lr.other(orientation)]);

        for (var j = (i + 1); j < n; j++) {
            edge = this._edges[j];
            if (edge.visible === false) {
                continue;
            }
            this._connect(points, j, bounds);
        }
        // close up the polygon by adding another corner point of the bounds if needed:
        this._connect(points, i, bounds, true);
        
        return points;
    },

    _connect: function (points, j, bounds, closingUp) {
        closingUp = def(closingUp, false);

        var rightPoint = points[points.length - 1];
        var newEdge = this._edges[j];
        var newOrientation = this._edgeOrientations[j];
        // the point that  must be connected to rightPoint:
        var newPoint = newEdge.clippedEnds[newOrientation];
        if (!closeEnough(rightPoint, newPoint)) {
            // The points do not coincide, so they must have been clipped at the bounds;
            // see if they are on the same border of the bounds:
            if (rightPoint.x !== newPoint.x && rightPoint.y !== newPoint.y) {
                // They are on different borders of the bounds;
                // insert one or two corners of bounds as needed to hook them up:
                // (NOTE this will not be correct if the region should take up more than
                // half of the bounds rect, for then we will have gone the wrong way
                // around the bounds and included the smaller part rather than the larger)
                var rightCheck = boundsCheck.check(rightPoint, bounds);
                var newCheck = boundsCheck.check(newPoint, bounds);
                var px, py;
                if ((rightCheck & boundsCheck.RIGHT) !== 0) {
                    px = rect(bounds).right();
                    if ((newCheck & boundsCheck.BOTTOM) !== 0) {
                        py = rect(bounds).bottom();
                        points.push({x: px, y: py});
                    }
                    else if ((newCheck & boundsCheck.TOP) !== 0) {
                        py = rect(bounds).top();
                        points.push({x: px, y: py});
                    }
                    else if ((newCheck & boundsCheck.LEFT) !== 0) {
                        if (rightPoint.y - bounds.y + newPoint.y - bounds.y < bounds.height) {
                            py = rect(bounds).top();
                        } else {
                            py = rect(bounds).bottom();
                        }
                        points.push({x: px, y: py});
                        points.push({x: rect(bounds).left(), y: py});
                    }
                } else if ((rightCheck & boundsCheck.LEFT) !== 0) {
                    px = rect(bounds).left();
                    if ((newCheck & boundsCheck.BOTTOM) !== 0) {
                        py = rect(bounds).bottom();
                        points.push({x: px, y: py});
                    } else if ((newCheck & boundsCheck.TOP) !== 0) {
                        py = rect(bounds).top();
                        points.push({x: px, y: py});
                    } else if ((newCheck & boundsCheck.RIGHT) !== 0) {
                        if (rightPoint.y - bounds.y + newPoint.y - bounds.y < bounds.height) {
                            py = rect(bounds).top();
                        } else {
                            py = rect(bounds).bottom();
                        }
                        points.push({x: px, y: py});
                        points.push({x: rect(bounds).right(), y: py});
                    }
                } else if ((rightCheck & boundsCheck.TOP) !== 0) {
                    py = rect(bounds).top();
                    if ((newCheck & boundsCheck.RIGHT) !== 0) {
                        px = rect(bounds).right();
                        points.push({x: px, y: py});
                    } else if ((newCheck & boundsCheck.LEFT) !== 0) {
                        px = rect(bounds).left();
                        points.push({x: px, y: py});
                    } else if ((newCheck & boundsCheck.BOTTOM) !== 0) {
                        if (rightPoint.x - bounds.x + newPoint.x - bounds.x < bounds.width) {
                            px = rect(bounds).left();
                        } else {
                            px = rect(bounds).right();
                        }
                        points.push({x: px, y: py});
                        points.push({x: px, y: rect(bounds).bottom()});
                    }
                } else if ((rightCheck & boundsCheck.BOTTOM) !== 0) {
                    py = rect(bounds).bottom();
                    if ((newCheck & boundsCheck.RIGHT) !== 0) {
                        px = rect(bounds).right();
                        points.push({x: px, y: py});
                    } else if ((newCheck & boundsCheck.LEFT) !== 0) {
                        px = rect(bounds).left();
                        points.push({x: px, y: py});
                    } else if ((newCheck & boundsCheck.TOP) !== 0) {
                        if (rightPoint.x - bounds.x + newPoint.x - bounds.x < bounds.width) {
                            px = rect(bounds).left();
                        } else {
                            px = rect(bounds).right();
                        }
                        points.push({x: px, y: py});
                        points.push({x: px, y: rect(bounds).top()});
                    }
                }
            }
            if (closingUp) {
                // newEdge's ends have already been added
                return;
            }
            points.push(newPoint);
        }
        var newRightPoint = newEdge.clippedEnds[lr.other(newOrientation)];
        if (!closeEnough(points[0], newRightPoint)) {
            points.push(newRightPoint);
        }
    },

    get x() { return this._coord.x; },

    get y() { return this._coord.y; },

    dist: function (p) {
        return pointCore.distance(p.coord, this.coord);
    }
};

exports.create = function (p, index, weight, color) {
    if (_pool.length > 0) {
        return _pool.pop().init(p, index, weight, color);
    } else {
        return new Site(p, index, weight, color);
    }
};

/**
 * sort sites on y, then x, coord
 * also change each site's _siteIndex to match its new position in the list
 * so the _siteIndex can be used to identify the site for nearest-neighbor queries
 * 
 * haha "also" - means more than one responsibility...
 * 
 */
exports.sortSites = function (sites) {
    sites.sort(voronoiModule.compareSiteByYThenX);
    _(sites).each(function (site, i) {
        sites[i]._siteIndex = i;
    });
};
},{"../../as3/point-core":4,"../../as3/rectangle":5,"../../janicek/core":10,"../geom/polygon":36,"../geom/winding":37,"./bounds-check":19,"./criterion":20,"./edge":24,"./edge-reorderer":23,"./lr":28,"./voronoi":33,"lodash":1}],32:[function(require,module,exports){
/* jshint es3:false */

'use strict';

var _pool = [];
var _nvertices = 0;

var Vertex = function (x, y) {
    this.init(x, y);
};

Vertex.prototype = {
    _coord: null,

    get coord() { return this._coord; },

    vertexIndex: 0,

    init: function (x, y) {
        this._coord = {x: x, y: y};
        return this;
    },

    dispose: function () {
        this._coord = null;
        _pool.push(this);
    },

    setIndex: function () {
        this.vertexIndex = _nvertices++;
    },

    toString: function () {
        return 'Vertex (' + this.vertexIndex + ')';
    },

    get x() {
        return this._coord.x;
    },

    get y() {
        return this._coord.y;
    }

};

function create(x, y) {
    if (isNaN(x) || isNaN(y)) {
        return exports.VERTEX_AT_INFINITY;
    }
    if (_pool.length > 0) {
        return _pool.pop().init(x, y);
    } else {
        return new Vertex(x, y);
    }
}

exports.VERTEX_AT_INFINITY = new Vertex(NaN, NaN);

/**
 * This is the only way to make a Vertex
 * 
 * @param halfedge0
 * @param halfedge1
 * @return 
 * 
 */
exports.intersect = function (halfedge0, halfedge1) {
    var voronoi = require('./voronoi');
    var lr = require('./lr');

    var edge0, edge1, edge;
    var halfedge;
    var determinant, intersectionX, intersectionY;
    var rightOfSite;

    edge0 = halfedge0.edge;
    edge1 = halfedge1.edge;
    if (edge0 === null || edge1 === null) {
        return null;
    }
    if (edge0.rightSite === edge1.rightSite) {
        return null;
    }

    determinant = edge0.a * edge1.b - edge0.b * edge1.a;
    if (-1.0e-10 < determinant && determinant < 1.0e-10) {
        // the edges are parallel
        return null;
    }

    intersectionX = (edge0.c * edge1.b - edge1.c * edge0.b) / determinant;
    intersectionY = (edge1.c * edge0.a - edge0.c * edge1.a) / determinant;

    //if (Voronoi.isInfSite(edge0.rightSite, edge1.rightSite))  //HxDelaunay
    if (voronoi.compareSiteByYThenX(edge0.rightSite, edge1.rightSite) < 0) {
        halfedge = halfedge0;
        edge = edge0;
    } else {
        halfedge = halfedge1;
        edge = edge1;
    }
    rightOfSite = intersectionX >= edge.rightSite.x;
    if ((rightOfSite && halfedge.leftRight === lr.LEFT) ||
        (!rightOfSite && halfedge.leftRight === lr.RIGHT)) {
        return null;
    }
    return create(intersectionX, intersectionY);
};
},{"./lr":28,"./voronoi":33}],33:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var criterion = require('./criterion');
var core = require('../../janicek/core');
var def = require('../../janicek/core').def;
var delaunayModule = require('./delaunay');
var edgeListModule = require('./edge-list');
var edgeModule = require('./edge');
var edgeReordererModule = require('./edge-reorderer');
var halfEdgeModule = require('./halfedge');
var halfedgePriorityQueue = require('./halfedge-priority-queue');
var kruskalModule = require('./kruskal');
var lr = require('./lr');
var pointCore = require('../../as3/point-core');
var prngModule = require('../../polygonal/pm-prng');
var siteListModule = require('./site-list');
var siteModule = require('./site');
var vertexModule = require('./vertex');

exports.make = function (points, colors, plotBoundsArg) {

    var _prng = prngModule();
    var _sites = siteListModule();
    var _sitesIndexedByLocation = {}; // Dictionary<Site>
    var _triangles = []; // Vector<Triangle>
    var _edges = []; // Vector<Edge>

    var pub = {};

    // TODO generalize this so it doesn't have to be a rectangle;
    // then we can make the fractal voronois-within-voronois
    pub.plotBounds = plotBoundsArg;

    pub.dispose = function () {
        var i, n;
        if (_sites !== null) {
            _sites.dispose();
            _sites = null;
        }
        if (_triangles !== null) {
            n = _triangles.length;
            for (i = 0; i < n; i++) {
                _triangles[i].dispose();
            }
            //_triangles.length = 0;
            _triangles = null;
        }
        if (_edges !== null) {
            n = _edges.length;
            for (i = 0; i < n; i++) {
                _edges[i].dispose();
            }
            //_edges.length = 0;
            _edges = null;
        }
        pub.plotBounds = null;
        _sitesIndexedByLocation = null;
    };

    /**
     * AS3 Dictionary stores object keys by object identity.
     * Haxe Hash only supports string keys.
     * This means duplicate coordinates can't be stored in hash.
     * Prevent this case until it's possible to store duplicate points coords.
     */
    function makeSureNoDuplicatePoints(points) {
        var h = {};
        _(points).each(function (p) {
            if (_(h).has(pointCore.hash(p))) {
                throw 'Duplicate points not supported yet!';
            }
            h[pointCore.hash(p)] = p;
        });
    }

    function addSites(points, colors) {
        var length = points.length;
        for (var i = 0; i < length; i++) {
            addSite(points[i], (colors !== null) ? colors[i] : 0, i);
        }
    }

    function addSite(p, color, index) {
        var weight = _prng.nextDouble() * 100;
        var site = siteModule.create(p, index, weight, color);
        _sites.push(site);
        _sitesIndexedByLocation[pointCore.hash(p)] = site;
    }

    pub.edges = function () {
        return _edges;
    };

    pub.region = function (p) {
        var site = _sitesIndexedByLocation[pointCore.hash(p)];
        if (site === null) {
            return [];
        }
        return site.region(pub.plotBounds);
    };

    // TODO: bug: if you call this before you call region(), something goes wrong :(
    pub.neighborSitesForSite = function (coord) {
        var points = []; // Vector<Point>
        var site = _sitesIndexedByLocation[pointCore.hash(coord)];
        if (site === null) {
            return points;
        }
        var sites = site.neighborSites();
        _(sites).each(function (neighbor) {
            points.push(neighbor.coord);
        });
        return points;
    };

    pub.circles = function () {
        return _sites.circles();
    };

    pub.voronoiBoundaryForSite = function (coord) {
        return delaunayModule.visibleLineSegments(delaunayModule.selectEdgesForSitePoint(coord, _edges));
    };

    pub.delaunayLinesForSite = function (coord) {
        return delaunayModule.delaunayLinesForEdges(delaunayModule.selectEdgesForSitePoint(coord, _edges));
    };

    pub.voronoiDiagram = function () {
        return delaunayModule.visibleLineSegments(_edges);
    };

    pub.delaunayTriangulation = function (keepOutMask) {
        keepOutMask = def(keepOutMask, null);
        return delaunayModule.delaunayLinesForEdges(delaunayModule.selectNonIntersectingEdges(keepOutMask, _edges));
    };

    pub.hull = function () {
        return delaunayModule.delaunayLinesForEdges(hullEdges());
    };

    function hullEdges() {
        return _(_edges).filter(function (edge) {
            return (edge.isPartOfConvexHull());
        });
    }

    pub.hullPointsInOrder = function () {
        var hullEdges = hullEdges();
        
        var points = [];
        if (hullEdges.length === 0) {
            return points;
        }
        
        var reorderer = edgeReordererModule(hullEdges, criterion.site);
        hullEdges = reorderer.edges;
        var orientations = reorderer.edgeOrientations;
        reorderer.dispose();
        
        var orientation;

        var n = hullEdges.length;
        var i;
        for (i = 0; i < n; i++) {
            var edge = hullEdges[i];
            orientation = orientations[i];
            points.push(edge.site(orientation).coord);
        }
        return points;
    };

    pub.spanningTree = function (type, keepOutMask) {
        type = def(type, 'minimum');
        keepOutMask = def(keepOutMask, null);

        var edges = delaunayModule.selectNonIntersectingEdges(keepOutMask, _edges);
        var segments = delaunayModule.delaunayLinesForEdges(edges);
        return kruskalModule.kruskal(segments, type);
    };

    pub.regions = function () {
        return _sites.regions(pub.plotBounds);
    };

    pub.siteColors = function (referenceImage) {
        referenceImage = def(referenceImage, null);
        return _sites.siteColors(referenceImage);
    };

    /**
     * 
     * @param proximityMap a BitmapData whose regions are filled with the site index values; see PlanePointsCanvas::fillRegions()
     * @param x
     * @param y
     * @return coordinates of nearest Site to (x, y)
     * 
     */
    pub.nearestSitePoint = function (proximityMap, x, y) {
        return _sites.nearestSitePoint(proximityMap, x, y);
    };

    pub.siteCoords = function () {
        return _sites.siteCoords();
    };

    function fortunesAlgorithm() {
        var newSite, bottomSite, topSite, tempSite;
        var v, vertex;
        var newintstar;
        var leftRight;
        var lbnd, rbnd, llbnd, rrbnd, bisector;
        var edge;
        
        var dataBounds = _sites.getSitesBounds();
        
        var sqrtNsites = core.toInt(Math.sqrt(_sites.length + 4));
        var heap = halfedgePriorityQueue(dataBounds.y, dataBounds.height, sqrtNsites);
        var edgeList = edgeListModule(dataBounds.x, dataBounds.width, sqrtNsites);
        var halfEdges = [];
        var vertices = [];
        
        var bottomMostSite = _sites.next();
        newSite = _sites.next();

        function leftRegion(he) {
            var edge = he.edge;
            if (edge === null) {
                return bottomMostSite;
            }
            return edge.site(he.leftRight);
        }
        
        function rightRegion(he) {
            var edge = he.edge;
            if (edge === null) {
                return bottomMostSite;
            }
            return edge.site(lr.other(he.leftRight));
        }
        
        while (true) {
            if (heap.empty() === false) {
                newintstar = heap.min();
            }
        
            if (newSite !== null &&  (heap.empty() || exports.comparePointByYThenX(newSite, newintstar) < 0)) {
                /* new site is smallest */
                
                // Step 8:
                lbnd = edgeList.edgeListLeftNeighbor(newSite.coord);    // the Halfedge just to the left of newSite
                rbnd = lbnd.edgeListRightNeighbor;      // the Halfedge just to the right
                bottomSite = rightRegion(lbnd);     // this is the same as leftRegion(rbnd)
                // this Site determines the region containing the new site
                
                // Step 9:
                edge = edgeModule.createBisectingEdge(bottomSite, newSite);
                _edges.push(edge);
                
                bisector = halfEdgeModule.create(edge, lr.LEFT);
                halfEdges.push(bisector);
                // inserting two Halfedges into edgeList constitutes Step 10:
                // insert bisector to the right of lbnd:
                edgeList.insert(lbnd, bisector);
                
                // first half of Step 11:
                if ((vertex = vertexModule.intersect(lbnd, bisector)) !== null) {
                    vertices.push(vertex);
                    heap.remove(lbnd);
                    lbnd.vertex = vertex;
                    lbnd.ystar = vertex.y + newSite.dist(vertex);
                    heap.insert(lbnd);
                }
                
                lbnd = bisector;
                bisector = halfEdgeModule.create(edge, lr.RIGHT);
                halfEdges.push(bisector);
                // second Halfedge for Step 10:
                // insert bisector to the right of lbnd:
                edgeList.insert(lbnd, bisector);
                
                // second half of Step 11:
                if ((vertex = vertexModule.intersect(bisector, rbnd)) !== null) {
                    vertices.push(vertex);
                    bisector.vertex = vertex;
                    bisector.ystar = vertex.y + newSite.dist(vertex);
                    heap.insert(bisector);
                }
                
                newSite = _sites.next();
            } else if (heap.empty() === false) {
                /* intersection is smallest */
                lbnd = heap.extractMin();
                llbnd = lbnd.edgeListLeftNeighbor;
                rbnd = lbnd.edgeListRightNeighbor;
                rrbnd = rbnd.edgeListRightNeighbor;
                bottomSite = leftRegion(lbnd);
                topSite = rightRegion(rbnd);
                // these three sites define a Delaunay triangle
                // (not actually using these for anything...)
                //_triangles.push(new Triangle(bottomSite, topSite, rightRegion(lbnd)));
                
                v = lbnd.vertex;
                v.setIndex();
                lbnd.edge.setVertex(lbnd.leftRight, v);
                rbnd.edge.setVertex(rbnd.leftRight, v);
                edgeList.remove(lbnd);
                heap.remove(rbnd);
                edgeList.remove(rbnd);
                leftRight = lr.LEFT;
                if (bottomSite.y > topSite.y) {
                    tempSite = bottomSite;
                    bottomSite = topSite;
                    topSite = tempSite;
                    leftRight = lr.RIGHT;
                }
                edge = edgeModule.createBisectingEdge(bottomSite, topSite);
                _edges.push(edge);
                bisector = halfEdgeModule.create(edge, leftRight);
                halfEdges.push(bisector);
                edgeList.insert(llbnd, bisector);
                edge.setVertex(lr.other(leftRight), v);
                if ((vertex = vertexModule.intersect(llbnd, bisector)) !== null) {
                    vertices.push(vertex);
                    heap.remove(llbnd);
                    llbnd.vertex = vertex;
                    llbnd.ystar = vertex.y + bottomSite.dist(vertex);
                    heap.insert(llbnd);
                }
                if ((vertex = vertexModule.intersect(bisector, rrbnd)) !== null) {
                    vertices.push(vertex);
                    bisector.vertex = vertex;
                    bisector.ystar = vertex.y + bottomSite.dist(vertex);
                    heap.insert(bisector);
                }
            } else {
                break;
            }
        }
        
        // heap should be empty now
        heap.dispose();
        edgeList.dispose();
        
        _(halfEdges).each(function (halfEdge) {
            halfEdge.reallyDispose();
        });
        //halfEdges.length = 0;
        
        // we need the vertices to clip the edges
        _(_edges).each(function (edge) {
            edge.clipVertices(pub.plotBounds);
        });
        // but we don't actually ever use them again!
        _(vertices).each(function (vertex) {
            vertex.dispose();
        });
        //vertices.length = 0;
    }

    makeSureNoDuplicatePoints(points);
    _prng.seed = 1;
    addSites(points, colors);
    fortunesAlgorithm();

    return pub;
};

/**
 * HxDelaunay
 */
exports.isInfSite = function (s1, s2) {
    return (s1.y < s2.y) || (s1.y === s2.y && s1.x < s2.x);
};

exports.comparePointByYThenX = function (s1, s2) {
    return exports.compareByYThenX(s1.x, s1.y, s2.x, s2.y);
};

exports.compareSiteByYThenX = function (s1, s2) {
    return exports.compareByYThenX(s1.x, s1.y, s2.x, s2.y);
};

exports.compareByYThenX = function (s1x, s1y, s2x, s2y) {
    if (s1y < s2y) { return -1; }
    if (s1y > s2y) { return 1; }
    if (s1x < s2x) { return -1; }
    if (s1x > s2x) { return 1; }
    return 0;
};
},{"../../as3/point-core":4,"../../janicek/core":10,"../../polygonal/pm-prng":38,"./criterion":20,"./delaunay":21,"./edge":24,"./edge-list":22,"./edge-reorderer":23,"./halfedge":26,"./halfedge-priority-queue":25,"./kruskal":27,"./lr":28,"./site":31,"./site-list":30,"./vertex":32,"lodash":1}],34:[function(require,module,exports){
'use strict';

module.exports = function (centerX, centerY, radius) {
    return {
        center: {x: centerX, y: centerY},
        radius: radius,
        toString: function () {
            return 'Circle (center: ' + this.center + '; radius: ' + this.radius + ')';
        }
    };
};
},{}],35:[function(require,module,exports){
'use strict';

var pointCore = require('../../as3/point-core');

exports.make = function (p0, p1) {
    return {
        p0: p0,
        p1: p1
    };
};

exports.core = {
    compareLengthsMax: function (segment0, segment1) {
        var length0 = pointCore.distance(segment0.p0, segment0.p1);
        var length1 = pointCore.distance(segment1.p0, segment1.p1);
        if (length0 < length1) {
            return 1;
        }
        if (length0 > length1) {
            return -1;
        }
        return 0;
    },

    compareLengths: function (edge0, edge1) {
        return - this.compareLengthsMax(edge0, edge1);
    }
};
},{"../../as3/point-core":4}],36:[function(require,module,exports){
'use strict';

var winding = require('./winding');

var Polygon = function (vertices) {
    this._vertices = vertices;
};

Polygon.prototype = {
    area: function () {
        return Math.abs(this.signedDoubleArea() * 0.5);
    },

    winding: function () {
        var signedDoubleArea = this.signedDoubleArea();
        if (signedDoubleArea < 0) {
            return winding.CLOCKWISE;
        }
        if (signedDoubleArea > 0) {
            return winding.COUNTERCLOCKWISE;
        }
        return winding.NONE;
    },

    signedDoubleArea: function () {
        var index, nextIndex;
        var n = this._vertices.length;
        var point, next;
        var signedDoubleArea = 0;
        for (index = 0; index < n; index++) {
            nextIndex = (index + 1) % n;
            point = this._vertices[index];
            next = this._vertices[nextIndex];
            signedDoubleArea += point.x * next.y - next.x * point.y;
        }
        return signedDoubleArea;
    }
};

module.exports = function (vertices) {
    return new Polygon(vertices);
};
},{"./winding":37}],37:[function(require,module,exports){
'use strict';

module.exports = {
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise',
    NONE: 'none'
};
},{}],38:[function(require,module,exports){
'use strict';

module.exports = function () {

    return {

        /**
         * set seed with a 31 bit unsigned integer
         * between 1 and 0X7FFFFFFE inclusive. don't use 0!
         */
        seed: 1,

        /**
         * provides the next pseudorandom number
         * as a float between nearly 0 and nearly 1.0.
         */
        nextDouble: function () {
            return (this.gen() / 2147483647);
        },

        /**
         * provides the next pseudorandom number
         * as an unsigned integer (31 bits) betweeen
         * a given range.
         */
        nextIntRange: function (min, max) {
            min -= 0.4999;
            max += 0.4999;
            return Math.round(min + ((max - min) * this.nextDouble()));
        },

        /**
         * provides the next pseudorandom number
         * as a float between a given range.
         */
        nextDoubleRange: function (min, max) {
            return min + ((max - min) * this.nextDouble());
        },

        /**
         * generator:
         * new-value = (old-value * 16807) mod (2^31 - 1)
         */
        gen: function () {
            //integer version 1, for max int 2^46 - 1 or larger.
            this.seed = (this.seed * 16807) % 2147483647;
            return this.seed;
            
            /**
             * integer version 2, for max int 2^31 - 1 (slowest)
             */
            //var test:int = 16807 * (seed % 127773 >> 0) - 2836 * (seed / 127773 >> 0);
            //return seed = (test > 0 ? test : test + 2147483647);
            
            /**
             * david g. carta's optimisation is 15% slower than integer version 1
             */
            //var hi:uint = 16807 * (seed >> 16);
            //var lo:uint = 16807 * (seed & 0xFFFF) + ((hi & 0x7FFF) << 16) + (hi >> 15);
            //return seed = (lo > 0x7FFFFFFF ? lo - 0x7FFFFFFF : lo);
        }
    };
};
},{}],39:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var colorModule = require('../janicek/html-color');
var convert = require('../as3/conversion-core');
var core = require('../janicek/core');
var matrix = require('../as3/matrix');
var pointCore = require('../as3/point-core');
var vector3d = require('../as3/vector-3d');

exports.graphicsReset = function (c, mapWidth, mapHeight, displayColors) {
    c.lineWidth = 1.0;
    c.clearRect(0, 0, 2000, 2000);
    c.fillStyle = '#bbbbaa';
    c.fillRect(0, 0, 2000, 2000);
    c.fillStyle = colorModule.intToHexColor(displayColors.OCEAN);
    c.fillRect(0, 0, core.toInt(mapWidth), core.toInt(mapHeight));
};

var lightVector = vector3d.make(-1, -1, 0);

exports.calculateLighting = function (p, r, s) {
    var A = vector3d.make(p.point.x, p.point.y, p.elevation);
    var B = vector3d.make(r.point.x, r.point.y, r.elevation);
    var C = vector3d.make(s.point.x, s.point.y, s.elevation);
    var normal = B.subtract(A).crossProduct(C.subtract(A));
    if (normal.z < 0) { normal.scaleBy(-1); }
    normal.normalize();
    var light = 0.5 + 35 * normal.dotProduct(lightVector);
    if (light < 0) { light = 0; }
    if (light > 1) { light = 1; }
    return light;
};

exports.colorWithSlope = function (color, p, q, edge, displayColors) {
    var r = edge.v0;
    var s = edge.v1;
    if (_.isNull(r) || _.isNull(s)) {
        // Edge of the map
        return displayColors.OCEAN;
    } else if (p.water) {
        return color;
    }

    if (q !== null && p.water === q.water) {
        color = colorModule.interpolateColor(color, displayColors[q.biome], 0.4);
    }
    var colorLow = colorModule.interpolateColor(color, 0x333333, 0.7);
    var colorHigh = colorModule.interpolateColor(color, 0xffffff, 0.3);
    var light = exports.calculateLighting(p, r, s);
    if (light < 0.5) {
        return colorModule.interpolateColor(colorLow, color, light * 2);
    } else {
        return colorModule.interpolateColor(color, colorHigh, light * 2 - 1);
    }
};

exports.colorWithSmoothColors = function (color, p, q, edge, displayColors) {
    if (q !== null && p.water === q.water) {
        color = colorModule.interpolateColor(displayColors[p.biome], displayColors[q.biome], 0.25);
    }
    return color;
};

exports.renderDebugPolygons = function (context, map, displayColors) {

    var color;

    if (map.centers.length === 0) {
        // We're still constructing the map so we may have some points
        
        context.fillStyle = '#dddddd';
        context.fillRect(0, 0, core.toInt(map.SIZE.width), core.toInt(map.SIZE.height) /*context.canvas.width, context.canvas.height */); //graphics.drawRect(0, 0, SIZE, SIZE);
        _(map.points).each(function (point) {
            context.beginPath();
            context.strokeStyle = '#000000';
            context.fillStyle = '#000000';
            context.arc(point.x, point.y, 1.3, Math.PI, 2 * Math.PI, false);
            context.closePath();
            context.fill();
            context.stroke();
        });
    }
    
    _(map.centers).each(function (p) {
        color = !_.isNull(p.biome) ? displayColors[p.biome] : (p.ocean ? displayColors.OCEAN : p.water ? displayColors.RIVER : 0xffffff);
      
        //Draw shape
        context.beginPath();
        _(p.borders).each(function (edge) {
            if (!_.isNull(edge.v0) && !_.isNull(edge.v1)) {
                context.moveTo(p.point.x, p.point.y);
                context.lineTo(edge.v0.point.x, edge.v0.point.y);
                context.lineTo(edge.v1.point.x, edge.v1.point.y);
            }
        });
        context.closePath();
        context.fillStyle = colorModule.intToHexColor(colorModule.interpolateColor(color, 0xdddddd, 0.2));
        context.fill();

        //Draw borders
        _(p.borders).each(function (edge) {
            if (!_.isNull(edge.v0) && !_.isNull(edge.v1)) {
                context.beginPath();
                context.moveTo(edge.v0.point.x, edge.v0.point.y);
                if (edge.river > 0) {
                    context.lineWidth = 1;
                    context.strokeStyle = colorModule.intToHexColor(displayColors.RIVER);
                } else {
                    context.lineWidth = 0.1;
                    context.strokeStyle = '#000000';
                }
                context.lineTo(edge.v1.point.x, edge.v1.point.y);
                context.closePath();
                context.stroke();
            }
        });
        
        context.beginPath();
        context.fillStyle = (p.water ? '#003333' : '#000000');
        context.globalAlpha = 0.7;
        context.arc(p.point.x, p.point.y, 1.3, Math.PI, 2 * Math.PI, false);
        context.closePath();
        context.fill();
        context.globalAlpha = 1.0;
        _(p.corners).each(function (q) {
            context.fillStyle = q.water ? '#0000ff' : '#009900';
            context.fillRect(core.toInt(q.point.x - 0.7), core.toInt(q.point.y - 0.7), core.toInt(1.5), core.toInt(1.5));
        });
    });
};

/**
 * Render the paths from each polygon to the ocean, showing watersheds.
 */
exports.renderWatersheds = function (graphics, map, watersheds) {
    var edge, w0, w1;

    _(map.edges).each(function (edge) {
        if (!_.isNull(edge.d0) && !_.isNull(edge.d1) && !_.isNull(edge.v0) && !_.isNull(edge.v1) && !edge.d0.ocean && !edge.d1.ocean) {
            w0 = watersheds.watersheds[edge.d0.index];
            w1 = watersheds.watersheds[edge.d1.index];
            if (w0 !== w1) {
                graphics.beginPath();
                //graphics.lineStyle(3.5, 0x000000, 0.1 * Math.sqrt((map.corners[w0].watershedSize || 1) + (map.corners[w1].watershed.watershedSize || 1)));
                graphics.lineWidth = 3.5;
                graphics.strokeStyle = colorModule.rgba(0, 0, 0, 0.1 * Math.sqrt((core.coalesce(map.corners[w0].watershedSize, 1)) + (core.coalesce(map.corners[w1].watershed.watershedSize, 1))));
                graphics.moveTo(edge.v0.point.x, edge.v0.point.y);
                graphics.lineTo(edge.v1.point.x, edge.v1.point.y);
                graphics.closePath(); //graphics.lineStyle();
                graphics.stroke();
            }
        }
    });

    for (edge in map.edges) {
        if (convert.booleanFromInt(edge.river)) {
            graphics.beginPath();
            //graphics.lineStyle(1.0, 0x6699ff);
            graphics.lineWidth = 1.0;
            graphics.strokeStyle = '#6699ff';
            graphics.moveTo(edge.v0.point.x, edge.v0.point.y);
            graphics.lineTo(edge.v1.point.x, edge.v1.point.y);
            //graphics.lineStyle();
            graphics.closePath();
            graphics.stroke();
        }
    }
};

function drawPathForwards(graphics, path) {
    for (var i = 0; i < path.length; i++) {
        graphics.lineTo(path[i].x, path[i].y);
    }
}

/**
 * Helper function for drawing triangles with gradients. This
 * function sets up the fill on the graphics object, and then
 * calls fillFunction to draw the desired path.
 */
function drawGradientTriangle(graphics, v1, v2, v3, colors, fillFunction, fillX, fillY) {
    var m = matrix();

    // Center of triangle:
    var V = v1.add(v2).add(v3);
    V.scaleBy(1 / 3.0);

    // Normal of the plane containing the triangle:
    var N = v2.subtract(v1).crossProduct(v3.subtract(v1));
    N.normalize();

    // Gradient vector in x-y plane pointing in the direction of increasing z
    var G = vector3d.make(-N.x / N.z, -N.y / N.z, 0);

    // Center of the color gradient
    var C = vector3d.make(V.x - G.x * ((V.z - 0.5) / G.length / G.length), V.y - G.y * ((V.z - 0.5) / G.length / G.length));

    if (G.length < 1e-6) {
        // If the gradient vector is small, there's not much
        // difference in colors across this triangle. Use a plain
        // fill, because the numeric accuracy of 1/G.length is not to
        // be trusted.  NOTE: only works for 1, 2, 3 colors in the array
        var color = colors[0];
        if (colors.length === 2) {
            color = colorModule.interpolateColor(colors[0], colors[1], V.z);
        } else if (colors.length === 3) {
            if (V.z < 0.5) {
                color = colorModule.interpolateColor(colors[0], colors[1], V.z * 2);
            } else {
                color = colorModule.interpolateColor(colors[1], colors[2], V.z * 2 - 1);
            }
        }
        graphics.fillStyle = colorModule.intToHexColor(color); //graphics.beginFill(color);
    } else {
        // The gradient box is weird to set up, so we let Flash set up
        // a basic matrix and then we alter it:
        m.createGradientBox(1, 1, 0, 0, 0);
        m.translate(-0.5, -0.5);
        m.scale((1 / G.length), (1 / G.length));
        m.rotate(Math.atan2(G.y, G.x));
        m.translate(C.x, C.y);
        var alphas = _(colors).map(function (c) { return 1.0; });
        var spread = _(colors).map(function (c, index) { return 255 * index / (colors.length - 1); });
        //graphics.beginGradientFill(GradientType.LINEAR, colors, alphas, spread, m, SpreadMethod.PAD);
    }
    fillFunction(graphics, fillX, fillY);
    graphics.fill(); //graphics.endFill();
}

/**
 * Render the interior of polygons
 */
exports.renderPolygons = function (graphics, colors, gradientFillProperty, colorOverrideFunction, map, noisyEdges)  {
    // My Voronoi polygon rendering doesn't handle the boundary
    // polygons, so I just fill everything with ocean first.
    graphics.fillStyle = colorModule.intToHexColor(colors.OCEAN);
    graphics.fillRect(0, 0, core.toInt(map.SIZE.width), core.toInt(map.SIZE.height));
 
    var drawPath0 = function (graphics, x, y) {
        var path = noisyEdges.path0[edge.index];
        graphics.moveTo(x, y);
        graphics.lineTo(path[0].x, path[0].y);
        drawPathForwards(graphics, path);
        graphics.lineTo(x, y);
    };

    var drawPath1 = function (graphics, x, y) {
        var path = noisyEdges.path1[edge.index];
        graphics.moveTo(x, y);
        graphics.lineTo(path[0].x, path[0].y);
        drawPathForwards(graphics, path);
        graphics.lineTo(x, y);
    };

    for (var centerIndex = 0; centerIndex < map.centers.length; centerIndex++) {
        var p = map.centers[centerIndex];
        for (var neighborIndex = 0; neighborIndex < p.neighbors.length; neighborIndex++) {
            var r = p.neighbors[neighborIndex];
            var edge = map.lookupEdgeFromCenter(p, r);
            var color = core.coalesce(colors[p.biome], 0);
            if (colorOverrideFunction !== null) {
                color = colorOverrideFunction(color, p, r, edge, colors);
            }

            if (core.isUndefinedOrNull(noisyEdges.path0[edge.index]) || core.isUndefinedOrNull(noisyEdges.path1[edge.index])) {
                // It's at the edge of the map, where we don't have
                // the noisy edges computed. TODO: figure out how to
                // fill in these edges from the voronoi library.
                continue;
            }

            if (!core.isUndefinedOrNull(gradientFillProperty)) {
                // We'll draw two triangles: center - corner0 -
                // midpoint and center - midpoint - corner1.
                var corner0 = edge.v0;
                var corner1 = edge.v1;

                // We pick the midpoint elevation/moisture between
                // corners instead of between polygon centers because
                // the resulting gradients tend to be smoother.
                var midpoint = edge.midpoint;
                var midpointAttr = 0.5 * (corner0[gradientFillProperty] + corner1[gradientFillProperty]);
                drawGradientTriangle(
                    graphics,
                    vector3d.make(p.point.x, p.point.y, p[gradientFillProperty]),
                    vector3d.make(corner0.point.x, corner0.point.y, corner0[gradientFillProperty]),
                    vector3d.make(midpoint.x, midpoint.y, midpointAttr),
                    [colors.GRADIENT_LOW, colors.GRADIENT_HIGH],
                    drawPath0, p.point.x, p.point.y
                );
                drawGradientTriangle(
                    graphics,
                    vector3d.make(p.point.x, p.point.y, p[gradientFillProperty]),
                    vector3d.make(midpoint.x, midpoint.y, midpointAttr),
                    vector3d.make(corner1.point.x, corner1.point.y, corner1[gradientFillProperty]),
                    [colors.GRADIENT_LOW, colors.GRADIENT_HIGH],
                    drawPath1, p.point.x, p.point.y
                );
            } else {
                graphics.fillStyle = colorModule.intToHexColor(color);
                graphics.strokeStyle = graphics.fillStyle;
                graphics.beginPath();
                drawPath0(graphics, p.point.x, p.point.y);
                drawPath1(graphics, p.point.x, p.point.y);
                graphics.closePath();
                graphics.fill();
                graphics.stroke();
            }
        }
    }
};

/**
 * Render bridges across every narrow river edge. Bridges are
 * straight line segments perpendicular to the edge. Bridges are
 * drawn after rivers. TODO: sometimes the bridges aren't long
 * enough to cross the entire noisy line river. TODO: bridges
 * don't line up with curved road segments when there are
 * roads. It might be worth making a shader that draws the bridge
 * only when there's water underneath.
 */
exports.renderBridges = function (graphics, map, roads, colors) {
    _(map.edges).each(function (edge) {
        if (edge.river > 0 && edge.river < 4 &&
            !edge.d0.water && !edge.d1.water &&
            (edge.d0.elevation > 0.05 || edge.d1.elevation > 0.05)) {

            var n = { x: -(edge.v1.point.y - edge.v0.point.y), y: edge.v1.point.x - edge.v0.point.x };
            pointCore.normalize(n, 0.25 + (!_.isNull(roads.road[edge.index]) ? 0.5 : 0) + 0.75 * Math.sqrt(edge.river));
            graphics.beginPath();
            graphics.lineWidth = 1.1;
            graphics.strokeStyle = colorModule.intToHexColor(colors.BRIDGE);
            graphics.lineCap = 'square';
            graphics.moveTo(edge.midpoint.x - n.x, edge.midpoint.y - n.y);
            graphics.lineTo(edge.midpoint.x + n.x, edge.midpoint.y + n.y);
            graphics.closePath();
            graphics.stroke();
        }
    });
};

/**
 * Render roads. We draw these before polygon edges, so that rivers overwrite roads.
 */
exports.renderRoads = function (graphics, map, roads, colors) {
    // First draw the roads, because any other feature should draw
    // over them. Also, roads don't use the noisy lines.
    var A, B, C;
    var i, j, d, edge1, edge2, edges;

    /**
     * Helper function: find the normal vector across edge 'e' and
     * make sure to point it in a direction towards 'c'.
     */
    function normalTowards(e, c, len) {
        // Rotate the v0-->v1 vector by 90 degrees:
        var n = { x: -(e.v1.point.y - e.v0.point.y), y: e.v1.point.x - e.v0.point.x };
        // Flip it around it if doesn't point towards c
        var d = pointCore.subtract(c, e.midpoint);
        if (n.x * d.x + n.y * d.y < 0) {
            n.x = -n.x;
            n.y = -n.y;
        }
        pointCore.normalize(n, len);
        return n;
    }
  
    _(map.centers).each(function (p) {
        if (!core.isUndefinedOrNull(roads.roadConnections[p.index])) {
            if (roads.roadConnections[p.index].length === 2) {
                // Regular road: draw a spline from one edge to the other.
                edges = p.borders;
                for (i = 0; i < edges.length; i++) {
                    edge1 = edges[i];
                    if (roads.road[edge1.index] > 0) {
                        for (j = i + 1; j < edges.length; j++) {
                            edge2 = edges[j];
                            if (roads.road[edge2.index] > 0) {
                                // The spline connects the midpoints of the edges
                                // and at right angles to them. In between we
                                // generate two control points A and B and one
                                // additional vertex C.  This usually works but
                                // not always.
                                d = 0.5 * Math.min(
                                    pointCore.distanceFromOrigin(pointCore.subtract(edge1.midpoint, p.point)),
                                    pointCore.distanceFromOrigin(pointCore.subtract(edge2.midpoint, p.point))
                                );
                                A = pointCore.add(normalTowards(edge1, p.point, d), edge1.midpoint);
                                B = pointCore.add(normalTowards(edge2, p.point, d), edge2.midpoint);
                                C = pointCore.interpolate(A, B, 0.5);
                                graphics.beginPath();
                                graphics.lineWidth = 1.1;
                                graphics.strokeStyle = colorModule.intToHexColor(colors['ROAD' + roads.road[edge1.index]]);
                                graphics.moveTo(edge1.midpoint.x, edge1.midpoint.y);
                                graphics.quadraticCurveTo(A.x, A.y, C.x, C.y);
                                graphics.moveTo(C.x, C.y);
                                graphics.lineWidth = 1.1;
                                graphics.strokeStyle = colorModule.intToHexColor(colors['ROAD' + roads.road[edge2.index]]);
                                graphics.quadraticCurveTo(B.x, B.y, edge2.midpoint.x, edge2.midpoint.y);
                                graphics.stroke();
                                graphics.closePath();
                            }
                        }
                    }
                }
            } else {
                // Intersection or dead end: draw a road spline from
                // each edge to the center
                _(p.borders).each(function (edge1) {
                    if (roads.road[edge1.index] > 0) {
                        d = 0.25 * pointCore.distanceFromOrigin(pointCore.subtract(edge1.midpoint, p.point));
                        A = pointCore.add(normalTowards(edge1, p.point, d), edge1.midpoint);
                        graphics.beginPath();
                        graphics.lineWidth = 1.4;
                        graphics.strokeStyle = colorModule.intToHexColor(colors['ROAD' + roads.road[edge1.index]]);
                        graphics.moveTo(edge1.midpoint.x, edge1.midpoint.y);
                        graphics.quadraticCurveTo(A.x, A.y, p.point.x, p.point.y);
                        graphics.stroke();
                        graphics.closePath();
                    }
                });
            }
        }
    });
};

function drawPathBackwards(graphics, path) {
    var i = path.length - 1;
    while (i >= 0) {
        graphics.lineTo(path[i].x, path[i].y);
        i--;
    }
}

/**
 * Render the exterior of polygons: coastlines, lake shores,
 * rivers, lava fissures. We draw all of these after the polygons
 * so that polygons don't overwrite any edges.
 */
exports.renderEdges = function (graphics, colors, map, noisyEdges, lava, renderRivers) {
    renderRivers = core.def(renderRivers, true);
    var edge;
    
    for (var centerIndex = 0; centerIndex < map.centers.length; centerIndex++) {
        var p = map.centers[centerIndex];
        for (var neighborIndex = 0; neighborIndex < p.neighbors.length; neighborIndex++) {
            var r = p.neighbors[neighborIndex];
            edge = map.lookupEdgeFromCenter(p, r);
            if (core.isUndefinedOrNull(noisyEdges.path0[edge.index]) || core.isUndefinedOrNull(noisyEdges.path1[edge.index])) {
                // It's at the edge of the map
                continue;
            }
            if (p.ocean !== r.ocean) {
                // One side is ocean and the other side is land -- coastline
                graphics.lineWidth = 2;
                graphics.strokeStyle = colorModule.intToHexColor(colors.COAST);
            } else if ((convert.intFromBoolean(p.water) > 0) !== (convert.intFromBoolean(r.water) > 0) && p.biome !== 'ICE' && r.biome !== 'ICE') {
                // Lake boundary
                graphics.lineWidth = 1;
                graphics.strokeStyle = colorModule.intToHexColor(colors.LAKESHORE);
            } else if (p.water || r.water) {
                // Lake interior – we don't want to draw the rivers here
                continue;
            } else if (lava.lava[edge.index]) {
                // Lava flow
                graphics.lineWidth = 1;
                graphics.strokeStyle = colorModule.intToHexColor(colors.LAVA);
            } else if (edge.river > 0 && renderRivers) {
                // River edge
                graphics.lineWidth = Math.sqrt(edge.river);
                graphics.strokeStyle = colorModule.intToHexColor(colors.RIVER);
            } else {
                continue;
            }
            
            graphics.beginPath();
            graphics.moveTo(noisyEdges.path0[edge.index][0].x, noisyEdges.path0[edge.index][0].y);
            drawPathForwards(graphics, noisyEdges.path0[edge.index]);
            drawPathBackwards(graphics, noisyEdges.path1[edge.index]);
            graphics.stroke();
            graphics.closePath();
        }
    }
};

exports.renderAllEdges = function (graphics, strokeStyle, map, noisyEdges) {
    var edge;

    graphics.lineWidth = 5;
    graphics.strokeStyle = strokeStyle;

    for (var centerIndex = 0; centerIndex < map.centers.length; centerIndex++) {
        var p = map.centers[centerIndex];
        for (var neighborIndex = 0; neighborIndex < p.neighbors.length; neighborIndex++) {
            var r = p.neighbors[neighborIndex];
            edge = map.lookupEdgeFromCenter(p, r);

            if (core.isUndefinedOrNull(noisyEdges.path0[edge.index]) || core.isUndefinedOrNull(noisyEdges.path1[edge.index]) || p.water) {
                // It's at the edge of the map or water
                continue;
            }

            // edge

            graphics.beginPath();
            graphics.moveTo(noisyEdges.path0[edge.index][0].x, noisyEdges.path0[edge.index][0].y);
            drawPathForwards(graphics, noisyEdges.path0[edge.index]);
            drawPathBackwards(graphics, noisyEdges.path1[edge.index]);
            graphics.stroke();
            graphics.closePath();
        }
    }
};

},{"../as3/conversion-core":2,"../as3/matrix":3,"../as3/point-core":4,"../as3/vector-3d":6,"../janicek/core":10,"../janicek/html-color":12,"lodash":1}],40:[function(require,module,exports){
'use strict';

module.exports = function () {
    return {
        index: null,
      
        point: null,        // Point location
        water: null,        // lake or ocean
        ocean: null,        // ocean
        coast: null,        // land polygon touching an ocean
        border: null,       // at the edge of the map
        biome: null,          // biome type (see article)
        elevation: null,     // 0.0-1.0
        moisture: null,      // 0.0-1.0

        neighbors: null,    // Vector<Center>
        borders: null,      // Vector<Edge>
        corners: null       // Vector<Corner>
    };
};
},{}],41:[function(require,module,exports){
'use strict';

module.exports = function () {
    return {
        index: null,
      
        point: null,  // location
        ocean: null,  // ocean
        water: null,  // lake or ocean
        coast: null,  // touches ocean and land polygons
        border: null,  // at the edge of the map
        elevation: null,  // 0.0-1.0
        moisture: null,  // 0.0-1.0

        touches: null,
        protrudes: null,
        adjacent: null,
      
        river: null,  // 0 if no river, or volume of water in river
        downslope: null,  // pointer to adjacent corner most downhill
        watershed: null,  // pointer to coastal corner, or null
        watershedSize: null
    };
};
},{}],42:[function(require,module,exports){
'use strict';

module.exports = function () {
    return {
        index: 0,
        d0: null,  // Delaunay edge
        d1: null,  // Delaunay edge
        v0: null,  // Voronoi edge
        v1: null,  // Voronoi edge
        midpoint: null,  // halfway between v0,v1
        river: 0  // volume of water, or 0
    };
};
},{}],43:[function(require,module,exports){
/* jshint bitwise:false */

/**
 * Factory class to build the 'inside' function that tells us whether
 * a point should be on the island or in the water.
 * 
 * This class has factory functions for generating islands of
 * different shapes. The factory returns a function that takes a
 * normalized point (x and y are -1 to +1) and returns true if the
 * point should be on the island, and false if it should be water
 * (lake or ocean).
 */

'use strict';

var array2d = require('../janicek/array2d');
var core = require('../janicek/core');
var distanceFromOrigin = require('../as3/point-core').distanceFromOrigin;
var perlinNoise = require('../janicek/perlin-noise');
var prngModule = require('../polygonal/pm-prng');
var prng = require('../janicek/pseudo-random-number-generators');

/**
* The radial island radius is based on overlapping sine waves 
* @param seed
* @param islandFactor = 1.0 means no small islands; 2.0 leads to a lot
*/
exports.makeRadial = function (seed, islandFactor) {
    islandFactor = core.def(islandFactor, 1.07);

    var islandRandom = prngModule();
    islandRandom.seed = seed;
    var bumps = islandRandom.nextIntRange(1, 6);
    var startAngle = islandRandom.nextDoubleRange(0, 2 * Math.PI);
    var dipAngle = islandRandom.nextDoubleRange(0, 2 * Math.PI);
    var dipWidth = islandRandom.nextDoubleRange(0.2, 0.7);

    function inside(q) {
        var angle = Math.atan2(q.y, q.x);
        var length = 0.5 * (Math.max(Math.abs(q.x), Math.abs(q.y)) + distanceFromOrigin(q));

        var r1 = 0.5 + 0.40 * Math.sin(startAngle + bumps * angle + Math.cos((bumps + 3) * angle));
        var r2 = 0.7 - 0.20 * Math.sin(startAngle + bumps * angle - Math.sin((bumps + 2) * angle));
        if (Math.abs(angle - dipAngle) < dipWidth ||
            Math.abs(angle - dipAngle + 2 * Math.PI) < dipWidth ||
            Math.abs(angle - dipAngle - 2 * Math.PI) < dipWidth) {
            r1 = r2 = 0.2;
        }
        return  (length < r1 || (length > r1 * islandFactor && length < r2));
    }

    return inside;
};

/**
 * The Perlin-based island combines perlin noise with the radius.
 * @param   seed
 * @param   oceanRatio 0 = least ocean, 1 = most ocean
 */
exports.makePerlin = function (seed, oceanRatio) {
    oceanRatio = core.def(oceanRatio, 0.5);

    var landRatioMinimum = 0.1;
    var landRatioMaximum = 0.5;
    oceanRatio = ((landRatioMaximum - landRatioMinimum) * oceanRatio) + landRatioMinimum;  //min: 0.1 max: 0.5
    var perlin = array2d(perlinNoise.makePerlinNoise(256, 256, 1.0, 1.0, 1.0, seed, 8));
    //perlin.perlinNoise(64, 64, 8, seed, false, true); //mapgen2

    return function (q) {
        var c = (perlin.get(core.toInt((q.x + 1) * 128), core.toInt((q.y + 1) * 128)) & 0xff) / 255.0;
        //var c:Number = (perlin.getPixel(Std.int((q.x+1)*128), Std.int((q.y+1)*128)) & 0xff) / 255.0; //mapgen2
        return c > (oceanRatio + oceanRatio * distanceFromOrigin(q) * distanceFromOrigin(q));
    };
};

/**
 * The square shape fills the entire space with land
 */
exports.makeSquare = function () {
    return function (q) {
        return true;
    };
};

/**
* The blob island is shaped like Amit's blob logo
*/
exports.makeBlob = function () {
    return function (q) {
        var eye1 = distanceFromOrigin({ x: q.x - 0.2, y: q.y / 2 + 0.2 }) < 0.05;
        var eye2 = distanceFromOrigin({ x: q.x + 0.2, y: q.y / 2 + 0.2 }) < 0.05;
        var body = distanceFromOrigin(q) < 0.8 - 0.18 * Math.sin(5 * Math.atan2(q.y, q.x));
        return body && !eye1 && !eye2;
    };
};

/**
 * Make island from bitmap.
 * @param {[[boolean]]} bitmap
 */
exports.makeBitmap = function (bitmap) {
    bitmap = array2d(bitmap);
    var dimensions = bitmap.dimensions();
    return function (q) {
        var x = ((q.x + 1) / 2) * dimensions.x;
        var y = ((q.y + 1) / 2) * dimensions.y;
        return bitmap.get(x, y);
    };
};

/**
 * Make island from simple noise.
 */
exports.makeNoise = function (seed) {
    return function (q) {
        seed = prng.nextParkMiller(seed);
        return prng.toBool(seed);
    };
};
},{"../as3/point-core":4,"../janicek/array2d":8,"../janicek/core":10,"../janicek/perlin-noise":15,"../janicek/pseudo-random-number-generators":16,"../polygonal/pm-prng":38}],44:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var cc = require('../as3/conversion-core');

exports.FRACTION_LAVA_FISSURES = 0.2;  // 0 to 1, probability of fissure

exports.make = function () {
    return {

        // The lava array marks the edges that hava lava.
        lava: [], // Array<Boolean> edge index -> Boolean

        // Lava fissures are at high elevations where moisture is low
        createLava: function (map, randomDouble) {
            _(map.edges).each(function (edge) {
                if (!cc.booleanFromInt(edge.river) &&
                    !edge.d0.water && !edge.d1.water &&
                    edge.d0.elevation > 0.8 && edge.d1.elevation > 0.8 &&
                    edge.d0.moisture < 0.3 && edge.d1.moisture < 0.3 &&
                    randomDouble() < exports.FRACTION_LAVA_FISSURES) {

                    this.lava[edge.index] = true;
                }
            });
        }

    };
};
},{"../as3/conversion-core":2,"lodash":1}],45:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var centerModule = require('./graph/center');
var convert = require('../as3/conversion-core');
var cornerModule = require('./graph/corner');
var core = require('../janicek/core');
var edgeModule = require('./graph/edge');
var prng = require('../polygonal/pm-prng');
var pc = require('../as3/point-core');
var rectangle = require('../as3/rectangle');
var voronoiModule = require('../nodename/delaunay/voronoi');

exports.DEFAULT_LAKE_THRESHOLD = 0.3;
exports.DEFAULT_LLOYD_ITERATIONS = 2;
exports.DEFAULT_NUMBER_OF_POINTS = 1000;

/**
 * Make a new map.
 * @param   size width and height of map
 * @param   riverChance 0 = no rivers, > 0 = more rivers, default = map area / 4
 */
exports.make = function (size) {
    var pub = {};

    /**
     * Passed in by the caller:
     */
    pub.SIZE = size;

    /**
     * Island shape is controlled by the islandRandom seed and the
     * type of island, passed in when we set the island shape. The
     * islandShape function uses both of them to determine whether any
     * point should be water or land.
     */
    pub.islandShape = null;


    /**
     * Island details are controlled by this random generator. The
     * initial map upon loading is always deterministic, but
     * subsequent maps reset this random number generator with a
     * random seed.
     */
    pub.mapRandom = prng();

    // These store the graph data
    
    /**
     * Only useful during map construction
     */
    pub.points = []; // Vector<Point>
    pub.centers = []; // Vector<Center>
    pub.corners = []; // Vector<Corner>
    pub.edges = []; // Vector<Edge>


    /**
     * Random parameters governing the overall shape of the island
     */
    pub.newIsland = function (islandShape, variant) {
        pub.islandShape = islandShape;
        pub.mapRandom.seed = variant;
    };

    /**
     * Generate the initial random set of points.
     */
    pub.go0PlacePoints = function (numberOfPoints) {
        numberOfPoints = core.def(numberOfPoints, exports.DEFAULT_NUMBER_OF_POINTS);
        pub.reset();
        pub.points = pub.generateRandomPoints(numberOfPoints);
    };

    pub.go1ImprovePoints = function (numLloydIterations) {
        numLloydIterations = core.def(numLloydIterations, exports.DEFAULT_LLOYD_ITERATIONS);
        pub.improveRandomPoints(pub.points, numLloydIterations);
    };

    /**
     * Create a graph structure from the Voronoi edge list. The
     * methods in the Voronoi object are somewhat inconvenient for
     * my needs, so I transform that data into the data I actually
     * need: edges connected to the Delaunay triangles and the
     * Voronoi polygons, a reverse map from those four points back
     * to the edge, a map from these four points to the points
     * they connect to (both along the edge and crosswise).
     */
    pub.go2BuildGraph = function () {
        var voronoi = voronoiModule.make(pub.points, null, rectangle(0, 0, pub.SIZE.width, pub.SIZE.height));
        pub.buildGraph(pub.points, voronoi);
        pub.improveCorners();
        voronoi.dispose();
        voronoi = null;
        pub.points = null;
    };

    /**
     * 
     * @param   lakeThreshold 0 to 1, fraction of water corners for water polygon, default = 0.3
     */
    pub.go3AssignElevations = function (lakeThreshold) {
        lakeThreshold = core.def(lakeThreshold, exports.DEFAULT_LAKE_THRESHOLD);

        // Determine the elevations and water at Voronoi corners.
        pub.assignCornerElevations();

        // Determine polygon and corner type: ocean, coast, land.
        pub.assignOceanCoastAndLand(lakeThreshold);

        // Rescale elevations so that the highest is 1.0, and they're
        // distributed well. We want lower elevations to be more common
        // than higher elevations, in proportions approximately matching
        // concentric rings. That is, the lowest elevation is the
        // largest ring around the island, and therefore should more
        // land area than the highest elevation, which is the very
        // center of a perfectly circular island.
        pub.redistributeElevations(pub.landCorners(pub.corners));

        // Assign elevations to non-land corners
        _(pub.corners).each(function (q) {
            if (q.ocean || q.coast) {
                q.elevation = 0.0;
            }
        });

        // Polygon elevations are the average of their corners
        pub.assignPolygonElevations();
    };

    pub.go4AssignMoisture = function (riverChance) {
        riverChance = core.def(riverChance, null);

        // Determine downslope paths.
        pub.calculateDownslopes();

        // Determine watersheds: for every corner, where does it flow
        // out into the ocean? 
        pub.calculateWatersheds();

        // Create rivers.
        pub.createRivers(riverChance);

        // Determine moisture at corners, starting at rivers
        // and lakes, but not oceans. Then redistribute
        // moisture to cover the entire range evenly from 0.0
        // to 1.0. Then assign polygon moisture as the average
        // of the corner moisture.
        pub.assignCornerMoisture();
        pub.redistributeMoisture(pub.landCorners(pub.corners));
        pub.assignPolygonMoisture();
    };

    pub.go5DecorateMap = function () {
        pub.assignBiomes();
    };

    pub.reset = function () {
        // Break cycles so the garbage collector will release data.
        if (pub.points !== null) {
            pub.points.splice(0, pub.points.length);
        }
        if (pub.edges !== null) {
            _(pub.edges).each(function (edge) {
                edge.d0 = edge.d1 = null;
                edge.v0 = edge.v1 = null;
            });
            pub.edges.splice(0, pub.edges.length);
        }
        if (pub.centers !== null) {
            _(pub.centers).each(function (p) {
                p.neighbors.splice(0, p.neighbors.length);
                p.corners.splice(0, p.corners.length);
                p.borders.splice(0, p.borders.length);
            });
            pub.centers.splice(0, pub.centers.length);
        }
        if (pub.corners !== null) {
            _(pub.corners).each(function (q) {
                q.adjacent.splice(0, q.adjacent.length);
                q.touches.splice(0, q.touches.length);
                q.protrudes.splice(0, q.protrudes.length);
                q.downslope = null;
                q.watershed = null;
            });
            pub.corners.splice(0, pub.corners.length);
        }
        // Clear the previous graph data.
        if (pub.points === null) { pub.points = []; }
        if (pub.edges === null) { pub.edges = []; }
        if (pub.centers === null) { pub.centers = []; }
        if (pub.corners === null) { pub.corners = []; }
      
        // Disabled for JavaScript
        //System.gc();
    };

    /**
     * Generate random points and assign them to be on the island or
     * in the water. Some water points are inland lakes; others are
     * ocean. We'll determine ocean later by looking at what's
     * connected to ocean.
     */
    pub.generateRandomPoints = function (NUM_POINTS) {
        var p, i, points = []; //Vector<Point>
        for (i = 0; i < NUM_POINTS; i++) {
            p = {
                x: pub.mapRandom.nextDoubleRange(10, pub.SIZE.width - 10),
                y: pub.mapRandom.nextDoubleRange(10, pub.SIZE.height - 10)
            };
            points.push(p);
        }
        return points;
    };

    /**
     * Improve the random set of points with Lloyd Relaxation.
     */
    pub.improveRandomPoints = function (points, numLloydIterations) {
      // We'd really like to generate "blue noise". Algorithms:
      // 1. Poisson dart throwing: check each new point against all
      //     existing points, and reject it if it's too close.
      // 2. Start with a hexagonal grid and randomly perturb points.
      // 3. Lloyd Relaxation: move each point to the centroid of the
      //     generated Voronoi polygon, then generate Voronoi again.
      // 4. Use force-based layout algorithms to push points away.
      // 5. More at http://www.cs.virginia.edu/~gfx/pubs/antimony/
      // Option 3 is implemented here. If it's run for too many iterations,
      // it will turn into a grid, but convergence is very slow, and we only
      // run it a few times.

        var i, voronoi, region;
        for (i = 0; i < numLloydIterations; i++) {
            voronoi = voronoiModule.make(points, null, rectangle(0, 0, pub.SIZE.width, pub.SIZE.height));
            for (var pointsIndex = 0; pointsIndex < points.length; pointsIndex++) {
                var p = points[pointsIndex];
                region = voronoi.region(p);
                p.x = 0.0;
                p.y = 0.0;
                for (var regionIndex = 0; regionIndex < region.length; regionIndex++) {
                    var q = region[regionIndex];
                    p.x += q.x;
                    p.y += q.y;
                }
                p.x /= region.length;
                p.y /= region.length;
                region.splice(0, region.length);
            }
            voronoi.dispose();
        }
    };

    /**
     * Although Lloyd relaxation improves the uniformity of polygon
     * sizes, it doesn't help with the edge lengths. Short edges can
     * be bad for some games, and lead to weird artifacts on
     * rivers. We can easily lengthen short edges by moving the
     * corners, but **we lose the Voronoi property**.  The corners are
     * moved to the average of the polygon centers around them. Short
     * edges become longer. Long edges tend to become shorter. The
     * polygons tend to be more uniform after this step.
     */
    pub.improveCorners = function () {
        var newCorners = []; // Vector<Point>
        var point, i;

        // First we compute the average of the centers next to each corner.
        _(pub.corners).each(function (q) {
            if (q.border) {
                newCorners[q.index] = q.point;
            } else {
                point = {x: 0.0, y: 0.0};
                _(q.touches).each(function (r) {
                    point.x += r.point.x;
                    point.y += r.point.y;
                });
                point.x /= q.touches.length;
                point.y /= q.touches.length;
                newCorners[q.index] = point;
            }
        });

        // Move the corners to the new locations.
        for (i = 0; i < pub.corners.length; i++) {
            pub.corners[i].point = newCorners[i];
        }

        // The edge midpoints were computed for the old corners and need
        // to be recomputed.
        _(pub.edges).each(function (edge) {
            if (edge.v0 !== null && edge.v1 !== null) {
                edge.midpoint = pc.interpolate(edge.v0.point, edge.v1.point, 0.5);
            }
        });
    };

    /**
     * Create an array of corners that are on land only, for use by
     * algorithms that work only on land.  We return an array instead
     * of a vector because the redistribution algorithms want to sort
     * this array using Array.sortOn.
     */
    pub.landCorners = function (corners) {
        var locations = [];
        _(corners).each(function (q) {
            if (!q.ocean && !q.coast) {
                locations.push(q);
            }
        });
        return locations;
    };

    /**
     * Build graph data structure in 'edges', 'centers', 'corners',
     * based on information in the Voronoi results: point.neighbors
     * will be a list of neighboring points of the same type (corner
     * or center); point.edges will be a list of edges that include
     * that point. Each edge connects to four points: the Voronoi edge
     * edge.{v0,v1} and its dual Delaunay triangle edge edge.{d0,d1}.
     * For boundary polygons, the Delaunay edge will have one null
     * point, and the Voronoi edge may be null.
     */
    pub.buildGraph = function (points, voronoi) {
        var p;
        var libedges = voronoi.edges();
        var centerLookup = {}; // Dictionary<Center>

        // Build Center objects for each of the points, and a lookup map
        // to find those Center objects again as we build the graph
        _(points).each(function (point) {
            p = centerModule();
            p.index = pub.centers.length;
            p.point = point;
            p.neighbors = [];
            p.borders = [];
            p.corners = [];
            pub.centers.push(p);
            centerLookup[pc.hash(point)] = p;
        });

        // Workaround for Voronoi lib bug: we need to call region()
        // before Edges or neighboringSites are available
        _(pub.centers).each(function (p) {
            voronoi.region(p.point);
        });
      
        // The Voronoi library generates multiple Point objects for
        // corners, and we need to canonicalize to one Corner object.
        // To make lookup fast, we keep an array of Points, bucketed by
        // x value, and then we only have to look at other Points in
        // nearby buckets. When we fail to find one, we'll create a new
        // Corner object.
        var _cornerMap = [];
        function makeCorner(point) {
            var q;
            if (point === null) { return null; }
            var bucket;
            for (bucket = core.toInt(point.x) - 1; bucket < core.toInt(point.x) + 2; bucket++) {
                if (!core.isUndefinedOrNull(_cornerMap[bucket])) {
                    for (var z = 0; z < _cornerMap[bucket].length; z++) {
                        q = _cornerMap[bucket][z];
                        var dx = point.x - q.point.x;
                        var dy = point.y - q.point.y;
                        if (dx * dx + dy * dy < 1e-6) {
                            return q;
                        }
                    }
                }
            }
            bucket = core.toInt(point.x);
            if (core.isUndefinedOrNull(_cornerMap[bucket])) { _cornerMap[bucket] = []; }
            q = cornerModule();
            q.index = pub.corners.length;
            pub.corners.push(q);
            q.point = point;
            q.border = (point.x === 0 || point.x === pub.SIZE.width || point.y === 0 || point.y === pub.SIZE.height);
            q.touches = [];
            q.protrudes = [];
            q.adjacent = [];
            _cornerMap[bucket].push(q);
            return q;
        }

        _(libedges).each(function (libedge) {
            var dedge = libedge.delaunayLine();
            var vedge = libedge.voronoiEdge();

            // Fill the graph data. Make an Edge object corresponding to
            // the edge from the voronoi library.
            var edge = edgeModule();
            edge.index = pub.edges.length;
            edge.river = 0;
            pub.edges.push(edge);
            edge.midpoint = (vedge.p0 !== null && vedge.p1 !== null) ? pc.interpolate(vedge.p0, vedge.p1, 0.5) : null;
          
            // Edges point to corners. Edges point to centers. 
            edge.v0 = makeCorner(vedge.p0);
            edge.v1 = makeCorner(vedge.p1);
            edge.d0 = centerLookup[pc.hash(dedge.p0)];
            edge.d1 = centerLookup[pc.hash(dedge.p1)];

            // Centers point to edges. Corners point to edges.
            if (edge.d0 !== null) { edge.d0.borders.push(edge); }
            if (edge.d1 !== null) { edge.d1.borders.push(edge); }
            if (edge.v0 !== null) { edge.v0.protrudes.push(edge); }
            if (edge.v1 !== null) { edge.v1.protrudes.push(edge); }

            function addToCornerList(v, x) {
                if (x !== null && v.indexOf(x) < 0) { v.push(x); }
            }
            function addToCenterList(v, x) {
                if (x !== null && v.indexOf(x) < 0) { v.push(x); }
            }
          
            // Centers point to centers.
            if (edge.d0 !== null && edge.d1 !== null) {
                addToCenterList(edge.d0.neighbors, edge.d1);
                addToCenterList(edge.d1.neighbors, edge.d0);
            }

            // Corners point to corners
            if (edge.v0 !== null && edge.v1 !== null) {
                addToCornerList(edge.v0.adjacent, edge.v1);
                addToCornerList(edge.v1.adjacent, edge.v0);
            }

            // Centers point to corners
            if (edge.d0 !== null) {
                addToCornerList(edge.d0.corners, edge.v0);
                addToCornerList(edge.d0.corners, edge.v1);
            }
            if (edge.d1 !== null) {
                addToCornerList(edge.d1.corners, edge.v0);
                addToCornerList(edge.d1.corners, edge.v1);
            }

            // Corners point to centers
            if (edge.v0 !== null) {
                addToCenterList(edge.v0.touches, edge.d0);
                addToCenterList(edge.v0.touches, edge.d1);
            }
            if (edge.v1 !== null) {
                addToCenterList(edge.v1.touches, edge.d0);
                addToCenterList(edge.v1.touches, edge.d1);
            }
        });
    };

    /**
     * Determine elevations and water at Voronoi corners. By
     * construction, we have no local minima. This is important for
     * the downslope vectors later, which are used in the river
     * construction algorithm. Also by construction, inlets/bays
     * push low elevation areas inland, which means many rivers end
     * up flowing out through them. Also by construction, lakes
     * often end up on river paths because they don't raise the
     * elevation as much as other terrain does.
     */
    pub.assignCornerElevations = function () {
        var queue = []; // Array<Corner>
      
        _(pub.corners).each(function (q) {
            q.water = !pub.inside(q.point);
        });

        _(pub.corners).each(function (q) {
            // The edges of the map are elevation 0
            if (q.border) {
                q.elevation = 0.0;
                queue.push(q);
            } else {
                q.elevation = Number.POSITIVE_INFINITY;
            }
        });
        // Traverse the graph and assign elevations to each point. As we
        // move away from the map border, increase the elevations. This
        // guarantees that rivers always have a way down to the coast by
        // going downhill (no local minima).
        while (queue.length > 0) {
            var q = queue.shift();
            for (var adjacentIndex = 0; adjacentIndex < q.adjacent.length; adjacentIndex++) {
                var s = q.adjacent[adjacentIndex];

                // Every step up is epsilon over water or 1 over land. The
                // number doesn't matter because we'll rescale the
                // elevations later.
                var newElevation = 0.01 + q.elevation;
                if (!q.water && !s.water) {
                    newElevation += 1;
                }

                // If this point changed, we'll add it to the queue so
                // that we can process its neighbors too.
                if (newElevation < s.elevation) {
                    s.elevation = newElevation;
                    queue.push(s);
                }
            }
        }
    };

    /**
     * Change the overall distribution of elevations so that lower
     * elevations are more common than higher
     * elevations. Specifically, we want elevation X to have frequency
     * (1-X).  To do this we will sort the corners, then set each
     * corner to its desired elevation.
     */
    pub.redistributeElevations = function (locations) {
        // SCALE_FACTOR increases the mountain area. At 1.0 the maximum
        // elevation barely shows up on the map, so we set it to 1.1.
        var SCALE_FACTOR = 1.1;
        var i, y, x;

        //JavaScript port
        //locations.sortOn('elevation', Array.NUMERIC);
        locations.sort(function (c1, c2) {
            if (c1.elevation > c2.elevation) { return 1; }
            if (c1.elevation < c2.elevation) { return -1; }
            if (c1.index > c2.index) { return 1; }
            if (c1.index < c2.index) { return -1; }
            return 0;
        });
      
        for (i = 0; i < locations.length; i++) {
            // Let y(x) be the total area that we want at elevation <= x.
            // We want the higher elevations to occur less than lower
            // ones, and set the area to be y(x) = 1 - (1-x)^2.
            y = i / (locations.length - 1);
            // Now we have to solve for x, given the known y.
            //  *  y = 1 - (1-x)^2
            //  *  y = 1 - (1 - 2x + x^2)
            //  *  y = 2x - x^2
            //  *  x^2 - 2x + y = 0
            // From this we can use the quadratic equation to get:
            x = Math.sqrt(SCALE_FACTOR) - Math.sqrt(SCALE_FACTOR * (1 - y));
            if (x > 1.0) { x = 1.0; }  // TODO: does this break downslopes?
            locations[i].elevation = x;
        }
    };

    /**
     * Change the overall distribution of moisture to be evenly distributed.
     */
    pub.redistributeMoisture = function (locations) {
        var i;
      
        locations.sort(function (c1, c2) {
            if (c1.moisture > c2.moisture) { return 1; }
            if (c1.moisture < c2.moisture) { return -1; }
            if (c1.index > c2.index) { return 1; }
            if (c1.index < c2.index) { return -1; }
            return 0;
        });
      
        for (i = 0; i < locations.length; i++) {
            locations[i].moisture = i / (locations.length - 1);
        }
    };

    /**
     * Determine polygon and corner types: ocean, coast, land.
     */
    pub.assignOceanCoastAndLand = function (lakeThreshold) {
        // Compute polygon attributes 'ocean' and 'water' based on the
        // corner attributes. Count the water corners per
        // polygon. Oceans are all polygons connected to the edge of the
        // map. In the first pass, mark the edges of the map as ocean;
        // in the second pass, mark any water-containing polygon
        // connected an ocean as ocean.
        var queue = []; // Array<Center>
        var p, numWater;
      
        _(pub.centers).each(function (p) {
            numWater = 0;
            _(p.corners).each(function (q) {
                if (q.border) {
                    p.border = true;
                    p.ocean = true;
                    q.water = true;
                    queue.push(p);
                }
                if (q.water) {
                    numWater += 1;
                }
            });
            p.water = (p.ocean || numWater >= p.corners.length * lakeThreshold);
        });
        while (queue.length > 0) {
            p = queue.shift();
            for (var neighbourIndex = 0; neighbourIndex < p.neighbors.length; neighbourIndex++) {
                var r = p.neighbors[neighbourIndex];
                if (r.water && !r.ocean) {
                    r.ocean = true;
                    queue.push(r);
                }
            }
        }
      
        // Set the polygon attribute 'coast' based on its neighbors. If
        // it has at least one ocean and at least one land neighbor,
        // then this is a coastal polygon.
        _(pub.centers).each(function (p) {
            var numOcean = 0;
            var numLand = 0;
            _(p.neighbors).each(function (r) {
                numOcean += convert.intFromBoolean(r.ocean);
                numLand += convert.intFromBoolean(!r.water);
            });
            p.coast = (numOcean > 0) && (numLand > 0);
        });


        // Set the corner attributes based on the computed polygon
        // attributes. If all polygons connected to this corner are
        // ocean, then it's ocean; if all are land, then it's land;
        // otherwise it's coast.
        _(pub.corners).each(function (q) {
            var numOcean = 0;
            var numLand = 0;
            _(q.touches).each(function (p) {
                numOcean += convert.intFromBoolean(p.ocean);
                numLand += convert.intFromBoolean(!p.water);
            });
            q.ocean = (numOcean === q.touches.length);
            q.coast = (numOcean > 0) && (numLand > 0);
            q.water = q.border || ((numLand !== q.touches.length) && !q.coast);
        });
    };

    /**
     * Polygon elevations are the average of the elevations of their corners.
     */
    pub.assignPolygonElevations = function () {
        var sumElevation;
        _(pub.centers).each(function (p) {
            sumElevation = 0.0;
            _(p.corners).each(function (q) {
                sumElevation += q.elevation;
            });
            p.elevation = sumElevation / p.corners.length;
        });
    };

    /**
     * Calculate downslope pointers.  At every point, we point to the
     * point downstream from it, or to itself.  This is used for
     * generating rivers and watersheds.
     */
    pub.calculateDownslopes = function () {
        var r;
      
        _(pub.corners).each(function (q) {
            r = q;
            _(q.adjacent).each(function (s) {
                if (s.elevation <= r.elevation) {
                    r = s;
                }
            });
            q.downslope = r;
        });
    };

    /**
     * Calculate the watershed of every land point. The watershed is
     * the last downstream land point in the downslope graph. TODO:
     * watersheds are currently calculated on corners, but it'd be
     * more useful to compute them on polygon centers so that every
     * polygon can be marked as being in one watershed.
     */
    pub.calculateWatersheds = function () {
        var r, i, changed;
      
        // Initially the watershed pointer points downslope one step.      
        _(pub.corners).each(function (q) {
            q.watershed = q;
            if (!q.ocean && !q.coast) {
                q.watershed = q.downslope;
            }
        });
        // Follow the downslope pointers to the coast. Limit to 100
        // iterations although most of the time with NUM_POINTS=2000 it
        // only takes 20 iterations because most points are not far from
        // a coast.  TODO: can run faster by looking at
        // p.watershed.watershed instead of p.downslope.watershed.
        var cornerIndex, q;
        for (i = 0; i < 100; i++) {
            changed = false;
            for (cornerIndex = 0; cornerIndex < pub.corners.length; cornerIndex++) {
                q = pub.corners[cornerIndex];
                if (!q.ocean && !q.coast && !q.watershed.coast) {
                    r = q.downslope.watershed;
                    if (!r.ocean) { q.watershed = r; }
                    changed = true;
                }
            }
            if (!changed) { break; }
        }
        // How big is each watershed?
        for (cornerIndex = 0; cornerIndex < pub.corners.length; cornerIndex++) {
            q = pub.corners[cornerIndex];
            r = q.watershed;
            r.watershedSize = 1 + (r.watershedSize || 0);
        }
    };

    /**
     * Create rivers along edges. Pick a random corner point,
     * then move downslope. Mark the edges and corners as rivers.
     * @param   riverChance Higher = more rivers.
     */
    pub.createRivers = function (riverChance) {
        riverChance = core.coalesce(riverChance, core.toInt((pub.SIZE.width + pub.SIZE.height) / 4));

        var i, q, edge;
      
        for (i = 0; i < riverChance; i++) {
            q = pub.corners[pub.mapRandom.nextIntRange(0, pub.corners.length - 1)];
            if (q.ocean || q.elevation < 0.3 || q.elevation > 0.9) { continue; }
            // Bias rivers to go west: if (q.downslope.x > q.x) continue;
            while (!q.coast) {
                if (q === q.downslope) {
                    break;
                }
                edge = pub.lookupEdgeFromCorner(q, q.downslope);
                edge.river = edge.river + 1;
                q.river = (q.river || 0) + 1;
                q.downslope.river = (q.downslope.river || 0) + 1;  // TODO: fix double count
                q = q.downslope;
            }
        }
    };

    /**
     * Calculate moisture. Freshwater sources spread moisture: rivers
     * and lakes (not oceans). Saltwater sources have moisture but do
     * not spread it (we set it at the end, after propagation).
     */
    pub.assignCornerMoisture = function () {
        var q, newMoisture;
        var queue = []; // Array<Corner>
        // Fresh water
        _(pub.corners).each(function (q) {
            if ((q.water || q.river > 0) && !q.ocean) {
                q.moisture = q.river > 0 ? Math.min(3.0, (0.2 * q.river)) : 1.0;
                queue.push(q);
            } else {
                q.moisture = 0.0;
            }
        });
        while (queue.length > 0) {
            q = queue.shift();

            for (var adjacentIndex = 0; adjacentIndex < q.adjacent.length; adjacentIndex++) {
                var r = q.adjacent[adjacentIndex];
                newMoisture = q.moisture * 0.9;
                if (newMoisture > r.moisture) {
                    r.moisture = newMoisture;
                    queue.push(r);
                }
            }
        }
        // Salt water
        _(pub.corners).each(function (q) {
            if (q.ocean || q.coast) {
                q.moisture = 1.0;
            }
        });
    };

    /**
     * Polygon moisture is the average of the moisture at corners
     */
    pub.assignPolygonMoisture = function () {
        var sumMoisture;
        _(pub.centers).each(function (p) {
            sumMoisture = 0.0;
            _(p.corners).each(function (q) {
                if (q.moisture > 1.0) { q.moisture = 1.0; }
                sumMoisture += q.moisture;
            });
            p.moisture = sumMoisture / p.corners.length;
        });
    };

    pub.assignBiomes = function () {
        _(pub.centers).each(function (p) {
            p.biome = exports.getBiome(p);
        });
    };

    /**
     * Look up a Voronoi Edge object given two adjacent Voronoi
     * polygons, or two adjacent Voronoi corners
     */
    pub.lookupEdgeFromCenter = function (p, r) {
        for (var i = 0; i < p.borders.length; i++) {
            var edge = p.borders[i];
            if (edge.d0 === r || edge.d1 === r) { return edge; }
        }
        return null;
    };

    pub.lookupEdgeFromCorner = function (q, s) {
        for (var i = 0; i < q.protrudes.length; i++) {
            var edge = q.protrudes[i];
            if (edge.v0 === s || edge.v1 === s) { return edge; }
        }
        return null;
    };

    /**
     * Determine whether a given point should be on the island or in the water.
     */
    pub.inside = function (p) {
        return pub.islandShape({ x: 2 * (p.x / pub.SIZE.width - 0.5), y: 2 * (p.y / pub.SIZE.height - 0.5) });
    };

    pub.reset();

    return pub;
};

/**
 * Assign a biome type to each polygon. If it has
 * ocean/coast/water, then that's the biome; otherwise it depends
 * on low/high elevation and low/medium/high moisture. This is
 * roughly based on the Whittaker diagram but adapted to fit the
 * needs of the island map generator.
 */
exports.getBiome = function (p) {
    if (p.ocean) {
        return 'OCEAN';
    } else if (p.water) {
        if (p.elevation < 0.1) { return 'MARSH'; }
        if (p.elevation > 0.8) { return 'ICE'; }
        return 'LAKE';
    } else if (p.coast) {
        return 'BEACH';
    } else if (p.elevation > 0.8) {
        if (p.moisture > 0.50) { return 'SNOW'; }
        else if (p.moisture > 0.33) { return 'TUNDRA'; }
        else if (p.moisture > 0.16) { return 'BARE'; }
        else { return 'SCORCHED'; }
    } else if (p.elevation > 0.6) {
        if (p.moisture > 0.66) { return 'TAIGA'; }
        else if (p.moisture > 0.33) { return 'SHRUBLAND'; }
        else { return 'TEMPERATE_DESERT'; }
    } else if (p.elevation > 0.3) {
        if (p.moisture > 0.83) { return 'TEMPERATE_RAIN_FOREST'; }
        else if (p.moisture > 0.50) { return 'TEMPERATE_DECIDUOUS_FOREST'; }
        else if (p.moisture > 0.16) { return 'GRASSLAND'; }
        else { return 'TEMPERATE_DESERT'; }
    } else {
        if (p.moisture > 0.66) { return 'TROPICAL_RAIN_FOREST'; }
        else if (p.moisture > 0.33) { return 'TROPICAL_SEASONAL_FOREST'; }
        else if (p.moisture > 0.16) { return 'GRASSLAND'; }
        else { return 'SUBTROPICAL_DESERT'; }
    }
};


// ------------------------------------------------------------------------
// Richard Janicek's Extensions

exports.countLands = function (centers) {
    return _(_(centers).filter(function (c) { return !c.water; })).size();
};

/**
 * Rebuilds the map varying the number of points until desired number of land centers are generated or timeout is reached.
 * Not an efficient algorithim, but gets the job done.
 */
exports.tryMutateMapPointsToGetNumberLands = function (map, numberOfLands, timeoutMilliseconds, initialNumberOfPoints, numLloydIterations, lakeThreshold) {
    timeoutMilliseconds = core.def(timeoutMilliseconds, 10 * 1000);
    initialNumberOfPoints = core.def(initialNumberOfPoints, exports.DEFAULT_NUMBER_OF_POINTS);
    numLloydIterations = core.def(numLloydIterations, exports.DEFAULT_LLOYD_ITERATIONS);
    lakeThreshold = core.def(lakeThreshold, exports.DEFAULT_LAKE_THRESHOLD);

    var pointCount = initialNumberOfPoints;
    var startTime = Date.now();
    var targetLandCountFound = false;
    do {
        map.go0PlacePoints(pointCount);
        map.go1ImprovePoints(numLloydIterations);
        map.go2BuildGraph();
        map.go3AssignElevations(lakeThreshold);
        var lands = exports.countLands(map.centers);
        if (lands === numberOfLands) {
            targetLandCountFound = true;
        }
        else {
            pointCount += (lands < numberOfLands ? 1 : -1);
        }
    } while (!targetLandCountFound && Date.now() - startTime < timeoutMilliseconds);
    
    return map;
};
},{"../as3/conversion-core":2,"../as3/point-core":4,"../as3/rectangle":5,"../janicek/core":10,"../nodename/delaunay/voronoi":33,"../polygonal/pm-prng":38,"./graph/center":40,"./graph/corner":41,"./graph/edge":42,"lodash":1}],46:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var convert = require('../as3/conversion-core');
var core = require('../janicek/core');
var pc = require('../as3/point-core');
var prng = require('../janicek/pseudo-random-number-generators');

exports.make = function () {
    var pub = {};

    pub.path0 = []; // Array<Vector<Point>> // edge index -> Vector.<Point>
    pub.path1 = []; // Array<Vector<Point>> // edge index -> Vector.<Point>

    /**
     * Build noisy line paths for each of the Voronoi edges. There are
     * two noisy line paths for each edge, each covering half the
     * distance: path0 is from v0 to the midpoint and path1 is from v1
     * to the midpoint. When drawing the polygons, one or the other
     * must be drawn in reverse order.
     * @param noisyLineTradeoff low: jagged vedge; high: jagged dedge (default = 0.5)
     */
    pub.buildNoisyEdges = function (map, lava, seed, noisyLineTradeoff) {
        noisyLineTradeoff = core.def(noisyLineTradeoff, 0.5);
        var gen = prng.randomGenerator(seed, prng.nextParkMiller);
        _(map.centers).each(function (p) {
            _(p.borders).each(function (edge) {
                if (!core.isUndefinedOrNull(edge.d0) && !core.isUndefinedOrNull(edge.d1) && !core.isUndefinedOrNull(edge.v0) && !core.isUndefinedOrNull(edge.v1) && core.isUndefinedOrNull(pub.path0[edge.index])) {
                    var f = noisyLineTradeoff;
                    var t = pc.interpolate(edge.v0.point, edge.d0.point, f);
                    var q = pc.interpolate(edge.v0.point, edge.d1.point, f);
                    var r = pc.interpolate(edge.v1.point, edge.d0.point, f);
                    var s = pc.interpolate(edge.v1.point, edge.d1.point, f);

                    var minLength = 10;
                    if (edge.d0.biome !== edge.d1.biome) { minLength = 3; }
                    if (edge.d0.ocean && edge.d1.ocean) { minLength = 100; }
                    if (edge.d0.coast || edge.d1.coast)  { minLength = 1; }
                    if (convert.booleanFromInt(edge.river) || !core.isUndefinedOrNull(lava.lava[edge.index])) { minLength = 1; }
                    pub.path0[edge.index] = exports.buildNoisyLineSegments(gen(), edge.v0.point, t, edge.midpoint, q, minLength);
                    pub.path1[edge.index] = exports.buildNoisyLineSegments(gen(), edge.v1.point, s, edge.midpoint, r, minLength);
                }
            });
        });
    };

    return pub;
};

// Helper function: build a single noisy line in a quadrilateral A-B-C-D,
// and store the output points in a Vector.
exports.buildNoisyLineSegments = function (seed, A, B, C, D, minLength) {
    var gen = prng.randomGenerator(seed, prng.nextParkMiller);
    var points = []; // Vector<Point>
    
    // var limit = 10;
  
    function subdivide(A, B, C, D) {
        if (pc.distanceFromOrigin(pc.subtract(A, C)) < minLength || pc.distanceFromOrigin(pc.subtract(B, D)) < minLength) {
            return;
        }

        // Subdivide the quadrilateral
        var p = prng.toFloatRange(gen(), 0.2, 0.8); // vertical (along A-D and B-C)
        var q = prng.toFloatRange(gen(), 0.2, 0.8); // horizontal (along A-B and D-C)

        // Midpoints
        var E = pc.interpolate(A, D, p);
        
        var F = pc.interpolate(B, C, p);
        var G = pc.interpolate(A, B, q);
        var I = pc.interpolate(D, C, q);
        
        // Central point
        var H = pc.interpolate(E, F, q);
        
        // Divide the quad into subquads, but meet at H
        var s = 1.0 - prng.toFloatRange(gen(), -0.4, 0.4); //random.nextDoubleRange(-0.4, 0.4);
        var t = 1.0 - prng.toFloatRange(gen(), -0.4, 0.4); //random.nextDoubleRange(-0.4, 0.4);
        
        //if(limit-- > 0) {trace([p, q, s, t]);}
        
        subdivide(A, pc.interpolate(G, B, s), H, pc.interpolate(E, D, t));
        points.push(H);
        subdivide(H, pc.interpolate(F, C, s), C, pc.interpolate(I, D, t));
    }

    points.push(A);
    subdivide(A, B, C, D);
    points.push(C);
    return points;
};
},{"../as3/conversion-core":2,"../as3/point-core":4,"../janicek/core":10,"../janicek/pseudo-random-number-generators":16,"lodash":1}],47:[function(require,module,exports){
'use strict';

var _ = require('lodash');
var core = require('../janicek/core');

module.exports = function () {
    var pub = {};

    // The road array marks the edges that are roads.  The mark is 1,
    // 2, or 3, corresponding to the three contour levels. Note that
    // these are sparse arrays, only filled in where there are roads.
    pub.road = []; // Array<Int> // edge index -> int contour level
    pub.roadConnections = []; // Array<Array<Edge>>  // center index -> array of Edges with roads

    // We want to mark different elevation zones so that we can draw
    // island-circling roads that divide the areas.
    pub.createRoads = function (map, elevationThresholds) {
        // Oceans and coastal polygons are the lowest contour zone
        // (1). Anything connected to contour level K, if it's below
        // elevation threshold K, or if it's water, gets contour level
        // K.  (2) Anything not assigned a contour level, and connected
        // to contour level K, gets contour level K+1.
        var queue = []; // Array<Center>
        var p, newLevel;
        //var elevationThresholds = [0, 0.05, 0.37, 0.64];
        var cornerContour = []; // Array<Int> // corner index -> int contour level
        var centerContour = []; //:Array<Int> // center index -> int contour level
    
        _(map.centers).each(function (p) {
            if (p.coast || p.ocean) {
                centerContour[p.index] = 1;
                queue.push(p);
            }
        });
      
        while (queue.length > 0) {
            p = queue.shift();
            for (var neighborIndex = 0; neighborIndex < p.neighbors.length; neighborIndex++) {
                var r = p.neighbors[neighborIndex];
                newLevel = core.coalesce(centerContour[p.index], 0);
                while (r.elevation > elevationThresholds[newLevel] && !r.water) {
                    // NOTE: extend the contour line past bodies of
                    // water so that roads don't terminate inside lakes.
                    newLevel += 1;
                }
                if (newLevel < core.coalesce(centerContour[r.index], 999)) {
                    centerContour[r.index] = newLevel;
                    queue.push(r);
                }
            }
        }

        // A corner's contour level is the MIN of its polygons
        _(map.centers).each(function (p) {
            _(p.corners).each(function (q) {
                cornerContour[q.index] = core.toInt(Math.min(core.coalesce(cornerContour[q.index], 999), core.coalesce(centerContour[p.index], 999)));
            });
        });

        // Roads go between polygons that have different contour levels
        _(map.centers).each(function (p) {
            _(p.borders).each(function (edge) {
                if (!_.isNull(edge.v0) && !_.isNull(edge.v1) && cornerContour[edge.v0.index] !== cornerContour[edge.v1.index]) {
                    pub.road[edge.index] = core.toInt(Math.min(cornerContour[edge.v0.index], cornerContour[edge.v1.index]));
                    if (core.isUndefinedOrNull(pub.roadConnections[p.index])) {
                        pub.roadConnections[p.index] = [];
                    }
                    pub.roadConnections[p.index].push(edge);
                }
            });
        });
    };

    return pub;
};
},{"../janicek/core":10,"lodash":1}],48:[function(require,module,exports){
'use strict';

exports.displayColors = {
    // Features
    OCEAN: 0x44447a,
    COAST: 0x33335a,
    LAKESHORE: 0x225588,
    LAKE: 0x336699,
    RIVER: 0x225588,
    MARSH: 0x2f6666,
    ICE: 0x99ffff,
    BEACH: 0xa09077,
    ROAD1: 0x442211,
    ROAD2: 0x553322,
    ROAD3: 0x664433,
    BRIDGE: 0x686860,
    LAVA: 0xcc3333,

    // Terrain
    SNOW: 0xffffff,
    TUNDRA: 0xbbbbaa,
    BARE: 0x888888,
    SCORCHED: 0x555555,
    TAIGA: 0x99aa77,
    SHRUBLAND: 0x889977,
    TEMPERATE_DESERT: 0xc9d29b,
    TEMPERATE_RAIN_FOREST: 0x448855,
    TEMPERATE_DECIDUOUS_FOREST: 0x679459,
    GRASSLAND: 0x88aa55,
    SUBTROPICAL_DESERT: 0xd2b98b,
    TROPICAL_RAIN_FOREST: 0x337755,
    TROPICAL_SEASONAL_FOREST: 0x559944
};

exports.elevationGradientColors = {
    OCEAN: 0x008800,
    GRADIENT_LOW: 0x008800,
    GRADIENT_HIGH: 0xffff00
};
},{}],49:[function(require,module,exports){
'use strict';

var _ = require('lodash');

module.exports = function () {
    var pub = {};
    pub.lowestCorner = [];   // Array<Int> // polygon index -> corner index
    pub.watersheds = [];     //Array<Int>;  // polygon index -> corner index

    // We want to mark each polygon with the corner where water would
    // exit the island.
    pub.createWatersheds = function (map) {
        var s;

        // Find the lowest corner of the polygon, and set that as the
        // exit point for rain falling on this polygon
        _(map.centers).each(function (p) {
            s = null;
            _(p.corners).each(function (q) {
                if (s === null || q.elevation < s.elevation) {
                    s = q;
                }
            });
            pub.lowestCorner[p.index] = (s === null) ? -1 : s.index;
            pub.watersheds[p.index] = (s === null) ? -1 : (s.watershed === null) ? -1 : s.watershed.index;
        });
    };

    return pub;
};
},{"lodash":1}]},{},[7])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxub2RlX21vZHVsZXNcXGxvZGFzaFxcZGlzdFxcbG9kYXNoLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxhczNcXGNvbnZlcnNpb24tY29yZS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcYXMzXFxtYXRyaXguanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXGFzM1xccG9pbnQtY29yZS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcYXMzXFxyZWN0YW5nbGUuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXGFzM1xcdmVjdG9yLTNkLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxpbmRleC5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcamFuaWNla1xcYXJyYXkyZC5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcamFuaWNla1xcY2FudmFzLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxqYW5pY2VrXFxjb3JlLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxqYW5pY2VrXFxoYXNoLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxqYW5pY2VrXFxodG1sLWNvbG9yLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxqYW5pY2VrXFxsb2cuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXGphbmljZWtcXG1hdGguanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXGphbmljZWtcXHBlcmxpbi1ub2lzZS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcamFuaWNla1xccHNldWRvLXJhbmRvbS1udW1iZXItZ2VuZXJhdG9ycy5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcamFuaWNla1xcc3RyaW5nLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxqYW5pY2VrXFx0aW1lci5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGRlbGF1bmF5XFxib3VuZHMtY2hlY2suanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXG5vZGVuYW1lXFxkZWxhdW5heVxcY3JpdGVyaW9uLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxub2RlbmFtZVxcZGVsYXVuYXlcXGRlbGF1bmF5LmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxub2RlbmFtZVxcZGVsYXVuYXlcXGVkZ2UtbGlzdC5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGRlbGF1bmF5XFxlZGdlLXJlb3JkZXJlci5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGRlbGF1bmF5XFxlZGdlLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxub2RlbmFtZVxcZGVsYXVuYXlcXGhhbGZlZGdlLXByaW9yaXR5LXF1ZXVlLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxub2RlbmFtZVxcZGVsYXVuYXlcXGhhbGZlZGdlLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxub2RlbmFtZVxcZGVsYXVuYXlcXGtydXNrYWwuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXG5vZGVuYW1lXFxkZWxhdW5heVxcbHIuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXG5vZGVuYW1lXFxkZWxhdW5heVxcbm9kZS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGRlbGF1bmF5XFxzaXRlLWxpc3QuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXG5vZGVuYW1lXFxkZWxhdW5heVxcc2l0ZS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGRlbGF1bmF5XFx2ZXJ0ZXguanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXG5vZGVuYW1lXFxkZWxhdW5heVxcdm9yb25vaS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGdlb21cXGNpcmNsZS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGdlb21cXGxpbmUtc2VnbWVudC5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcbm9kZW5hbWVcXGdlb21cXHBvbHlnb24uanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXG5vZGVuYW1lXFxnZW9tXFx3aW5kaW5nLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFxwb2x5Z29uYWxcXHBtLXBybmcuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXHZvcm9ub2ltYXBcXGNhbnZhcy1yZW5kZXIuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXHZvcm9ub2ltYXBcXGdyYXBoXFxjZW50ZXIuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXHZvcm9ub2ltYXBcXGdyYXBoXFxjb3JuZXIuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXHZvcm9ub2ltYXBcXGdyYXBoXFxlZGdlLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFx2b3Jvbm9pbWFwXFxpc2xhbmQtc2hhcGUuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXHZvcm9ub2ltYXBcXGxhdmEuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXHZvcm9ub2ltYXBcXG1hcC5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcdm9yb25vaW1hcFxcbm9pc3ktZWRnZXMuanMiLCJEOlxcZGF0YVxccHJvamVjdHNcXHZvcm9ub2ktbWFwLWpzXFxzcmNcXHZvcm9ub2ltYXBcXHJvYWRzLmpzIiwiRDpcXGRhdGFcXHByb2plY3RzXFx2b3Jvbm9pLW1hcC1qc1xcc3JjXFx2b3Jvbm9pbWFwXFxzdHlsZS5qcyIsIkQ6XFxkYXRhXFxwcm9qZWN0c1xcdm9yb25vaS1tYXAtanNcXHNyY1xcdm9yb25vaW1hcFxcd2F0ZXJzaGVkcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ243S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbD1zZWxmOy8qKlxuICogQGxpY2Vuc2VcbiAqIExvLURhc2ggMS4zLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHA6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiAtbyAuL2Rpc3QvbG9kYXNoLmpzYFxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS40LjQgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLz5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cDovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuOyhmdW5jdGlvbih3aW5kb3cpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUgRVM1IGVudmlyb25tZW50cyAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIHRvIHBvb2wgYXJyYXlzIGFuZCBvYmplY3RzIHVzZWQgaW50ZXJuYWxseSAqL1xuICB2YXIgYXJyYXlQb29sID0gW10sXG4gICAgICBvYmplY3RQb29sID0gW107XG5cbiAgLyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuICB2YXIgaWRDb3VudGVyID0gMDtcblxuICAvKiogVXNlZCBpbnRlcm5hbGx5IHRvIGluZGljYXRlIHZhcmlvdXMgdGhpbmdzICovXG4gIHZhciBpbmRpY2F0b3JPYmplY3QgPSB7fTtcblxuICAvKiogVXNlZCB0byBwcmVmaXgga2V5cyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBgX19wcm90b19fYCBhbmQgcHJvcGVydGllcyBvbiBgT2JqZWN0LnByb3RvdHlwZWAgKi9cbiAgdmFyIGtleVByZWZpeCA9ICtuZXcgRGF0ZSArICcnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHdoZW4gb3B0aW1pemF0aW9ucyBhcmUgZW5hYmxlZCBmb3IgbGFyZ2UgYXJyYXlzICovXG4gIHZhciBsYXJnZUFycmF5U2l6ZSA9IDc1O1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXggc2l6ZSBvZiB0aGUgYGFycmF5UG9vbGAgYW5kIGBvYmplY3RQb29sYCAqL1xuICB2YXIgbWF4UG9vbFNpemUgPSA0MDtcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUzYgdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy03LjguNlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCByZWdleHAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMgKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFwiaW50ZXJwb2xhdGVcIiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzICovXG4gIHZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGZ1bmN0aW9ucyBjb250YWluaW5nIGEgYHRoaXNgIHJlZmVyZW5jZSAqL1xuICB2YXIgcmVUaGlzID0gKHJlVGhpcyA9IC9cXGJ0aGlzXFxiLykgJiYgcmVUaGlzLnRlc3QocnVuSW5Db250ZXh0KSAmJiByZVRoaXM7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGFuZCB0ZXN0IHdoaXRlc3BhY2UgKi9cbiAgdmFyIHdoaXRlc3BhY2UgPSAoXG4gICAgLy8gd2hpdGVzcGFjZVxuICAgICcgXFx0XFx4MEJcXGZcXHhBMFxcdWZlZmYnICtcblxuICAgIC8vIGxpbmUgdGVybWluYXRvcnNcbiAgICAnXFxuXFxyXFx1MjAyOFxcdTIwMjknICtcblxuICAgIC8vIHVuaWNvZGUgY2F0ZWdvcnkgXCJac1wiIHNwYWNlIHNlcGFyYXRvcnNcbiAgICAnXFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMCdcbiAgKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UgYW5kIHplcm9zIHRvIGJlIHJlbW92ZWQgKi9cbiAgdmFyIHJlTGVhZGluZ1NwYWNlc0FuZFplcm9zID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlICsgJ10qMCsoPz0uJCknKTtcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGNoYXJhY3RlcnMgKi9cbiAgdmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHRcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdGdW5jdGlvbicsICdNYXRoJywgJ051bWJlcicsICdPYmplY3QnLFxuICAgICdSZWdFeHAnLCAnU3RyaW5nJywgJ18nLCAnYXR0YWNoRXZlbnQnLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ2lzTmFOJyxcbiAgICAncGFyc2VJbnQnLCAnc2V0SW1tZWRpYXRlJywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeSAqL1xuICB2YXIgdGVtcGxhdGVDb3VudGVyID0gMDtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHNob3J0Y3V0cyAqL1xuICB2YXIgYXJnc0NsYXNzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheUNsYXNzID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGJvb2xDbGFzcyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICAgIGRhdGVDbGFzcyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGVycm9yQ2xhc3MgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgb2JqZWN0IGNsYXNzaWZpY2F0aW9ucyB0aGF0IGBfLmNsb25lYCBzdXBwb3J0cyAqL1xuICB2YXIgY2xvbmVhYmxlQ2xhc3NlcyA9IHt9O1xuICBjbG9uZWFibGVDbGFzc2VzW2Z1bmNDbGFzc10gPSBmYWxzZTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1thcnJheUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbYm9vbENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbZGF0ZUNsYXNzXSA9XG4gIGNsb25lYWJsZUNsYXNzZXNbbnVtYmVyQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tvYmplY3RDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3JlZ2V4cENsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbc3RyaW5nQ2xhc3NdID0gdHJ1ZTtcblxuICAvKiogVXNlZCB0byBkZXRlcm1pbmUgaWYgdmFsdWVzIGFyZSBvZiB0aGUgbGFuZ3VhZ2UgdHlwZSBPYmplY3QgKi9cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzICovXG4gIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgIFwiJ1wiOiBcIidcIixcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcdCc6ICd0JyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYCAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAgKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLCBhbmQgdXNlIGl0IGFzIGB3aW5kb3dgICovXG4gIHZhciBmcmVlR2xvYmFsID0gb2JqZWN0VHlwZXNbdHlwZW9mIGdsb2JhbF0gJiYgZ2xvYmFsO1xuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgd2luZG93ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYmluYXJ5IHNlYXJjaGVzXG4gICAqIG9yIGBmcm9tSW5kZXhgIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSBvciBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzaWNJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gKGZyb21JbmRleCB8fCAwKSAtIDEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb250YWluc2AgZm9yIGNhY2hlIG9iamVjdHMgdGhhdCBtaW1pY3MgdGhlIHJldHVyblxuICAgKiBzaWduYXR1cmUgb2YgYF8uaW5kZXhPZmAgYnkgcmV0dXJuaW5nIGAwYCBpZiB0aGUgdmFsdWUgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgYDBgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBjYWNoZSA9IGNhY2hlLmNhY2hlO1xuXG4gICAgaWYgKHR5cGUgPT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZVt2YWx1ZV07XG4gICAgfVxuICAgIGlmICh0eXBlICE9ICdudW1iZXInICYmIHR5cGUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG4gICAgdmFyIGtleSA9IHR5cGUgPT0gJ251bWJlcicgPyB2YWx1ZSA6IGtleVByZWZpeCArIHZhbHVlO1xuICAgIGNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgcmV0dXJuIHR5cGUgPT0gJ29iamVjdCdcbiAgICAgID8gKGNhY2hlW2tleV0gJiYgYmFzaWNJbmRleE9mKGNhY2hlW2tleV0sIHZhbHVlKSA+IC0xID8gMCA6IC0xKVxuICAgICAgOiAoY2FjaGVba2V5XSA/IDAgOiAtMSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGdpdmVuIGB2YWx1ZWAgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlUHVzaCh2YWx1ZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXG4gICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PSAnYm9vbGVhbicgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgY2FjaGVbdmFsdWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT0gJ251bWJlcicgJiYgdHlwZSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gJ29iamVjdCc7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdHlwZSA9PSAnbnVtYmVyJyA/IHZhbHVlIDoga2V5UHJlZml4ICsgdmFsdWUsXG4gICAgICAgICAgdHlwZUNhY2hlID0gY2FjaGVbdHlwZV0gfHwgKGNhY2hlW3R5cGVdID0ge30pO1xuXG4gICAgICBpZiAodHlwZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoKHR5cGVDYWNoZVtrZXldIHx8ICh0eXBlQ2FjaGVba2V5XSA9IFtdKSkucHVzaCh2YWx1ZSkgPT0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBjYWNoZVt0eXBlXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlQ2FjaGVba2V5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBgY2FsbGJhY2tgIHdoZW4gYSBnaXZlblxuICAgKiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2hhcmFjdGVyIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiBnaXZlbiBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyQXRDYWxsYmFjayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHNvcnRCeWAgdG8gY29tcGFyZSB0cmFuc2Zvcm1lZCBgY29sbGVjdGlvbmAgdmFsdWVzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWkgPSBhLmluZGV4LFxuICAgICAgICBiaSA9IGIuaW5kZXg7XG5cbiAgICBhID0gYS5jcml0ZXJpYTtcbiAgICBiID0gYi5jcml0ZXJpYTtcblxuICAgIC8vIGVuc3VyZSBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzXG4gICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTBcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgPiBiIHx8IHR5cGVvZiBhID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKGEgPCBiIHx8IHR5cGVvZiBiID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFpIDwgYmkgPyAtMSA6IDE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhY2hlIG9iamVjdCB0byBvcHRpbWl6ZSBsaW5lYXIgc2VhcmNoZXMgb2YgbGFyZ2UgYXJyYXlzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEByZXR1cm5zIHtOdWxsfE9iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgb2JqZWN0IG9yIGBudWxsYCBpZiBjYWNoaW5nIHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHZhciBjYWNoZSA9IGdldE9iamVjdCgpO1xuICAgIGNhY2hlWydmYWxzZSddID0gY2FjaGVbJ251bGwnXSA9IGNhY2hlWyd0cnVlJ10gPSBjYWNoZVsndW5kZWZpbmVkJ10gPSBmYWxzZTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRPYmplY3QoKTtcbiAgICByZXN1bHQuYXJyYXkgPSBhcnJheTtcbiAgICByZXN1bHQuY2FjaGUgPSBjYWNoZTtcbiAgICByZXN1bHQucHVzaCA9IGNhY2hlUHVzaDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChhcnJheVtpbmRleF0pO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUub2JqZWN0ID09PSBmYWxzZVxuICAgICAgPyAocmVsZWFzZU9iamVjdChyZXN1bHQpLCBudWxsKVxuICAgICAgOiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWRcbiAgICogc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXJyYXkgZnJvbSB0aGUgYXJyYXkgcG9vbCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiB0aGUgcG9vbCBpcyBlbXB0eS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldEFycmF5KCkge1xuICAgIHJldHVybiBhcnJheVBvb2wucG9wKCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3QgZnJvbSB0aGUgb2JqZWN0IHBvb2wgb3IgY3JlYXRlcyBhIG5ldyBvbmUgaWYgdGhlIHBvb2wgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3QgZnJvbSB0aGUgcG9vbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE9iamVjdCgpIHtcbiAgICByZXR1cm4gb2JqZWN0UG9vbC5wb3AoKSB8fCB7XG4gICAgICAnYXJyYXknOiBudWxsLFxuICAgICAgJ2NhY2hlJzogbnVsbCxcbiAgICAgICdjcml0ZXJpYSc6IG51bGwsXG4gICAgICAnZmFsc2UnOiBmYWxzZSxcbiAgICAgICdpbmRleCc6IDAsXG4gICAgICAnbGVhZGluZyc6IGZhbHNlLFxuICAgICAgJ21heFdhaXQnOiAwLFxuICAgICAgJ251bGwnOiBmYWxzZSxcbiAgICAgICdudW1iZXInOiBudWxsLFxuICAgICAgJ29iamVjdCc6IG51bGwsXG4gICAgICAncHVzaCc6IG51bGwsXG4gICAgICAnc3RyaW5nJzogbnVsbCxcbiAgICAgICd0cmFpbGluZyc6IGZhbHNlLFxuICAgICAgJ3RydWUnOiBmYWxzZSxcbiAgICAgICd1bmRlZmluZWQnOiBmYWxzZSxcbiAgICAgICd2YWx1ZSc6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgdGhlIGdpdmVuIGBhcnJheWAgYmFjayB0byB0aGUgYXJyYXkgcG9vbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gcmVsZWFzZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbGVhc2VBcnJheShhcnJheSkge1xuICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgaWYgKGFycmF5UG9vbC5sZW5ndGggPCBtYXhQb29sU2l6ZSkge1xuICAgICAgYXJyYXlQb29sLnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgZ2l2ZW4gYG9iamVjdGAgYmFjayB0byB0aGUgb2JqZWN0IHBvb2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHJlbGVhc2UuXG4gICAqL1xuICBmdW5jdGlvbiByZWxlYXNlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBjYWNoZSA9IG9iamVjdC5jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgIH1cbiAgICBvYmplY3QuYXJyYXkgPSBvYmplY3QuY2FjaGUgPSBvYmplY3QuY3JpdGVyaWEgPSBvYmplY3Qub2JqZWN0ID0gb2JqZWN0Lm51bWJlciA9IG9iamVjdC5zdHJpbmcgPSBvYmplY3QudmFsdWUgPSBudWxsO1xuICAgIGlmIChvYmplY3RQb29sLmxlbmd0aCA8IG1heFBvb2xTaXplKSB7XG4gICAgICBvYmplY3RQb29sLnB1c2gob2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2xpY2VzIHRoZSBgY29sbGVjdGlvbmAgZnJvbSB0aGUgYHN0YXJ0YCBpbmRleCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsXG4gICAqIHRoZSBgZW5kYCBpbmRleC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyB1c2VkLCBpbnN0ZWFkIG9mIGBBcnJheSNzbGljZWAsIHRvIHN1cHBvcnQgbm9kZSBsaXN0c1xuICAgKiBpbiBJRSA8IDkgYW5kIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgaW5kZXguXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICAgIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCB8fCAwLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD13aW5kb3ddIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgLy8gQXZvaWQgaXNzdWVzIHdpdGggc29tZSBFUzMgZW52aXJvbm1lbnRzIHRoYXQgYXR0ZW1wdCB0byB1c2UgdmFsdWVzLCBuYW1lZFxuICAgIC8vIGFmdGVyIGJ1aWx0LWluIGNvbnN0cnVjdG9ycyBsaWtlIGBPYmplY3RgLCBmb3IgdGhlIGNyZWF0aW9uIG9mIGxpdGVyYWxzLlxuICAgIC8vIEVTNSBjbGVhcnMgdGhpcyB1cCBieSBzdGF0aW5nIHRoYXQgbGl0ZXJhbHMgbXVzdCB1c2UgYnVpbHQtaW4gY29uc3RydWN0b3JzLlxuICAgIC8vIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxMS4xLjUuXG4gICAgY29udGV4dCA9IGNvbnRleHQgPyBfLmRlZmF1bHRzKHdpbmRvdy5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHdpbmRvdywgY29udGV4dFByb3BzKSkgOiB3aW5kb3c7XG5cbiAgICAvKiogTmF0aXZlIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMgKi9cbiAgICB2YXIgQXJyYXkgPSBjb250ZXh0LkFycmF5LFxuICAgICAgICBCb29sZWFuID0gY29udGV4dC5Cb29sZWFuLFxuICAgICAgICBEYXRlID0gY29udGV4dC5EYXRlLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE51bWJlciA9IGNvbnRleHQuTnVtYmVyLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGBBcnJheWAgbWV0aG9kIHJlZmVyZW5jZXMuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSBgQXJyYXkucHJvdG90eXBlYCB3b3VsZCBzdWZmaWNlLCBob3dldmVyLCB1c2luZyBhbiBhcnJheSBsaXRlcmFsXG4gICAgICogYXZvaWRzIGlzc3VlcyBpbiBOYXJ3aGFsLlxuICAgICAqL1xuICAgIHZhciBhcnJheVJlZiA9IFtdO1xuXG4gICAgLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyAqL1xuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIHN0cmluZ1Byb3RvID0gU3RyaW5nLnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIGBfYCByZWZlcmVuY2UgaW4gYG5vQ29uZmxpY3RgICovXG4gICAgdmFyIG9sZERhc2ggPSBjb250ZXh0Ll87XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlICovXG4gICAgdmFyIHJlTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgICBTdHJpbmcob2JqZWN0UHJvdG8udmFsdWVPZilcbiAgICAgICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcbiAgICAgICAgLnJlcGxhY2UoL3ZhbHVlT2Z8Zm9yIFteXFxdXSsvZywgJy4rPycpICsgJyQnXG4gICAgKTtcblxuICAgIC8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgICBjbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY29uY2F0ID0gYXJyYXlSZWYuY29uY2F0LFxuICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICAgIGdldFByb3RvdHlwZU9mID0gcmVOYXRpdmUudGVzdChnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICAgIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBjb250ZXh0LnNldEltbWVkaWF0ZSxcbiAgICAgICAgc2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCxcbiAgICAgICAgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qIE5hdGl2ZSBtZXRob2Qgc2hvcnRjdXRzIGZvciBtZXRob2RzIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzICovXG4gICAgdmFyIG5hdGl2ZUJpbmQgPSByZU5hdGl2ZS50ZXN0KG5hdGl2ZUJpbmQgPSB0b1N0cmluZy5iaW5kKSAmJiBuYXRpdmVCaW5kLFxuICAgICAgICBuYXRpdmVDcmVhdGUgPSByZU5hdGl2ZS50ZXN0KG5hdGl2ZUNyZWF0ZSA9ICBPYmplY3QuY3JlYXRlKSAmJiBuYXRpdmVDcmVhdGUsXG4gICAgICAgIG5hdGl2ZUlzQXJyYXkgPSByZU5hdGl2ZS50ZXN0KG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KSAmJiBuYXRpdmVJc0FycmF5LFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUlzTmFOID0gY29udGV4dC5pc05hTixcbiAgICAgICAgbmF0aXZlS2V5cyA9IHJlTmF0aXZlLnRlc3QobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVNsaWNlID0gYXJyYXlSZWYuc2xpY2U7XG5cbiAgICAvKiogRGV0ZWN0IHZhcmlvdXMgZW52aXJvbm1lbnRzICovXG4gICAgdmFyIGlzSWVPcGVyYSA9IHJlTmF0aXZlLnRlc3QoY29udGV4dC5hdHRhY2hFdmVudCksXG4gICAgICAgIGlzVjggPSBuYXRpdmVCaW5kICYmICEvXFxufHRydWUvLnRlc3QobmF0aXZlQmluZCArIGlzSWVPcGVyYSk7XG5cbiAgICAvKiogVXNlZCB0byBsb29rdXAgYSBidWlsdC1pbiBjb25zdHJ1Y3RvciBieSBbW0NsYXNzXV0gKi9cbiAgICB2YXIgY3RvckJ5Q2xhc3MgPSB7fTtcbiAgICBjdG9yQnlDbGFzc1thcnJheUNsYXNzXSA9IEFycmF5O1xuICAgIGN0b3JCeUNsYXNzW2Jvb2xDbGFzc10gPSBCb29sZWFuO1xuICAgIGN0b3JCeUNsYXNzW2RhdGVDbGFzc10gPSBEYXRlO1xuICAgIGN0b3JCeUNsYXNzW2Z1bmNDbGFzc10gPSBGdW5jdGlvbjtcbiAgICBjdG9yQnlDbGFzc1tvYmplY3RDbGFzc10gPSBPYmplY3Q7XG4gICAgY3RvckJ5Q2xhc3NbbnVtYmVyQ2xhc3NdID0gTnVtYmVyO1xuICAgIGN0b3JCeUNsYXNzW3JlZ2V4cENsYXNzXSA9IFJlZ0V4cDtcbiAgICBjdG9yQnlDbGFzc1tzdHJpbmdDbGFzc10gPSBTdHJpbmc7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCBvYmplY3QsIHdoaWNoIHdyYXBzIHRoZSBnaXZlbiBgdmFsdWVgLCB0byBlbmFibGUgbWV0aG9kXG4gICAgICogY2hhaW5pbmcuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBMby1EYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGFsc28gaGF2ZSB0aGUgZm9sbG93aW5nIGBBcnJheWAgbWV0aG9kczpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgcmV2ZXJzZWAsIGBzaGlmdGAsIGBzbGljZWAsIGBzb3J0YCwgYHNwbGljZWAsXG4gICAgICogYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYHZhbHVlYCBtZXRob2QgaXNcbiAgICAgKiBpbXBsaWNpdGx5IG9yIGV4cGxpY2l0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIGZ1bmN0aW9ucyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFzc2lnbmAsIGBiaW5kYCwgYGJpbmRBbGxgLCBgYmluZEtleWAsIGBjaGFpbmAsIGBjb21wYWN0YCxcbiAgICAgKiBgY29tcG9zZWAsIGBjb25jYXRgLCBgY291bnRCeWAsIGBjcmVhdGVDYWxsYmFja2AsIGBkZWJvdW5jZWAsIGBkZWZhdWx0c2AsXG4gICAgICogYGRlZmVyYCwgYGRlbGF5YCwgYGRpZmZlcmVuY2VgLCBgZmlsdGVyYCwgYGZsYXR0ZW5gLCBgZm9yRWFjaGAsIGBmb3JJbmAsXG4gICAgICogYGZvck93bmAsIGBmdW5jdGlvbnNgLCBgZ3JvdXBCeWAsIGBpbml0aWFsYCwgYGludGVyc2VjdGlvbmAsIGBpbnZlcnRgLFxuICAgICAqIGBpbnZva2VgLCBga2V5c2AsIGBtYXBgLCBgbWF4YCwgYG1lbW9pemVgLCBgbWVyZ2VgLCBgbWluYCwgYG9iamVjdGAsIGBvbWl0YCxcbiAgICAgKiBgb25jZWAsIGBwYWlyc2AsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwaWNrYCwgYHBsdWNrYCwgYHB1c2hgLCBgcmFuZ2VgLFxuICAgICAqIGByZWplY3RgLCBgcmVzdGAsIGByZXZlcnNlYCwgYHNodWZmbGVgLCBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCxcbiAgICAgKiBgdGFwYCwgYHRocm90dGxlYCwgYHRpbWVzYCwgYHRvQXJyYXlgLCBgdHJhbnNmb3JtYCwgYHVuaW9uYCwgYHVuaXFgLCBgdW5zaGlmdGAsXG4gICAgICogYHVuemlwYCwgYHZhbHVlc2AsIGB3aGVyZWAsIGB3aXRob3V0YCwgYHdyYXBgLCBhbmQgYHppcGBcbiAgICAgKlxuICAgICAqIFRoZSBub24tY2hhaW5hYmxlIHdyYXBwZXIgZnVuY3Rpb25zIGFyZTpcbiAgICAgKiBgY2xvbmVgLCBgY2xvbmVEZWVwYCwgYGNvbnRhaW5zYCwgYGVzY2FwZWAsIGBldmVyeWAsIGBmaW5kYCwgYGhhc2AsXG4gICAgICogYGlkZW50aXR5YCwgYGluZGV4T2ZgLCBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0Jvb2xlYW5gLCBgaXNEYXRlYCxcbiAgICAgKiBgaXNFbGVtZW50YCwgYGlzRW1wdHlgLCBgaXNFcXVhbGAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzTmFOYCxcbiAgICAgKiBgaXNOdWxsYCwgYGlzTnVtYmVyYCwgYGlzT2JqZWN0YCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLCBgaXNTdHJpbmdgLFxuICAgICAqIGBpc1VuZGVmaW5lZGAsIGBqb2luYCwgYGxhc3RJbmRleE9mYCwgYG1peGluYCwgYG5vQ29uZmxpY3RgLCBgcGFyc2VJbnRgLFxuICAgICAqIGBwb3BgLCBgcmFuZG9tYCwgYHJlZHVjZWAsIGByZWR1Y2VSaWdodGAsIGByZXN1bHRgLCBgc2hpZnRgLCBgc2l6ZWAsIGBzb21lYCxcbiAgICAgKiBgc29ydGVkSW5kZXhgLCBgcnVuSW5Db250ZXh0YCwgYHRlbXBsYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYW5kIGB2YWx1ZWBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGZ1bmN0aW9ucyBgZmlyc3RgIGFuZCBgbGFzdGAgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gYG5gIGlzXG4gICAgICogcGFzc2VkLCBvdGhlcndpc2UgdGhleSByZXR1cm4gdW53cmFwcGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgY2hhaW5cbiAgICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyByZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZVxuICAgICAqIHdyYXBwZWQucmVkdWNlKGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIHJldHVybnMgYSB3cmFwcGVkIHZhbHVlXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gKiBudW07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzLnZhbHVlKCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAgIC8vIGRvbid0IHdyYXAgaWYgYWxyZWFkeSB3cmFwcGVkLCBldmVuIGlmIHdyYXBwZWQgYnkgYSBkaWZmZXJlbnQgYGxvZGFzaGAgY29uc3RydWN0b3JcbiAgICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmICFpc0FycmF5KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSlcbiAgICAgICA/IHZhbHVlXG4gICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmYXN0IHBhdGggZm9yIGNyZWF0aW5nIGBsb2Rhc2hgIHdyYXBwZXIgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAgaW4gYSBgbG9kYXNoYCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoV3JhcHBlcih2YWx1ZSkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgYG5ldyBsb2Rhc2hXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgbG9kYXNoYFxuICAgIGxvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gbG9kYXNoLnByb3RvdHlwZTtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGZsYWcgZW52aXJvbm1lbnRzIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHN1cHBvcnQgPSBsb2Rhc2guc3VwcG9ydCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGBGdW5jdGlvbiNiaW5kYCBleGlzdHMgYW5kIGlzIGluZmVycmVkIHRvIGJlIGZhc3QgKGFsbCBidXQgVjgpLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8uc3VwcG9ydFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICBzdXBwb3J0LmZhc3RCaW5kID0gbmF0aXZlQmluZCAmJiAhaXNWODtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgTG8tRGFzaCBhcmUgc2ltaWxhciB0byB0aG9zZSBpblxuICAgICAqIGVtYmVkZGVkIFJ1YnkgKEVSQikuIENoYW5nZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZVxuICAgICAqIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgICAqL1xuICAgICAgJ2VzY2FwZSc6IC88JS0oW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIFJlZ0V4cFxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZ1xuICAgICAqIG9mIGB0aGlzQXJnYCBhbmQgcHJlcGVuZHMgYW55IGBwYXJ0aWFsQXJnc2AgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlXG4gICAgICogYm91bmQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kIG9yIHRoZSBtZXRob2QgbmFtZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFsQXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtpZGljYXRvcl0gVXNlZCB0byBpbmRpY2F0ZSBiaW5kaW5nIGJ5IGtleSBvciBwYXJ0aWFsbHlcbiAgICAgKiAgYXBwbHlpbmcgYXJndW1lbnRzIGZyb20gdGhlIHJpZ2h0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxBcmdzLCBpbmRpY2F0b3IpIHtcbiAgICAgIHZhciBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGZ1bmMpLFxuICAgICAgICAgIGlzUGFydGlhbCA9ICFwYXJ0aWFsQXJncyxcbiAgICAgICAgICBrZXkgPSB0aGlzQXJnO1xuXG4gICAgICAvLyBqdWdnbGUgYXJndW1lbnRzXG4gICAgICBpZiAoaXNQYXJ0aWFsKSB7XG4gICAgICAgIHZhciByaWdodEluZGljYXRvciA9IGluZGljYXRvcjtcbiAgICAgICAgcGFydGlhbEFyZ3MgPSB0aGlzQXJnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzRnVuYykge1xuICAgICAgICBpZiAoIWluZGljYXRvcikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc0FyZyA9IGZ1bmM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAvLyBgRnVuY3Rpb24jYmluZGAgc3BlY1xuICAgICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIHRoaXNCaW5kaW5nID0gaXNQYXJ0aWFsID8gdGhpcyA6IHRoaXNBcmc7XG5cbiAgICAgICAgaWYgKCFpc0Z1bmMpIHtcbiAgICAgICAgICBmdW5jID0gdGhpc0FyZ1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsQXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBhcmdzID0gYXJncy5sZW5ndGhcbiAgICAgICAgICAgID8gKGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3MpLCByaWdodEluZGljYXRvciA/IGFyZ3MuY29uY2F0KHBhcnRpYWxBcmdzKSA6IHBhcnRpYWxBcmdzLmNvbmNhdChhcmdzKSlcbiAgICAgICAgICAgIDogcGFydGlhbEFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgIC8vIGVuc3VyZSBgbmV3IGJvdW5kYCBpcyBhbiBpbnN0YW5jZSBvZiBgZnVuY2BcbiAgICAgICAgICB0aGlzQmluZGluZyA9IGNyZWF0ZU9iamVjdChmdW5jLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAvLyBtaW1pYyB0aGUgY29uc3RydWN0b3IncyBgcmV0dXJuYCBiZWhhdmlvclxuICAgICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDEzLjIuMlxuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSA/IHJlc3VsdCA6IHRoaXNCaW5kaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYHByb3RvdHlwZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVPYmplY3QocHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QocHJvdG90eXBlKSA/IG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sRXNjYXBlc1ttYXRjaF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpbmRleE9mXCIgZnVuY3Rpb24uIElmIHRoZSBgXy5pbmRleE9mYCBtZXRob2QgaXNcbiAgICAgKiBjdXN0b21pemVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAqIHRoZSBgYmFzaWNJbmRleE9mYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBcImluZGV4T2ZcIiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKHJlc3VsdCA9IGxvZGFzaC5pbmRleE9mKSA9PT0gaW5kZXhPZiA/IGJhc2ljSW5kZXhPZiA6IHJlc3VsdDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQganVnZ2xlcyBhcmd1bWVudHMsIGFsbG93aW5nIGFyZ3VtZW50IG92ZXJsb2FkaW5nXG4gICAgICogZm9yIGBfLmZsYXR0ZW5gIGFuZCBgXy51bmlxYCwgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byB0aGUgZ2l2ZW4gYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJsb2FkV3JhcHBlcihmdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGZsYWcsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFnICE9ICdib29sZWFuJyAmJiBmbGFnICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzQXJnID0gY2FsbGJhY2s7XG4gICAgICAgICAgY2FsbGJhY2sgPSAhKHRoaXNBcmcgJiYgdGhpc0FyZ1tmbGFnXSA9PT0gYXJyYXkpID8gZmxhZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJyYXksIGZsYWcsIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgaXNQbGFpbk9iamVjdGAgd2hpY2ggY2hlY2tzIGlmIGEgZ2l2ZW4gYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3RvciwgYXNzdW1pbmcgb2JqZWN0cyBjcmVhdGVkXG4gICAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgICAqIHRoZXJlIGFyZSBubyBgT2JqZWN0LnByb3RvdHlwZWAgZXh0ZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgY3RvcixcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIC8vIGF2b2lkIG5vbiBPYmplY3Qgb2JqZWN0cywgYGFyZ3VtZW50c2Agb2JqZWN0cywgYW5kIERPTSBlbGVtZW50c1xuICAgICAgaWYgKCEodmFsdWUgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gb2JqZWN0Q2xhc3MpIHx8XG4gICAgICAgICAgKGN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvciwgaXNGdW5jdGlvbihjdG9yKSAmJiAhKGN0b3IgaW5zdGFuY2VvZiBjdG9yKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gSW4gbW9zdCBlbnZpcm9ubWVudHMgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgYXJlIGl0ZXJhdGVkIGJlZm9yZVxuICAgICAgLy8gaXRzIGluaGVyaXRlZCBwcm9wZXJ0aWVzLiBJZiB0aGUgbGFzdCBpdGVyYXRlZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qnc1xuICAgICAgLy8gb3duIHByb3BlcnR5IHRoZW4gdGhlcmUgYXJlIG5vIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICBmb3JJbih2YWx1ZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYHVuZXNjYXBlYCB0byBjb252ZXJ0IEhUTUwgZW50aXRpZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcmd1bWVudHMoYXJndW1lbnRzKTsgfSkoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzQ2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAsIGlmIHRoZSBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcnJheShhcmd1bWVudHMpOyB9KSgpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBuYXRpdmVJc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIHByb2R1Y2VzIGFuIGFycmF5IG9mIHRoZVxuICAgICAqIGdpdmVuIG9iamVjdCdzIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICB2YXIgc2hpbUtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAoIShvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0XSkpIHJldHVybiByZXN1bHQ7ICAgIFxuICAgICAgICBmb3IgKGluZGV4IGluIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGluZGV4KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZXgpOyAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH0gICAgXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29tcG9zZWQgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2V5cyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbJ29uZScsICd0d28nLCAndGhyZWUnXSAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgYD5gIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlIGA+YCBhbmQgYC9gXG4gICAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAgICogb2YgYSB0YWcgb3IgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKVxuICAgICAqL1xuICAgIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAgICcmJzogJyZhbXA7JyxcbiAgICAgICc8JzogJyZsdDsnLFxuICAgICAgJz4nOiAnJmd0OycsXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAgIFwiJ1wiOiAnJiMzOTsnXG4gICAgfTtcblxuICAgIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gICAgdmFyIGh0bWxVbmVzY2FwZXMgPSBpbnZlcnQoaHRtbEVzY2FwZXMpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91c1xuICAgICAqIHNvdXJjZXMuIElmIGEgYGNhbGxiYWNrYCBmdW5jdGlvbiBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG8gcHJvZHVjZVxuICAgICAqIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdHdvIGFyZ3VtZW50czsgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3NvdXJjZTEsIHNvdXJjZTIsIC4uLl0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25pbmcgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ25hbWUnOiAnbW9lJyB9LCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbiwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIHR5cGVvZiBhID09ICd1bmRlZmluZWQnID8gYiA6IGE7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHsgJ25hbWUnOiAnYXBwbGUnIH07XG4gICAgICogZGVmYXVsdHMoZm9vZCwgeyAnbmFtZSc6ICdiYW5hbmEnLCAndHlwZSc6ICdmcnVpdCcgfSk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdhcHBsZScsICd0eXBlJzogJ2ZydWl0JyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGZ1bmN0aW9uIChvYmplY3QsIHNvdXJjZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBpbmRleCwgaXRlcmFibGUgPSBvYmplY3QsIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IDAsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IHR5cGVvZiBndWFyZCA9PSAnbnVtYmVyJyA/IDIgOiBhcmdzLmxlbmd0aDtcbiAgICAgIGlmIChhcmdzTGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1thcmdzTGVuZ3RoIC0gMl0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soYXJnc1stLWFyZ3NMZW5ndGggLSAxXSwgYXJnc1thcmdzTGVuZ3RoLS1dLCAyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnc0xlbmd0aCA+IDIgJiYgdHlwZW9mIGFyZ3NbYXJnc0xlbmd0aCAtIDFdID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tYXJnc0xlbmd0aF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgeyAgICBcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2sgPyBjYWxsYmFjayhyZXN1bHRbaW5kZXhdLCBpdGVyYWJsZVtpbmRleF0pIDogaXRlcmFibGVbaW5kZXhdOyAgICBcbiAgICAgICAgfSAgICBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYGRlZXBgIGlzIGB0cnVlYCwgbmVzdGVkIG9iamVjdHMgd2lsbCBhbHNvXG4gICAgICogYmUgY2xvbmVkLCBvdGhlcndpc2UgdGhleSB3aWxsIGJlIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZS4gSWYgYSBgY2FsbGJhY2tgXG4gICAgICogZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmXG4gICAgICogYGNhbGxiYWNrYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuXG4gICAgICogVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZGVlcD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEBwYXJhbS0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge0FycmF5fSBbc3RhY2tCPVtdXSBBc3NvY2lhdGVzIGNsb25lcyB3aXRoIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBjbG9uZWQgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0b29nZXMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShzdG9vZ2VzKTtcbiAgICAgKiBzaGFsbG93WzBdID09PSBzdG9vZ2VzWzBdO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZShzdG9vZ2VzLCB0cnVlKTtcbiAgICAgKiBkZWVwWzBdID09PSBzdG9vZ2VzWzBdO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLm1peGluKHtcbiAgICAgKiAgICdjbG9uZSc6IF8ucGFydGlhbFJpZ2h0KF8uY2xvbmUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAqICAgfSlcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjbG9uZSA9IF8uY2xvbmUoZG9jdW1lbnQuYm9keSk7XG4gICAgICogY2xvbmUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlLCBkZWVwLCBjYWxsYmFjaywgdGhpc0FyZywgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblxuICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcyB3aXRob3V0IHVzaW5nIHRoZWlyIGBjYWxsYmFja2BcbiAgICAgIC8vIGFyZ3VtZW50LCBgaW5kZXh8a2V5YCwgZm9yIHRoaXMgbWV0aG9kJ3MgYGNhbGxiYWNrYFxuICAgICAgaWYgKHR5cGVvZiBkZWVwICE9ICdib29sZWFuJyAmJiBkZWVwICE9IG51bGwpIHtcbiAgICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGRlZXA7XG4gICAgICAgIGRlZXAgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9ICh0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICA/IGNhbGxiYWNrXG4gICAgICAgICAgOiBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpO1xuXG4gICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIGluc3BlY3QgW1tDbGFzc11dXG4gICAgICB2YXIgaXNPYmogPSBpc09iamVjdChyZXN1bHQpO1xuICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHJlc3VsdCk7XG4gICAgICAgIGlmICghY2xvbmVhYmxlQ2xhc3Nlc1tjbGFzc05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHJlc3VsdCk7XG4gICAgICB9XG4gICAgICAvLyBzaGFsbG93IGNsb25lXG4gICAgICBpZiAoIWlzT2JqIHx8ICFkZWVwKSB7XG4gICAgICAgIHJldHVybiBpc09ialxuICAgICAgICAgID8gKGlzQXJyID8gc2xpY2UocmVzdWx0KSA6IGFzc2lnbih7fSwgcmVzdWx0KSlcbiAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBjdG9yID0gY3RvckJ5Q2xhc3NbY2xhc3NOYW1lXTtcbiAgICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgICBjYXNlIGRhdGVDbGFzczpcbiAgICAgICAgICByZXR1cm4gbmV3IGN0b3IoK3Jlc3VsdCk7XG5cbiAgICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICByZXR1cm4gbmV3IGN0b3IocmVzdWx0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgICAgIHJldHVybiBjdG9yKHJlc3VsdC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZXN1bHQpKTtcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gY29ycmVzcG9uZGluZyBjbG9uZVxuICAgICAgdmFyIGluaXRlZFN0YWNrID0gIXN0YWNrQTtcbiAgICAgIHN0YWNrQSB8fCAoc3RhY2tBID0gZ2V0QXJyYXkoKSk7XG4gICAgICBzdGFja0IgfHwgKHN0YWNrQiA9IGdldEFycmF5KCkpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoc3RhY2tBW2xlbmd0aF0gPT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGluaXQgY2xvbmVkIG9iamVjdFxuICAgICAgcmVzdWx0ID0gaXNBcnIgPyBjdG9yKHJlc3VsdC5sZW5ndGgpIDoge307XG5cbiAgICAgIC8vIGFkZCBhcnJheSBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2BcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2luZGV4JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5kZXggPSB2YWx1ZS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2lucHV0JykpIHtcbiAgICAgICAgICByZXN1bHQuaW5wdXQgPSB2YWx1ZS5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAvLyBhbmQgYXNzb2NpYXRlIGl0IHdpdGggaXRzIGNsb25lXG4gICAgICBzdGFja0EucHVzaCh2YWx1ZSk7XG4gICAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKSh2YWx1ZSwgZnVuY3Rpb24ob2JqVmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKG9ialZhbHVlLCBkZWVwLCBjYWxsYmFjaywgdW5kZWZpbmVkLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgYHZhbHVlYC4gSWYgYSBgY2FsbGJhY2tgIGZ1bmN0aW9uIGlzIHBhc3NlZCxcbiAgICAgKiBpdCB3aWxsIGJlIGV4ZWN1dGVkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZXMuIElmIGBjYWxsYmFja2AgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBjbG9uaW5nIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY2FsbGJhY2tgXG4gICAgICogaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGUgc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG0uIEZ1bmN0aW9uc1xuICAgICAqIGFuZCBET00gbm9kZXMgYXJlICoqbm90KiogY2xvbmVkLiBUaGUgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYW5kXG4gICAgICogb2JqZWN0cyBjcmVhdGVkIGJ5IGNvbnN0cnVjdG9ycyBvdGhlciB0aGFuIGBPYmplY3RgIGFyZSBjbG9uZWQgdG8gcGxhaW4gYE9iamVjdGAgb2JqZWN0cy5cbiAgICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNpbnRlcm5hbC1zdHJ1Y3R1cmVkLWNsb25pbmctYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGVlcCBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0b29nZXMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAoc3Rvb2dlcyk7XG4gICAgICogZGVlcFswXSA9PT0gc3Rvb2dlc1swXTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnbm9kZSc6IGVsZW1lbnRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGNsb25lID0gXy5jbG9uZURlZXAodmlldywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzRWxlbWVudCh2YWx1ZSkgPyB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjbG9uZS5ub2RlID09IHZpZXcubm9kZTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHJldHVybiBjbG9uZSh2YWx1ZSwgdHJ1ZSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAgICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgZGVmYXVsdHMgb2YgdGhlIHNhbWUgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3NvdXJjZTEsIHNvdXJjZTIsIC4uLl0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBBbGxvd3Mgd29ya2luZyB3aXRoIGBfLnJlZHVjZWAgd2l0aG91dCB1c2luZyBpdHNcbiAgICAgKiAgY2FsbGJhY2sncyBga2V5YCBhbmQgYG9iamVjdGAgYXJndW1lbnRzIGFzIHNvdXJjZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHsgJ25hbWUnOiAnYXBwbGUnIH07XG4gICAgICogXy5kZWZhdWx0cyhmb29kLCB7ICduYW1lJzogJ2JhbmFuYScsICd0eXBlJzogJ2ZydWl0JyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2FwcGxlJywgJ3R5cGUnOiAnZnJ1aXQnIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBmdW5jdGlvbiAob2JqZWN0LCBzb3VyY2UsIGd1YXJkKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gb2JqZWN0LCByZXN1bHQgPSBpdGVyYWJsZTtcbiAgICAgIGlmICghaXRlcmFibGUpIHJldHVybiByZXN1bHQ7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBhcmdzSW5kZXggPSAwLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSB0eXBlb2YgZ3VhcmQgPT0gJ251bWJlcicgPyAyIDogYXJncy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhYmxlID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmFibGUgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgeyAgICBcbiAgICAgICAgdmFyIG93bkluZGV4ID0gLTEsXG4gICAgICAgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYWJsZV0gJiYga2V5cyhpdGVyYWJsZSksXG4gICAgICAgICAgICBsZW5ndGggPSBvd25Qcm9wcyA/IG93blByb3BzLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IG93blByb3BzW293bkluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtpbmRleF0gPT0gJ3VuZGVmaW5lZCcpIHJlc3VsdFtpbmRleF0gPSBpdGVyYWJsZVtpbmRleF07ICAgIFxuICAgICAgICB9ICAgIFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8uZmluZGAsIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGVcbiAgICAgKiBlbGVtZW50IHRoYXQgcGFzc2VzIHRoZSBjYWxsYmFjayBjaGVjaywgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8U3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGVcbiAgICAgKiAgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kS2V5KHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH0sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBgb2JqZWN0YCdzIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcywgZXhlY3V0aW5nXG4gICAgICogdGhlIGBjYWxsYmFja2AgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSBGdW5jdGlvblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRG9nKG5hbWUpIHtcbiAgICAgKiAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRG9nLnByb3RvdHlwZS5iYXJrID0gZnVuY3Rpb24oKSB7XG4gICAgICogICBhbGVydCgnV29vZiwgd29vZiEnKTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRG9nKCdEYWdueScpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBhbGVydChrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IGFsZXJ0cyAnbmFtZScgYW5kICdiYXJrJyAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvckluID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXgsIGl0ZXJhYmxlID0gY29sbGVjdGlvbiwgcmVzdWx0ID0gaXRlcmFibGU7XG4gICAgICBpZiAoIWl0ZXJhYmxlKSByZXR1cm4gcmVzdWx0O1xuICAgICAgaWYgKCFvYmplY3RUeXBlc1t0eXBlb2YgaXRlcmFibGVdKSByZXR1cm4gcmVzdWx0O1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTsgICAgXG4gICAgICAgIGZvciAoaW5kZXggaW4gaXRlcmFibGUpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2soaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSByZXR1cm4gcmVzdWx0OyAgICBcbiAgICAgICAgfSAgICBcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzLCBleGVjdXRpbmcgdGhlIGBjYWxsYmFja2BcbiAgICAgKiBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAgICAgKiByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvck93bih7ICcwJzogJ3plcm8nLCAnMSc6ICdvbmUnLCAnbGVuZ3RoJzogMiB9LCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAqICAgYWxlcnQoa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBhbGVydHMgJzAnLCAnMScsIGFuZCAnbGVuZ3RoJyAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIGZvck93biA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4LCBpdGVyYWJsZSA9IGNvbGxlY3Rpb24sIHJlc3VsdCA9IGl0ZXJhYmxlO1xuICAgICAgaWYgKCFpdGVyYWJsZSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGlmICghb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgJiYgdHlwZW9mIHRoaXNBcmcgPT0gJ3VuZGVmaW5lZCcgPyBjYWxsYmFjayA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7ICAgIFxuICAgICAgICB2YXIgb3duSW5kZXggPSAtMSxcbiAgICAgICAgICAgIG93blByb3BzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGl0ZXJhYmxlXSAmJiBrZXlzKGl0ZXJhYmxlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG93blByb3BzID8gb3duUHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytvd25JbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayhpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQ7ICAgIFxuICAgICAgICB9ICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc29ydGVkIGFycmF5IG9mIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIG93biBhbmQgaW5oZXJpdGVkLFxuICAgICAqIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgbWV0aG9kc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKF8pO1xuICAgICAqIC8vID0+IFsnYWxsJywgJ2FueScsICdiaW5kJywgJ2JpbmRBbGwnLCAnY2xvbmUnLCAnY29tcGFjdCcsICdjb21wb3NlJywgLi4uXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBgcHJvcGVydHlgIGV4aXN0cyBhbmQgaXMgYSBkaXJlY3QgcHJvcGVydHksXG4gICAgICogaW5zdGVhZCBvZiBhbiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYga2V5IGlzIGEgZGlyZWN0IHByb3BlcnR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGFzKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCAnYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA/IGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBnaXZlbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjcmVhdGVkIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogIF8uaW52ZXJ0KHsgJ2ZpcnN0JzogJ21vZScsICdzZWNvbmQnOiAnbGFycnknIH0pO1xuICAgICAqIC8vID0+IHsgJ21vZSc6ICdmaXJzdCcsICdsYXJyeSc6ICdzZWNvbmQnIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZlcnQob2JqZWN0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtvYmplY3Rba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgdGhlIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwodmFsdWUpID09IGJvb2xDbGFzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGRhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAsIGlmIHRoZSBgdmFsdWVgIGlzIGEgZGF0ZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlQ2xhc3MpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgdGhlIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5ub2RlVHlwZSA9PT0gMSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAgICogbGVuZ3RoIG9mIGAwYCBhbmQgb2JqZWN0cyB3aXRoIG5vIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvbnNpZGVyZWRcbiAgICAgKiBcImVtcHR5XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgLCBpZiB0aGUgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoJycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIGlmICgoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBhcmdzQ2xhc3MgKSB8fFxuICAgICAgICAgIChjbGFzc05hbWUgPT0gb2JqZWN0Q2xhc3MgJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNwbGljZSkpKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yT3duKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQgdG8gZWFjaCBvdGhlci4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgdG9cbiAgICAgKiBjb21wYXJlIHZhbHVlcy4gSWYgYGNhbGxiYWNrYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29ucyB3aWxsIGJlIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoXG4gICAgICogdHdvIGFyZ3VtZW50czsgKGEsIGIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IGIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmluZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEBwYXJhbS0ge0FycmF5fSBbc3RhY2tBPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBhYCBvYmplY3RzLlxuICAgICAqIEBwYXJhbS0ge0FycmF5fSBbc3RhY2tCPVtdXSBUcmFja3MgdHJhdmVyc2VkIGBiYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbW9lID0geyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfTtcbiAgICAgKiB2YXIgY29weSA9IHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH07XG4gICAgICpcbiAgICAgKiBtb2UgPT0gY29weTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG1vZSwgY29weSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHdvcmRzID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyV29yZHMgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbCh3b3Jkcywgb3RoZXJXb3JkcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgdmFyIHJlR3JlZXQgPSAvXig/OmhlbGxvfGhpKSQvaSxcbiAgICAgKiAgICAgICBhR3JlZXQgPSBfLmlzU3RyaW5nKGEpICYmIHJlR3JlZXQudGVzdChhKSxcbiAgICAgKiAgICAgICBiR3JlZXQgPSBfLmlzU3RyaW5nKGIpICYmIHJlR3JlZXQudGVzdChiKTtcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIChhR3JlZXQgfHwgYkdyZWV0KSA/IChhR3JlZXQgPT0gYkdyZWV0KSA6IHVuZGVmaW5lZDtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBjYWxsYmFjaywgdGhpc0FyZywgc3RhY2tBLCBzdGFja0IpIHtcbiAgICAgIC8vIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIGNvbXBhcmluZyBvYmplY3RzLCBgYWAgaGFzIGF0IGxlYXN0IHRoZSBwcm9wZXJ0aWVzIG9mIGBiYFxuICAgICAgdmFyIHdoZXJlSW5kaWNhdG9yID0gY2FsbGJhY2sgPT09IGluZGljYXRvck9iamVjdDtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyAmJiAhd2hlcmVJbmRpY2F0b3IpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDIpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soYSwgYik7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBpZGVudGljYWwgdmFsdWVzXG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAvLyB0cmVhdCBgKzBgIHZzLiBgLTBgIGFzIG5vdCBlcXVhbFxuICAgICAgICByZXR1cm4gYSAhPT0gMCB8fCAoMSAvIGEgPT0gMSAvIGIpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgYSxcbiAgICAgICAgICBvdGhlclR5cGUgPSB0eXBlb2YgYjtcblxuICAgICAgLy8gZXhpdCBlYXJseSBmb3IgdW5saWtlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgIGlmIChhID09PSBhICYmXG4gICAgICAgICAgKCFhIHx8ICh0eXBlICE9ICdmdW5jdGlvbicgJiYgdHlwZSAhPSAnb2JqZWN0JykpICYmXG4gICAgICAgICAgKCFiIHx8IChvdGhlclR5cGUgIT0gJ2Z1bmN0aW9uJyAmJiBvdGhlclR5cGUgIT0gJ29iamVjdCcpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGVhcmx5IGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgLCBhdm9pZGluZyBFUzMncyBGdW5jdGlvbiNjYWxsIGJlaGF2aW9yXG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNFxuICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG4gICAgICAvLyBjb21wYXJlIFtbQ2xhc3NdXSBuYW1lc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSksXG4gICAgICAgICAgb3RoZXJDbGFzcyA9IHRvU3RyaW5nLmNhbGwoYik7XG5cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IG9iamVjdENsYXNzO1xuICAgICAgfVxuICAgICAgaWYgKG90aGVyQ2xhc3MgPT0gYXJnc0NsYXNzKSB7XG4gICAgICAgIG90aGVyQ2xhc3MgPSBvYmplY3RDbGFzcztcbiAgICAgIH1cbiAgICAgIGlmIChjbGFzc05hbWUgIT0gb3RoZXJDbGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgICBjYXNlIGJvb2xDbGFzczpcbiAgICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgICAgLy8gY29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kIGJvb2xlYW5zXG4gICAgICAgICAgLy8gdG8gYDFgIG9yIGAwYCwgdHJlYXRpbmcgaW52YWxpZCBkYXRlcyBjb2VyY2VkIHRvIGBOYU5gIGFzIG5vdCBlcXVhbFxuICAgICAgICAgIHJldHVybiArYSA9PSArYjtcblxuICAgICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgICAgIC8vIHRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiAoYSAhPSArYSlcbiAgICAgICAgICAgID8gYiAhPSArYlxuICAgICAgICAgICAgLy8gYnV0IHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgICA6IChhID09IDAgPyAoMSAvIGEgPT0gMSAvIGIpIDogYSA9PSArYik7XG5cbiAgICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgICAvLyBjb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIChodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4xMC42LjQpXG4gICAgICAgICAgLy8gdHJlYXQgc3RyaW5nIHByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IGluc3RhbmNlcyBhcyBlcXVhbFxuICAgICAgICAgIHJldHVybiBhID09IFN0cmluZyhiKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzO1xuICAgICAgaWYgKCFpc0Fycikge1xuICAgICAgICAvLyB1bndyYXAgYW55IGBsb2Rhc2hgIHdyYXBwZWQgdmFsdWVzXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsICdfX3dyYXBwZWRfXyAnKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsICdfX3dyYXBwZWRfXycpKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRXF1YWwoYS5fX3dyYXBwZWRfXyB8fCBhLCBiLl9fd3JhcHBlZF9fIHx8IGIsIGNhbGxiYWNrLCB0aGlzQXJnLCBzdGFja0EsIHN0YWNrQik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhpdCBmb3IgZnVuY3Rpb25zIGFuZCBET00gbm9kZXNcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSBvYmplY3RDbGFzcykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBPcGVyYSwgYGFyZ3VtZW50c2Agb2JqZWN0cyBoYXZlIGBBcnJheWAgY29uc3RydWN0b3JzXG4gICAgICAgIHZhciBjdG9yQSA9IGEuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBjdG9yQiA9IGIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gbm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWxcbiAgICAgICAgaWYgKGN0b3JBICE9IGN0b3JCICYmICEoXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiZcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihjdG9yQikgJiYgY3RvckIgaW5zdGFuY2VvZiBjdG9yQlxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYXNzdW1lIGN5Y2xpYyBzdHJ1Y3R1cmVzIGFyZSBlcXVhbFxuICAgICAgLy8gdGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpYyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjFcbiAgICAgIC8vIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AgKGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjEyLjMpXG4gICAgICB2YXIgaW5pdGVkU3RhY2sgPSAhc3RhY2tBO1xuICAgICAgc3RhY2tBIHx8IChzdGFja0EgPSBnZXRBcnJheSgpKTtcbiAgICAgIHN0YWNrQiB8fCAoc3RhY2tCID0gZ2V0QXJyYXkoKSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSBhKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzaXplID0gMDtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIC8vIGFkZCBgYWAgYW5kIGBiYCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHNcbiAgICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgICAgc3RhY2tCLnB1c2goYik7XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgc2l6ZSA9IGIubGVuZ3RoO1xuXG4gICAgICAgIC8vIGNvbXBhcmUgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5XG4gICAgICAgIHJlc3VsdCA9IHNpemUgPT0gYS5sZW5ndGg7XG4gICAgICAgIGlmICghcmVzdWx0ICYmICF3aGVyZUluZGljYXRvcikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllc1xuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGJbc2l6ZV07XG5cbiAgICAgICAgICBpZiAod2hlcmVJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgIGlmICgocmVzdWx0ID0gaXNFcXVhbChhW2luZGV4XSwgdmFsdWUsIGNhbGxiYWNrLCB0aGlzQXJnLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCEocmVzdWx0ID0gaXNFcXVhbChhW3NpemVdLCB2YWx1ZSwgY2FsbGJhY2ssIHRoaXNBcmcsIHN0YWNrQSwgc3RhY2tCKSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gZGVlcCBjb21wYXJlIG9iamVjdHMgdXNpbmcgYGZvckluYCwgaW5zdGVhZCBvZiBgZm9yT3duYCwgdG8gYXZvaWQgYE9iamVjdC5rZXlzYFxuICAgICAgLy8gd2hpY2gsIGluIHRoaXMgY2FzZSwgaXMgbW9yZSBjb3N0bHlcbiAgICAgIGZvckluKGIsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGIpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSkge1xuICAgICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgcHJvcGVydGllcy5cbiAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgLy8gZGVlcCBjb21wYXJlIGVhY2ggcHJvcGVydHkgdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkgJiYgaXNFcXVhbChhW2tleV0sIHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZywgc3RhY2tBLCBzdGFja0IpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXN1bHQgJiYgIXdoZXJlSW5kaWNhdG9yKSB7XG4gICAgICAgIC8vIGVuc3VyZSBib3RoIG9iamVjdHMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllc1xuICAgICAgICBmb3JJbihhLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBhKSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYSwga2V5KSkge1xuICAgICAgICAgICAgLy8gYHNpemVgIHdpbGwgYmUgYC0xYCBpZiBgYWAgaGFzIG1vcmUgcHJvcGVydGllcyB0aGFuIGBiYFxuICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgPSAtLXNpemUgPiAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbml0ZWRTdGFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tBKTtcbiAgICAgICAgcmVsZWFzZUFycmF5KHN0YWNrQik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzLCBvciBjYW4gYmUgY29lcmNlZCB0bywgYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgbmF0aXZlIGBpc0Zpbml0ZWAsIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgZm9yXG4gICAgICogYm9vbGVhbnMgYW5kIGVtcHR5IHN0cmluZ3MuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4xLjIuNS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgdGhlIGB2YWx1ZWAgaXMgZmluaXRlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoLTEwMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMTAnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKHRydWUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCcnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUlzRmluaXRlKHZhbHVlKSAmJiAhbmF0aXZlSXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAsIGlmIHRoZSBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0LlxuICAgICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgLCBpZiB0aGUgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgICAvLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g4XG4gICAgICAvLyBhbmQgYXZvaWQgYSBWOCBidWdcbiAgICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTFcbiAgICAgIHJldHVybiAhISh2YWx1ZSAmJiBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNOYU5gLCB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIHZhbHVlcy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjEuMi40LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgLCBpZiB0aGUgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIGBOYU5gIGFzIGEgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZlxuICAgICAgLy8gKHBlcmZvcm0gdGhlIFtbQ2xhc3NdXSBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRSlcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgLCBpZiB0aGUgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgLCBpZiB0aGUgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDguNCAqIDUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBudW1iZXJDbGFzcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiBgdmFsdWVgIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTdG9vZ2UobmFtZSwgYWdlKSB7XG4gICAgICogICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAqICAgdGhpcy5hZ2UgPSBhZ2U7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBTdG9vZ2UoJ21vZScsIDQwKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghKHZhbHVlICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG9iamVjdENsYXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YsXG4gICAgICAgICAgb2JqUHJvdG8gPSB0eXBlb2YgdmFsdWVPZiA9PSAnZnVuY3Rpb24nICYmIChvYmpQcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlT2YpKSAmJiBnZXRQcm90b3R5cGVPZihvYmpQcm90byk7XG5cbiAgICAgIHJldHVybiBvYmpQcm90b1xuICAgICAgICA/ICh2YWx1ZSA9PSBvYmpQcm90byB8fCBnZXRQcm90b3R5cGVPZih2YWx1ZSkgPT0gb2JqUHJvdG8pXG4gICAgICAgIDogc2hpbUlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCwgaWYgdGhlIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvbW9lLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cENsYXNzKSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgLCBpZiB0aGUgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdtb2UnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nQ2xhc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAsIGlmIHRoZSBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgbWVyZ2VzIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QocyksIHRoYXRcbiAgICAgKiBkb24ndCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlc1xuICAgICAqIHdpbGwgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuIElmIGEgYGNhbGxiYWNrYCBmdW5jdGlvblxuICAgICAqIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSBleGVjdXRlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIGFuZCBzb3VyY2UgcHJvcGVydGllcy4gSWYgYGNhbGxiYWNrYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIHdpbGwgYmVcbiAgICAgKiBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOyAob2JqZWN0VmFsdWUsIHNvdXJjZVZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc291cmNlMSwgc291cmNlMiwgLi4uXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdpbmcgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZGVlcEluZGljYXRvcl0gSW5kaWNhdGVzIHRoYXQgYHN0YWNrQWAgYW5kIGBzdGFja0JgIGFyZVxuICAgICAqICBhcnJheXMgb2YgdHJhdmVyc2VkIG9iamVjdHMsIGluc3RlYWQgb2Ygc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtLSB7QXJyYXl9IFtzdGFja0E9W11dIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtLSB7QXJyYXl9IFtzdGFja0I9W11dIEFzc29jaWF0ZXMgdmFsdWVzIHdpdGggc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBuYW1lcyA9IHtcbiAgICAgKiAgICdzdG9vZ2VzJzogW1xuICAgICAqICAgICB7ICduYW1lJzogJ21vZScgfSxcbiAgICAgKiAgICAgeyAnbmFtZSc6ICdsYXJyeScgfVxuICAgICAqICAgXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYWdlcyA9IHtcbiAgICAgKiAgICdzdG9vZ2VzJzogW1xuICAgICAqICAgICB7ICdhZ2UnOiA0MCB9LFxuICAgICAqICAgICB7ICdhZ2UnOiA1MCB9XG4gICAgICogICBdXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2UobmFtZXMsIGFnZXMpO1xuICAgICAqIC8vID0+IHsgJ3N0b29nZXMnOiBbeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfSwgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9XSB9XG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IHtcbiAgICAgKiAgICdmcnVpdHMnOiBbJ2FwcGxlJ10sXG4gICAgICogICAndmVnZXRhYmxlcyc6IFsnYmVldCddXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlckZvb2QgPSB7XG4gICAgICogICAnZnJ1aXRzJzogWydiYW5hbmEnXSxcbiAgICAgKiAgICd2ZWdldGFibGVzJzogWydjYXJyb3QnXVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKGZvb2QsIG90aGVyRm9vZCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAqICAgcmV0dXJuIF8uaXNBcnJheShhKSA/IGEuY29uY2F0KGIpIDogdW5kZWZpbmVkO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ZydWl0cyc6IFsnYXBwbGUnLCAnYmFuYW5hJ10sICd2ZWdldGFibGVzJzogWydiZWV0JywgJ2NhcnJvdF0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKG9iamVjdCwgc291cmNlLCBkZWVwSW5kaWNhdG9yKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gMjtcblxuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoZGVlcEluZGljYXRvciA9PT0gaW5kaWNhdG9yT2JqZWN0KSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3NbM10sXG4gICAgICAgICAgICBzdGFja0EgPSBhcmdzWzRdLFxuICAgICAgICAgICAgc3RhY2tCID0gYXJnc1s1XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbml0ZWRTdGFjayA9IHRydWU7XG4gICAgICAgIHN0YWNrQSA9IGdldEFycmF5KCk7XG4gICAgICAgIHN0YWNrQiA9IGdldEFycmF5KCk7XG5cbiAgICAgICAgLy8gYWxsb3dzIHdvcmtpbmcgd2l0aCBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAgd2l0aG91dFxuICAgICAgICAvLyB1c2luZyB0aGVpciBgY2FsbGJhY2tgIGFyZ3VtZW50cywgYGluZGV4fGtleWAgYW5kIGBjb2xsZWN0aW9uYFxuICAgICAgICBpZiAodHlwZW9mIGRlZXBJbmRpY2F0b3IgIT0gJ251bWJlcicpIHtcbiAgICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gMyAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAyXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soYXJnc1stLWxlbmd0aCAtIDFdLCBhcmdzW2xlbmd0aC0tXSwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiB0eXBlb2YgYXJnc1tsZW5ndGggLSAxXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2FsbGJhY2sgPSBhcmdzWy0tbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgKGlzQXJyYXkoYXJnc1tpbmRleF0pID8gZm9yRWFjaCA6IGZvck93bikoYXJnc1tpbmRleF0sIGZ1bmN0aW9uKHNvdXJjZSwga2V5KSB7XG4gICAgICAgICAgdmFyIGZvdW5kLFxuICAgICAgICAgICAgICBpc0FycixcbiAgICAgICAgICAgICAgcmVzdWx0ID0gc291cmNlLFxuICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHNvdXJjZSAmJiAoKGlzQXJyID0gaXNBcnJheShzb3VyY2UpKSB8fCBpc1BsYWluT2JqZWN0KHNvdXJjZSkpKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBtZXJnaW5nIHByZXZpb3VzbHkgbWVyZ2VkIGN5Y2xpYyBzb3VyY2VzXG4gICAgICAgICAgICB2YXIgc3RhY2tMZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgaWYgKChmb3VuZCA9IHN0YWNrQVtzdGFja0xlbmd0aF0gPT0gc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhY2tCW3N0YWNrTGVuZ3RoXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICB2YXIgaXNTaGFsbG93O1xuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoKGlzU2hhbGxvdyA9IHR5cGVvZiByZXN1bHQgIT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGlzQXJyXG4gICAgICAgICAgICAgICAgICA/IChpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10pXG4gICAgICAgICAgICAgICAgICA6IChpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDoge30pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGFkZCBgc291cmNlYCBhbmQgYXNzb2NpYXRlZCBgdmFsdWVgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgICAgICAgICAgICBzdGFja0EucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgICBzdGFja0IucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cylcbiAgICAgICAgICAgICAgaWYgKCFpc1NoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1lcmdlKHZhbHVlLCBzb3VyY2UsIGluZGljYXRvck9iamVjdCwgY2FsbGJhY2ssIHN0YWNrQSwgc3RhY2tCKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBzb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluaXRlZFN0YWNrKSB7XG4gICAgICAgIHJlbGVhc2VBcnJheShzdGFja0EpO1xuICAgICAgICByZWxlYXNlQXJyYXkoc3RhY2tCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYG9iamVjdGAgZXhjbHVkaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgICAqIHByb3BlcnR5IG5hbWVzLiBJZiBhIGBjYWxsYmFja2AgZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkXG4gICAgICogZm9yIGVhY2ggcHJvcGVydHkgaW4gdGhlIGBvYmplY3RgLCBvbWl0dGluZyB0aGUgcHJvcGVydGllcyBgY2FsbGJhY2tgXG4gICAgICogcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrfFtwcm9wMSwgcHJvcDIsIC4uLl0gVGhlIHByb3BlcnRpZXMgdG8gb21pdFxuICAgICAqICBvciB0aGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGhvdXQgdGhlIG9taXR0ZWQgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScgfVxuICAgICAqXG4gICAgICogXy5vbWl0KHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnbW9lJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcHMgPSBjb25jYXQuYXBwbHkoYXJyYXlSZWYsIG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICB9XG4gICAgICBmb3JJbihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBpZiAoaXNGdW5jXG4gICAgICAgICAgICAgID8gIWNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdClcbiAgICAgICAgICAgICAgOiBpbmRleE9mKHByb3BzLCBrZXkpIDwgMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0d28gZGltZW5zaW9uYWwgYXJyYXkgb2YgdGhlIGdpdmVuIG9iamVjdCdzIGtleS12YWx1ZSBwYWlycyxcbiAgICAgKiBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBuZXcgYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhaXJzKHsgJ21vZSc6IDMwLCAnbGFycnknOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbWydtb2UnLCAzMF0sIFsnbGFycnknLCA0MF1dIChvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBjb21wb3NlZCBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2YgcHJvcGVydHlcbiAgICAgKiBuYW1lcy4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggcHJvcGVydHkgaW4gdGhlXG4gICAgICogYG9iamVjdGAsIHBpY2tpbmcgdGhlIHByb3BlcnRpZXMgYGNhbGxiYWNrYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBgY2FsbGJhY2tgXG4gICAgICogaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufFN0cmluZ30gY2FsbGJhY2t8W3Byb3AxLCBwcm9wMiwgLi4uXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBpdGVyYXRpb24gb3IgcHJvcGVydGllcyB0byBwaWNrLCBlaXRoZXIgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXJyYXlzLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIHByb3BlcnRpZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ21vZScsICdfdXNlcmlkJzogJ21vZTEnIH0sICduYW1lJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdtb2UnIH1cbiAgICAgKlxuICAgICAqIF8ucGljayh7ICduYW1lJzogJ21vZScsICdfdXNlcmlkJzogJ21vZTEnIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkuY2hhckF0KDApICE9ICdfJztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2sob2JqZWN0LCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgcHJvcHMgPSBjb25jYXQuYXBwbHkoYXJyYXlSZWYsIG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSksXG4gICAgICAgICAgICBsZW5ndGggPSBpc09iamVjdChvYmplY3QpID8gcHJvcHMubGVuZ3RoIDogMDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYCwgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBhbiBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBlbGVtZW50c1xuICAgICAqIHRocm91Z2ggdGhlIGBjYWxsYmFja2AsIHdpdGggZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbiBwb3RlbnRpYWxseSBtdXRhdGluZ1xuICAgICAqIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkXG4gICAgICogd2l0aCBmb3VyIGFyZ3VtZW50czsgKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNxdWFyZXMgPSBfLnRyYW5zZm9ybShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdLCBmdW5jdGlvbihyZXN1bHQsIG51bSkge1xuICAgICAqICAgbnVtICo9IG51bTtcbiAgICAgKiAgIGlmIChudW0gJSAyKSB7XG4gICAgICogICAgIHJldHVybiByZXN1bHQucHVzaChudW0pIDwgMztcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgOSwgMjVdXG4gICAgICpcbiAgICAgKiB2YXIgbWFwcGVkID0gXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sIGZ1bmN0aW9uKHJlc3VsdCwgbnVtLCBrZXkpIHtcbiAgICAgKiAgIHJlc3VsdFtrZXldID0gbnVtICogMztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMywgJ2InOiA2LCAnYyc6IDkgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpO1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDQpO1xuXG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgcHJvdG8gPSBjdG9yICYmIGN0b3IucHJvdG90eXBlO1xuXG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBjcmVhdGVPYmplY3QocHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnIgPyBmb3JFYWNoIDogZm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHByb3BzID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gb2JqZWN0W3Byb3BzW2luZGV4XV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXhlcywgb3Iga2V5cywgb2YgdGhlXG4gICAgICogYGNvbGxlY3Rpb25gLiBJbmRleGVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzXG4gICAgICogb2YgaW5kZXhlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxOdW1iZXJ8U3RyaW5nfSBbaW5kZXgxLCBpbmRleDIsIC4uLl0gVGhlIGluZGV4ZXMgb2ZcbiAgICAgKiAgYGNvbGxlY3Rpb25gIHRvIHJldHJpZXZlLCBlaXRoZXIgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXJyYXlzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICAgICAqICBwcm92aWRlZCBpbmRleGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmF0KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sIFswLCAyLCA0XSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnLCAnZSddXG4gICAgICpcbiAgICAgKiBfLmF0KFsnbW9lJywgJ2xhcnJ5JywgJ2N1cmx5J10sIDAsIDIpO1xuICAgICAqIC8vID0+IFsnbW9lJywgJ2N1cmx5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdChjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBwcm9wcyA9IGNvbmNhdC5hcHBseShhcnJheVJlZiwgbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gY29sbGVjdGlvbltwcm9wc1tpbmRleF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBnaXZlbiBgdGFyZ2V0YCBlbGVtZW50IGlzIHByZXNlbnQgaW4gYSBgY29sbGVjdGlvbmAgdXNpbmcgc3RyaWN0XG4gICAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgICAqIGFzIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGluY2x1ZGVcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHRhcmdldCBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB0YXJnZXRgIGVsZW1lbnQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5jb250YWlucyh7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LCAnbW9lJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb250YWlucygnY3VybHknLCAndXInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgbGVuZ3RoICsgZnJvbUluZGV4KSA6IGZyb21JbmRleCkgfHwgMDtcbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSAoaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgICA/IGNvbGxlY3Rpb24uaW5kZXhPZih0YXJnZXQsIGZyb21JbmRleClcbiAgICAgICAgICA6IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpXG4gICAgICAgICkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICgrK2luZGV4ID49IGZyb21JbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gdmFsdWUgPT09IHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyByZXR1cm5lZCBmcm9tIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIHRoZVxuICAgICAqIGBjb2xsZWN0aW9uYCB0aHJvdWdoIHRoZSBnaXZlbiBgY2FsbGJhY2tgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZiBlYWNoIGtleVxuICAgICAqIGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgdGhlIGBjYWxsYmFja2AuIFRoZSBgY2FsbGJhY2tgXG4gICAgICogaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fFN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlXG4gICAgICogIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs0LjMsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY291bnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAga2V5ID0gU3RyaW5nKGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKTtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0rKyA6IHJlc3VsdFtrZXldID0gMSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBgY2FsbGJhY2tgIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYVxuICAgICAqIGBjb2xsZWN0aW9uYC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbGxcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fFN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlXG4gICAgICogIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShzdG9vZ2VzLCAnYWdlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5ldmVyeShzdG9vZ2VzLCB7ICdhZ2UnOiA1MCB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSAhIWNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gKHJlc3VsdCA9ICEhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGFtaW5lcyBlYWNoIGVsZW1lbnQgaW4gYSBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiB0aGUgYGNhbGxiYWNrYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAYWxpYXMgc2VsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxTdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgICAqIC8vID0+IFsyLCA0LCA2XVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2FwcGxlJywgICdvcmdhbmljJzogZmFsc2UsICd0eXBlJzogJ2ZydWl0JyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdjYXJyb3QnLCAnb3JnYW5pYyc6IHRydWUsICAndHlwZSc6ICd2ZWdldGFibGUnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maWx0ZXIoZm9vZCwgJ29yZ2FuaWMnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdjYXJyb3QnLCAnb3JnYW5pYyc6IHRydWUsICd0eXBlJzogJ3ZlZ2V0YWJsZScgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlsdGVyKGZvb2QsIHsgJ3R5cGUnOiAnZnJ1aXQnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2FwcGxlJywgJ29yZ2FuaWMnOiBmYWxzZSwgJ3R5cGUnOiAnZnJ1aXQnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sbGVjdGlvbltpbmRleF07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4YW1pbmVzIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCB0aGF0IHRoZSBgY2FsbGJhY2tgXG4gICAgICogcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRldGVjdCwgZmluZFdoZXJlXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxTdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kKFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIHZhciBmb29kID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdhcHBsZScsICAnb3JnYW5pYyc6IGZhbHNlLCAndHlwZSc6ICdmcnVpdCcgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFuYW5hJywgJ29yZ2FuaWMnOiB0cnVlLCAgJ3R5cGUnOiAnZnJ1aXQnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2JlZXQnLCAgICdvcmdhbmljJzogZmFsc2UsICd0eXBlJzogJ3ZlZ2V0YWJsZScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpbmQoZm9vZCwgeyAndHlwZSc6ICd2ZWdldGFibGUnIH0pO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnYmVldCcsICdvcmdhbmljJzogZmFsc2UsICd0eXBlJzogJ3ZlZ2V0YWJsZScgfVxuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5maW5kKGZvb2QsICdvcmdhbmljJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdiYW5hbmEnLCAnb3JnYW5pYyc6IHRydWUsICd0eXBlJzogJ2ZydWl0JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIGBjb2xsZWN0aW9uYCwgZXhlY3V0aW5nIHRoZSBgY2FsbGJhY2tgIGZvciBlYWNoIGVsZW1lbnQgaW5cbiAgICAgKiB0aGUgYGNvbGxlY3Rpb25gLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gICAgICogYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdHxTdHJpbmd9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkuZm9yRWFjaChhbGVydCkuam9pbignLCcpO1xuICAgICAqIC8vID0+IGFsZXJ0cyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnb25lJzogMSwgJ3R3byc6IDIsICd0aHJlZSc6IDMgfSwgYWxlcnQpO1xuICAgICAqIC8vID0+IGFsZXJ0cyBlYWNoIG51bWJlciB2YWx1ZSAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgdGhpc0FyZyA9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIHJldHVybmVkIGZyb20gcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgdGhlXG4gICAgICogYGNvbGxlY3Rpb25gIHRocm91Z2ggdGhlIGBjYWxsYmFja2AuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mIGVhY2gga2V5IGlzXG4gICAgICogYW4gYXJyYXkgb2YgZWxlbWVudHMgcGFzc2VkIHRvIGBjYWxsYmFja2AgdGhhdCByZXR1cm5lZCB0aGUga2V5LiBUaGUgYGNhbGxiYWNrYFxuICAgICAqIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fFN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlXG4gICAgICogIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLmZsb29yKG51bSk7IH0pO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNC4yLCA2LjEsIDYuNF0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gdGhpcy5mbG9vcihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cEJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG5cbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBrZXkgPSBTdHJpbmcoY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbikpO1xuICAgICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSA6IHJlc3VsdFtrZXldID0gW10pLnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBuYW1lZCBieSBgbWV0aG9kTmFtZWAgb24gZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAsXG4gICAgICogcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogd2lsbCBiZSBwYXNzZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGxcbiAgICAgKiBiZSBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW2FyZzEsIGFyZzIsIC4uLl0gQXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnZva2UoY29sbGVjdGlvbiwgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IChpc0Z1bmMgPyBtZXRob2ROYW1lIDogdmFsdWVbbWV0aG9kTmFtZV0pLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gXG4gICAgICogdGhyb3VnaCB0aGUgYGNhbGxiYWNrYC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBjb2xsZWN0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxTdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGBjYWxsYmFja2AgZXhlY3V0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDldXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIDM7IH0pO1xuICAgICAqIC8vID0+IFszLCA2LCA5XSAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5tYXAoc3Rvb2dlcywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ21vZScsICdsYXJyeSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5sZW5ndGggOiAwO1xuXG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gY2FsbGJhY2soY29sbGVjdGlvbltpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmVzdWx0WysraW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYW4gYGFycmF5YC4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsXG4gICAgICogaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgYGFycmF5YCB0byBnZW5lcmF0ZSB0aGVcbiAgICAgKiBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxTdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXgoc3Rvb2dlcywgZnVuY3Rpb24oc3Rvb2dlKSB7IHJldHVybiBzdG9vZ2UuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLm1heChzdG9vZ2VzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGNvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgICBpZiAoIWNhbGxiYWNrICYmIGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayA9ICghY2FsbGJhY2sgJiYgaXNTdHJpbmcoY29sbGVjdGlvbikpXG4gICAgICAgICAgPyBjaGFyQXRDYWxsYmFja1xuICAgICAgICAgIDogbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcblxuICAgICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICBpZiAoY3VycmVudCA+IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYW4gYGFycmF5YC4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsXG4gICAgICogaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgYGFycmF5YCB0byBnZW5lcmF0ZSB0aGVcbiAgICAgKiBjcml0ZXJpb24gYnkgd2hpY2ggdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgXG4gICAgICogYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxTdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5taW4oc3Rvb2dlcywgZnVuY3Rpb24oc3Rvb2dlKSB7IHJldHVybiBzdG9vZ2UuYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9O1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5taW4oc3Rvb2dlcywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgICByZXN1bHQgPSBjb21wdXRlZDtcblxuICAgICAgaWYgKCFjYWxsYmFjayAmJiBpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgPSAoIWNhbGxiYWNrICYmIGlzU3RyaW5nKGNvbGxlY3Rpb24pKVxuICAgICAgICAgID8gY2hhckF0Q2FsbGJhY2tcbiAgICAgICAgICA6IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG5cbiAgICAgICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPCBjb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJyZW50O1xuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGFsbCBlbGVtZW50cyBpbiB0aGUgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUgRnVuY3Rpb25cbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gcGx1Y2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0b29nZXMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGx1Y2soc3Rvb2dlcywgJ25hbWUnKTtcbiAgICAgKiAvLyA9PiBbJ21vZScsICdsYXJyeSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbiwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjb2xsZWN0aW9uW2luZGV4XVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgfHwgbWFwKGNvbGxlY3Rpb24sIHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGEgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAgdGhyb3VnaCB0aGUgYGNhbGxiYWNrYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogYGNhbGxiYWNrYCBleGVjdXRpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZXhlY3V0aW9uLlxuICAgICAqIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90IHBhc3NlZCwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGBjb2xsZWN0aW9uYCB3aWxsIGJlXG4gICAgICogdXNlZCBhcyB0aGUgaW5pdGlhbCBgYWNjdW11bGF0b3JgIHZhbHVlLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOyAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGZvbGRsLCBpbmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzdW0gPSBfLnJlZHVjZShbMSwgMiwgM10sIGZ1bmN0aW9uKHN1bSwgbnVtKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbnVtO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIHZhciBtYXBwZWQgPSBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgZnVuY3Rpb24ocmVzdWx0LCBudW0sIGtleSkge1xuICAgICAqICAgcmVzdWx0W2tleV0gPSBudW0gKiAzO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnYSc6IDMsICdiJzogNiwgJ2MnOiA5IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoIWNvbGxlY3Rpb24pIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAobm9hY2N1bSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY29sbGVjdGlvblsrK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvck93bihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IG5vYWNjdW1cbiAgICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8ucmVkdWNlYCwgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBhXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBmb2xkclxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW2FjY3VtdWxhdG9yXSBJbml0aWFsIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxpc3QgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICogdmFyIGZsYXQgPSBfLnJlZHVjZVJpZ2h0KGxpc3QsIGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgY2FsbGJhY2ssIGFjY3VtdWxhdG9yLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXRlcmFibGUgPSBjb2xsZWN0aW9uLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbm9hY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgNCk7XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpbmRleCA9IHByb3BzID8gcHJvcHNbLS1sZW5ndGhdIDogLS1sZW5ndGg7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICAgID8gKG5vYWNjdW0gPSBmYWxzZSwgaXRlcmFibGVbaW5kZXhdKVxuICAgICAgICAgIDogY2FsbGJhY2soYWNjdW11bGF0b3IsIGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGFcbiAgICAgKiBgY29sbGVjdGlvbmAgdGhhdCBgY2FsbGJhY2tgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8U3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGVcbiAgICAgKiAgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBkaWQgKipub3QqKiBwYXNzIHRoZVxuICAgICAqICBjYWxsYmFjayBjaGVjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9kZHMgPSBfLnJlamVjdChbMSwgMiwgMywgNCwgNSwgNl0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICUgMiA9PSAwOyB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdhcHBsZScsICAnb3JnYW5pYyc6IGZhbHNlLCAndHlwZSc6ICdmcnVpdCcgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnY2Fycm90JywgJ29yZ2FuaWMnOiB0cnVlLCAgJ3R5cGUnOiAndmVnZXRhYmxlJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGZvb2QsICdvcmdhbmljJyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYXBwbGUnLCAnb3JnYW5pYyc6IGZhbHNlLCAndHlwZSc6ICdmcnVpdCcgfV1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVqZWN0KGZvb2QsIHsgJ3R5cGUnOiAnZnJ1aXQnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2NhcnJvdCcsICdvcmdhbmljJzogdHJ1ZSwgJ3R5cGUnOiAndmVnZXRhYmxlJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuICFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCBgYXJyYXlgIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIEZpc2hlci1ZYXRlcyBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgNiwgMywgNSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByYW5kID0gZmxvb3IobmF0aXZlUmFuZG9tKCkgKiAoKytpbmRleCArIDEpKTtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdFtyYW5kXTtcbiAgICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBgY29sbGVjdGlvbi5sZW5ndGhgIGZvciBhcnJheXNcbiAgICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgnY3VybHknKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDoga2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBgY2FsbGJhY2tgIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgZm9yICoqYW55KiogZWxlbWVudCBvZiBhXG4gICAgICogYGNvbGxlY3Rpb25gLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIHBhc3NpbmcgdmFsdWUsIGFuZFxuICAgICAqIGRvZXMgbm90IGl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGBjb2xsZWN0aW9uYC4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBhbnlcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fFN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlXG4gICAgICogIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgY2FsbGJhY2sgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYXBwbGUnLCAgJ29yZ2FuaWMnOiBmYWxzZSwgJ3R5cGUnOiAnZnJ1aXQnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2NhcnJvdCcsICdvcmdhbmljJzogdHJ1ZSwgICd0eXBlJzogJ3ZlZ2V0YWJsZScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoZm9vZCwgJ29yZ2FuaWMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvbWUoZm9vZCwgeyAndHlwZSc6ICdtZWF0JyB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKChyZXN1bHQgPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JPd24oY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuICEocmVzdWx0ID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gIHRocm91Z2ggdGhlIGBjYWxsYmFja2AuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgd2lsbCBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxTdHJpbmd9IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICAgKiAgaXRlcmF0aW9uLiBJZiBhIHByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZVxuICAgICAqICBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICAgKiAvLyA9PiBbMywgMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uc29ydEJ5KFsnYmFuYW5hJywgJ3N0cmF3YmVycnknLCAnYXBwbGUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IFsnYXBwbGUnLCAnYmFuYW5hJywgJ3N0cmF3YmVycnknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheSh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInID8gbGVuZ3RoIDogMCk7XG5cbiAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgb2JqZWN0ID0gcmVzdWx0WysraW5kZXhdID0gZ2V0T2JqZWN0KCk7XG4gICAgICAgIG9iamVjdC5jcml0ZXJpYSA9IGNhbGxiYWNrKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgICBvYmplY3QuaW5kZXggPSBpbmRleDtcbiAgICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICB9KTtcblxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgIHJlc3VsdC5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBvYmplY3QudmFsdWU7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGBjb2xsZWN0aW9uYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cykuc2xpY2UoMSk7IH0pKDEsIDIsIDMsIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzbGljZShjb2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhhbWluZXMgZWFjaCBlbGVtZW50IGluIGEgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogdGhhdCBoYXZlIHRoZSBnaXZlbiBgcHJvcGVydGllc2AuIFdoZW4gY2hlY2tpbmcgYHByb3BlcnRpZXNgLCB0aGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50XG4gICAgICogdG8gZWFjaCBvdGhlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIEZ1bmN0aW9uXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgZ2l2ZW4gYHByb3BlcnRpZXNgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy53aGVyZShzdG9vZ2VzLCB7ICdhZ2UnOiA0MCB9KTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfV1cbiAgICAgKi9cbiAgICB2YXIgd2hlcmUgPSBmaWx0ZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyBvZiBgYXJyYXlgIHJlbW92ZWQuIFRoZSB2YWx1ZXNcbiAgICAgKiBgZmFsc2VgLCBgbnVsbGAsIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCBhbmQgYE5hTmAgYXJlIGFsbCBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIGVsZW1lbnRzIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBhcnJheXNcbiAgICAgKiB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheTEsIGFycmF5MiwgLi4uXSBBcnJheXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGBhcnJheWAgZWxlbWVudHMgbm90IHByZXNlbnQgaW4gdGhlXG4gICAgICogIG90aGVyIGFycmF5cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsxLCAyLCAzLCA0LCA1XSwgWzUsIDIsIDEwXSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGlmZmVyZW5jZShhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhPZiA9IGdldEluZGV4T2YoKSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgc2VlbiA9IGNvbmNhdC5hcHBseShhcnJheVJlZiwgbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgdmFyIGlzTGFyZ2UgPSBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzaWNJbmRleE9mO1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZShzZWVuKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgICBzZWVuID0gY2FjaGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChpbmRleE9mKHNlZW4sIHZhbHVlKSA8IDApIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHJlbGVhc2VPYmplY3Qoc2Vlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYF8uZmluZGAsIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mXG4gICAgICogdGhlIGVsZW1lbnQgdGhhdCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLCBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fFN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlXG4gICAgICogIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleChbJ2FwcGxlJywgJ2JhbmFuYScsICdiZWV0J10sIGZ1bmN0aW9uKGZvb2QpIHtcbiAgICAgKiAgIHJldHVybiAvXmIvLnRlc3QoZm9vZCk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGBhcnJheWAuIElmIGEgbnVtYmVyIGBuYCBpcyBwYXNzZWQsIHRoZSBmaXJzdFxuICAgICAqIGBuYCBlbGVtZW50cyBvZiB0aGUgYGFycmF5YCBhcmUgcmV0dXJuZWQuIElmIGEgYGNhbGxiYWNrYCBmdW5jdGlvbiBpcyBwYXNzZWQsXG4gICAgICogZWxlbWVudHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlIGBjYWxsYmFja2BcbiAgICAgKiByZXR1cm5zIHRydXRoeS4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBoZWFkLCB0YWtlXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdHxOdW1iZXJ8U3RyaW5nfSBbY2FsbGJhY2t8bl0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yXG4gICAgICogIG9iamVjdCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIlxuICAgICAqICBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQocykgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maXJzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlyc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2JhbmFuYScsICdvcmdhbmljJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiZWV0JywgICAnb3JnYW5pYyc6IGZhbHNlIH0sXG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uZmlyc3QoZm9vZCwgJ29yZ2FuaWMnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiYW5hbmEnLCAnb3JnYW5pYyc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdhcHBsZScsICAndHlwZSc6ICdmcnVpdCcgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFuYW5hJywgJ3R5cGUnOiAnZnJ1aXQnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2JlZXQnLCAgICd0eXBlJzogJ3ZlZ2V0YWJsZScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmZpcnN0KGZvb2QsIHsgJ3R5cGUnOiAnZnJ1aXQnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2FwcGxlJywgJ3R5cGUnOiAnZnJ1aXQnIH0sIHsgJ25hbWUnOiAnYmFuYW5hJywgJ3R5cGUnOiAnZnJ1aXQnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlyc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbiA9IGNhbGxiYWNrO1xuICAgICAgICAgIGlmIChuID09IG51bGwgfHwgdGhpc0FyZykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2UoYXJyYXksIDAsIG5hdGl2ZU1pbihuYXRpdmVNYXgoMCwgbiksIGxlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYGlzU2hhbGxvd2BcbiAgICAgKiBpcyB0cnV0aHksIGBhcnJheWAgd2lsbCBvbmx5IGJlIGZsYXR0ZW5lZCBhIHNpbmdsZSBsZXZlbC4gSWYgYGNhbGxiYWNrYFxuICAgICAqIGlzIHBhc3NlZCwgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgaXMgcGFzc2VkIHRocm91Z2ggYSBgY2FsbGJhY2tgIGJlZm9yZVxuICAgICAqIGZsYXR0ZW5pbmcuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOyAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTaGFsbG93PWZhbHNlXSBBIGZsYWcgdG8gaW5kaWNhdGUgb25seSBmbGF0dGVuaW5nIGEgc2luZ2xlIGxldmVsLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fFN0cmluZ30gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlclxuICAgICAqICBpdGVyYXRpb24uIElmIGEgcHJvcGVydHkgbmFtZSBvciBvYmplY3QgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlXG4gICAgICogIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMl0sIFszLCBbWzRdXV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0sIHRydWUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbWzRdXV07XG4gICAgICpcbiAgICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnY3VybHknLCAncXVvdGVzJzogWydPaCwgYSB3aXNlIGd1eSwgZWg/JywgJ1BvaWZlY3QhJ10gfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ3F1b3Rlcyc6IFsnU3ByZWFkIG91dCEnLCAnWW91IGtudWNrbGVoZWFkISddIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLnBsdWNrXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5mbGF0dGVuKHN0b29nZXMsICdxdW90ZXMnKTtcbiAgICAgKiAvLyA9PiBbJ09oLCBhIHdpc2UgZ3V5LCBlaD8nLCAnUG9pZmVjdCEnLCAnU3ByZWFkIG91dCEnLCAnWW91IGtudWNrbGVoZWFkISddXG4gICAgICovXG4gICAgdmFyIGZsYXR0ZW4gPSBvdmVybG9hZFdyYXBwZXIoZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgaXNTaGFsbG93LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdCwgaXNTaGFsbG93ID8gdmFsdWUgOiBmbGF0dGVuKHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBgYXJyYXlgIGlzIGFscmVhZHlcbiAgICAgKiBzb3J0ZWQsIHBhc3NpbmcgYHRydWVgIGZvciBgZnJvbUluZGV4YCB3aWxsIHJ1biBhIGZhc3RlciBiaW5hcnkgc2VhcmNoLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtCb29sZWFufE51bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20gb3IgYHRydWVgIHRvXG4gICAgICogIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAxLCAyLCAyLCAzLCAzXSwgMiwgdHJ1ZSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXkgPyBiYXNpY0luZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIDogLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC4gSWYgYSBudW1iZXIgYG5gIGlzIHBhc3NlZCwgdGhlXG4gICAgICogbGFzdCBgbmAgZWxlbWVudHMgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIHJlc3VsdC4gSWYgYSBgY2FsbGJhY2tgIGZ1bmN0aW9uXG4gICAgICogaXMgcGFzc2VkLCBlbGVtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheSBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgcmVzdWx0XG4gICAgICogYXMgbG9uZyBhcyB0aGUgYGNhbGxiYWNrYCByZXR1cm5zIHRydXRoeS4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG9cbiAgICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8TnVtYmVyfFN0cmluZ30gW2NhbGxiYWNrfG49MV0gVGhlIGZ1bmN0aW9uIGNhbGxlZFxuICAgICAqICBwZXIgZWxlbWVudCBvciB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuIElmIGEgcHJvcGVydHkgbmFtZSBvclxuICAgICAqICBvYmplY3QgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGEgXCJfLnBsdWNrXCIgb3IgXCJfLndoZXJlXCJcbiAgICAgKiAgc3R5bGUgY2FsbGJhY2ssIHJlc3BlY3RpdmVseS5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10sIGZ1bmN0aW9uKG51bSkge1xuICAgICAqICAgcmV0dXJuIG51bSA+IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmVldCcsICAgJ29yZ2FuaWMnOiBmYWxzZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdjYXJyb3QnLCAnb3JnYW5pYyc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmluaXRpYWwoZm9vZCwgJ29yZ2FuaWMnKTtcbiAgICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdiZWV0JywgICAnb3JnYW5pYyc6IGZhbHNlIH1dXG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYmFuYW5hJywgJ3R5cGUnOiAnZnJ1aXQnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2JlZXQnLCAgICd0eXBlJzogJ3ZlZ2V0YWJsZScgfSxcbiAgICAgKiAgIHsgJ25hbWUnOiAnY2Fycm90JywgJ3R5cGUnOiAndmVnZXRhYmxlJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy53aGVyZVwiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8uaW5pdGlhbChmb29kLCB7ICd0eXBlJzogJ3ZlZ2V0YWJsZScgfSk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnYmFuYW5hJywgJ3R5cGUnOiAnZnJ1aXQnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnbnVtYmVyJyAmJiBjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgICB3aGlsZSAoaW5kZXgtLSAmJiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSAoY2FsbGJhY2sgPT0gbnVsbCB8fCB0aGlzQXJnKSA/IDEgOiBjYWxsYmFjayB8fCBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCAwLCBuYXRpdmVNaW4obmF0aXZlTWF4KDAsIGxlbmd0aCAtIG4pLCBsZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCB0aGUgcGFzc2VkLWluIGFycmF5cyB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICAgKiBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5MSwgYXJyYXkyLCAuLi5dIEFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB1bmlxdWUgZWxlbWVudHMgdGhhdCBhcmUgcHJlc2VudFxuICAgICAqICBpbiAqKmFsbCoqIG9mIHRoZSBhcnJheXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsxLCAyLCAzXSwgWzEwMSwgMiwgMSwgMTBdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihhcnJheSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGNhY2hlcyA9IGdldEFycmF5KCksXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleE9mID0gZ2V0SW5kZXhPZigpLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gZ2V0QXJyYXkoKTtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIGNhY2hlc1thcmdzSW5kZXhdID0gaW5kZXhPZiA9PT0gYmFzaWNJbmRleE9mICYmXG4gICAgICAgICAgKHZhbHVlID8gdmFsdWUubGVuZ3RoIDogMCkgPj0gbGFyZ2VBcnJheVNpemUgJiZcbiAgICAgICAgICBjcmVhdGVDYWNoZShhcmdzSW5kZXggPyBhcmdzW2FyZ3NJbmRleF0gOiBzZWVuKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY2FjaGVzWzBdO1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgICAgICBpZiAoKGNhY2hlID8gY2FjaGVJbmRleE9mKGNhY2hlLCB2YWx1ZSkgOiBpbmRleE9mKHNlZW4sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgYXJnc0luZGV4ID0gYXJnc0xlbmd0aDtcbiAgICAgICAgICAoY2FjaGUgfHwgc2VlbikucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgd2hpbGUgKC0tYXJnc0luZGV4KSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlc1thcmdzSW5kZXhdO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA/IGNhY2hlSW5kZXhPZihjYWNoZSwgdmFsdWUpIDogaW5kZXhPZihhcmdzW2FyZ3NJbmRleF0sIHZhbHVlKSkgPCAwKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgY2FjaGUgPSBjYWNoZXNbYXJnc0xlbmd0aF07XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgIHJlbGVhc2VPYmplY3QoY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWxlYXNlQXJyYXkoY2FjaGVzKTtcbiAgICAgIHJlbGVhc2VBcnJheShzZWVuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBgYXJyYXlgLiBJZiBhIG51bWJlciBgbmAgaXMgcGFzc2VkLCB0aGVcbiAgICAgKiBsYXN0IGBuYCBlbGVtZW50cyBvZiB0aGUgYGFycmF5YCBhcmUgcmV0dXJuZWQuIElmIGEgYGNhbGxiYWNrYCBmdW5jdGlvblxuICAgICAqIGlzIHBhc3NlZCwgZWxlbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkgYXJlIHJldHVybmVkIGFzIGxvbmcgYXMgdGhlXG4gICAgICogYGNhbGxiYWNrYCByZXR1cm5zIHRydXRoeS4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7KHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBJZiBhIHByb3BlcnR5IG5hbWUgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ucGx1Y2tcIiBzdHlsZVxuICAgICAqIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIElmIGFuIG9iamVjdCBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy53aGVyZVwiIHN0eWxlIGNhbGxiYWNrXG4gICAgICogd2lsbCByZXR1cm4gYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGdpdmVuIG9iamVjdCxcbiAgICAgKiBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fE51bWJlcnxTdHJpbmd9IFtjYWxsYmFja3xuXSBUaGUgZnVuY3Rpb24gY2FsbGVkXG4gICAgICogIHBlciBlbGVtZW50IG9yIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50KHMpIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7XG4gICAgICogICByZXR1cm4gbnVtID4gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIHZhciBmb29kID0gW1xuICAgICAqICAgeyAnbmFtZSc6ICdiZWV0JywgICAnb3JnYW5pYyc6IGZhbHNlIH0sXG4gICAgICogICB7ICduYW1lJzogJ2NhcnJvdCcsICdvcmdhbmljJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ubGFzdChmb29kLCAnb3JnYW5pYycpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2NhcnJvdCcsICdvcmdhbmljJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2JhbmFuYScsICd0eXBlJzogJ2ZydWl0JyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiZWV0JywgICAndHlwZSc6ICd2ZWdldGFibGUnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2NhcnJvdCcsICd0eXBlJzogJ3ZlZ2V0YWJsZScgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ud2hlcmVcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLmxhc3QoZm9vZCwgeyAndHlwZSc6ICd2ZWdldGFibGUnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2JlZXQnLCAndHlwZSc6ICd2ZWdldGFibGUnIH0sIHsgJ25hbWUnOiAnY2Fycm90JywgJ3R5cGUnOiAndmVnZXRhYmxlJyB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXksIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgdmFyIG4gPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICBjYWxsYmFjayA9IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG4gPSBjYWxsYmFjaztcbiAgICAgICAgICBpZiAobiA9PSBudWxsIHx8IHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVtsZW5ndGggLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlKGFycmF5LCBuYXRpdmVNYXgoMCwgbGVuZ3RoIC0gbikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBsYXN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCB1c2luZyBzdHJpY3RcbiAgICAgKiBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCBpcyB1c2VkXG4gICAgICogYXMgdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAzLCAxLCAyLCAzXSwgMiwgMyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICBpZiAodHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGluZGV4ICsgZnJvbUluZGV4KSA6IG5hdGl2ZU1pbihmcm9tSW5kZXgsIGluZGV4IC0gMSkpICsgMTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGBlbmRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgcmFuZ2UgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMTApO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCAxMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAzMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNSwgMjAsIDI1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtMTAsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtMywgLTQsIC01LCAtNiwgLTcsIC04LCAtOV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgICAgc3RlcCA9ICtzdGVwIHx8IDE7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBWOCB3aWxsIGF2b2lkIHRoZSBzbG93ZXIgXCJkaWN0aW9uYXJ5XCIgbW9kZVxuICAgICAgLy8gaHR0cDovL3lvdXR1LmJlL1hBcUlwR1U4WlprI3Q9MTdtMjVzXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCkpLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgLCB0aGlzIG1ldGhvZCBnZXRzIGFsbCBidXQgdGhlIGZpcnN0IHZhbHVlIG9mXG4gICAgICogYGFycmF5YC4gSWYgYSBudW1iZXIgYG5gIGlzIHBhc3NlZCwgdGhlIGZpcnN0IGBuYCB2YWx1ZXMgYXJlIGV4Y2x1ZGVkIGZyb21cbiAgICAgKiB0aGUgcmVzdWx0LiBJZiBhIGBjYWxsYmFja2AgZnVuY3Rpb24gaXMgcGFzc2VkLCBlbGVtZW50cyBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICogb2YgdGhlIGFycmF5IGFyZSBleGNsdWRlZCBmcm9tIHRoZSByZXN1bHQgYXMgbG9uZyBhcyB0aGUgYGNhbGxiYWNrYCByZXR1cm5zXG4gICAgICogdHJ1dGh5LiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIGRyb3AsIHRhaWxcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258T2JqZWN0fE51bWJlcnxTdHJpbmd9IFtjYWxsYmFja3xuPTFdIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICAgKiAgcGVyIGVsZW1lbnQgb3IgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLiBJZiBhIHByb3BlcnR5IG5hbWUgb3JcbiAgICAgKiAgb2JqZWN0IGlzIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhIFwiXy5wbHVja1wiIG9yIFwiXy53aGVyZVwiXG4gICAgICogIHN0eWxlIGNhbGxiYWNrLCByZXNwZWN0aXZlbHkuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5yZXN0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnJlc3QoWzEsIDIsIDNdLCBmdW5jdGlvbihudW0pIHtcbiAgICAgKiAgIHJldHVybiBudW0gPCAzO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogdmFyIGZvb2QgPSBbXG4gICAgICogICB7ICduYW1lJzogJ2JhbmFuYScsICdvcmdhbmljJzogdHJ1ZSB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiZWV0JywgICAnb3JnYW5pYyc6IGZhbHNlIH0sXG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIFwiXy5wbHVja1wiIGNhbGxiYWNrIHNob3J0aGFuZFxuICAgICAqIF8ucmVzdChmb29kLCAnb3JnYW5pYycpO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2JlZXQnLCAnb3JnYW5pYyc6IGZhbHNlIH1dXG4gICAgICpcbiAgICAgKiB2YXIgZm9vZCA9IFtcbiAgICAgKiAgIHsgJ25hbWUnOiAnYXBwbGUnLCAgJ3R5cGUnOiAnZnJ1aXQnIH0sXG4gICAgICogICB7ICduYW1lJzogJ2JhbmFuYScsICd0eXBlJzogJ2ZydWl0JyB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdiZWV0JywgICAndHlwZSc6ICd2ZWdldGFibGUnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kXG4gICAgICogXy5yZXN0KGZvb2QsIHsgJ3R5cGUnOiAnZnJ1aXQnIH0pO1xuICAgICAqIC8vID0+IFt7ICduYW1lJzogJ2JlZXQnLCAndHlwZSc6ICd2ZWdldGFibGUnIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChhcnJheSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ251bWJlcicgJiYgY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbiA9IDAsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICAgIGNhbGxiYWNrID0gbG9kYXNoLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgY2FsbGJhY2soYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgbisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gKGNhbGxiYWNrID09IG51bGwgfHwgdGhpc0FyZykgPyAxIDogbmF0aXZlTWF4KDAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzbGljZShhcnJheSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCB0aGUgYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gdGhlIHNvcnQgb3JkZXIgb2YgdGhlXG4gICAgICogc29ydGVkIGBhcnJheWAuIElmIGBjYWxsYmFja2AgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBgdmFsdWVgIGFuZFxuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGUgYGNhbGxiYWNrYCBpc1xuICAgICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIElmIGEgcHJvcGVydHkgbmFtZSBpcyBwYXNzZWQgZm9yIGBjYWxsYmFja2AsIHRoZSBjcmVhdGVkIFwiXy5wbHVja1wiIHN0eWxlXG4gICAgICogY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLndoZXJlXCIgc3R5bGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgcHJvcGVydGllcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LFxuICAgICAqIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8U3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGVcbiAgICAgKiAgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgdmFsdWUgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMjAsIDMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnNvcnRlZEluZGV4KFt7ICd4JzogMjAgfSwgeyAneCc6IDMwIH0sIHsgJ3gnOiA1MCB9XSwgeyAneCc6IDQwIH0sICd4Jyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogdmFyIGRpY3QgPSB7XG4gICAgICogICAnd29yZFRvTnVtYmVyJzogeyAndHdlbnR5JzogMjAsICd0aGlydHknOiAzMCwgJ2ZvdXJ0eSc6IDQwLCAnZmlmdHknOiA1MCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAgICogICByZXR1cm4gZGljdC53b3JkVG9OdW1iZXJbd29yZF07XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgKiAgIHJldHVybiB0aGlzLndvcmRUb051bWJlclt3b3JkXTtcbiAgICAgKiB9LCBkaWN0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogbG93O1xuXG4gICAgICAvLyBleHBsaWNpdGx5IHJlZmVyZW5jZSBgaWRlbnRpdHlgIGZvciBiZXR0ZXIgaW5saW5pbmcgaW4gRmlyZWZveFxuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGxvZGFzaC5jcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZywgMSkgOiBpZGVudGl0eTtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUpO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgICAoY2FsbGJhY2soYXJyYXlbbWlkXSkgPCB2YWx1ZSlcbiAgICAgICAgICA/IGxvdyA9IG1pZCArIDFcbiAgICAgICAgICA6IGhpZ2ggPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG93O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSB1bmlvbiBvZiB0aGUgcGFzc2VkLWluIGFycmF5cyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAgICogY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5MSwgYXJyYXkyLCAuLi5dIEFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgdGhhdCBhcmVcbiAgICAgKiAgcHJlc2VudCBpbiBvbmUgb3IgbW9yZSBvZiB0aGUgYXJyYXlzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsxLCAyLCAzXSwgWzEwMSwgMiwgMSwgMTBdLCBbMiwgMV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCAxMDEsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaW9uKGFycmF5KSB7XG4gICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IGFycmF5ID8gbmF0aXZlU2xpY2UuY2FsbChhcnJheSkgOiBhcnJheVJlZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmlxKGNvbmNhdC5hcHBseShhcnJheVJlZiwgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS12YWx1ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGBhcnJheWAgdXNpbmcgc3RyaWN0IGVxdWFsaXR5XG4gICAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYGFycmF5YCBpcyBhbHJlYWR5IHNvcnRlZCwgcGFzc2luZyBgdHJ1ZWBcbiAgICAgKiBmb3IgYGlzU29ydGVkYCB3aWxsIHJ1biBhIGZhc3RlciBhbGdvcml0aG0uIElmIGBjYWxsYmFja2AgaXMgcGFzc2VkLCBlYWNoXG4gICAgICogZWxlbWVudCBvZiBgYXJyYXlgIGlzIHBhc3NlZCB0aHJvdWdoIHRoZSBgY2FsbGJhY2tgIGJlZm9yZSB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLlxuICAgICAqIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHBhc3NlZCBmb3IgYGNhbGxiYWNrYCwgdGhlIGNyZWF0ZWQgXCJfLnBsdWNrXCIgc3R5bGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkIGZvciBgY2FsbGJhY2tgLCB0aGUgY3JlYXRlZCBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFja1xuICAgICAqIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiBvYmplY3QsXG4gICAgICogZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHVuaXF1ZVxuICAgICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NvcnRlZD1mYWxzZV0gQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIGBhcnJheWAgaXMgYWxyZWFkeSBzb3J0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R8U3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyXG4gICAgICogIGl0ZXJhdGlvbi4gSWYgYSBwcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGVcbiAgICAgKiAgYSBcIl8ucGx1Y2tcIiBvciBcIl8ud2hlcmVcIiBzdHlsZSBjYWxsYmFjaywgcmVzcGVjdGl2ZWx5LlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udW5pcShbJ0EnLCAnYicsICdDJywgJ2EnLCAnQicsICdjJ10sIGZ1bmN0aW9uKGxldHRlcikgeyByZXR1cm4gbGV0dGVyLnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgICAqIC8vID0+IFsnQScsICdiJywgJ0MnXVxuICAgICAqXG4gICAgICogXy51bmlxKFsxLCAyLjUsIDMsIDEuNSwgMiwgMy41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgICAqIC8vID0+IFsxLCAyLjUsIDNdXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBcIl8ucGx1Y2tcIiBjYWxsYmFjayBzaG9ydGhhbmRcbiAgICAgKiBfLnVuaXEoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlxID0gb3ZlcmxvYWRXcmFwcGVyKGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4T2YgPSBnZXRJbmRleE9mKCksXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB2YXIgaXNMYXJnZSA9ICFpc1NvcnRlZCAmJiBsZW5ndGggPj0gbGFyZ2VBcnJheVNpemUgJiYgaW5kZXhPZiA9PT0gYmFzaWNJbmRleE9mLFxuICAgICAgICAgIHNlZW4gPSAoY2FsbGJhY2sgfHwgaXNMYXJnZSkgPyBnZXRBcnJheSgpIDogcmVzdWx0O1xuXG4gICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjcmVhdGVDYWNoZShzZWVuKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgaW5kZXhPZiA9IGNhY2hlSW5kZXhPZjtcbiAgICAgICAgICBzZWVuID0gY2FjaGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNMYXJnZSA9IGZhbHNlO1xuICAgICAgICAgIHNlZW4gPSBjYWxsYmFjayA/IHNlZW4gOiAocmVsZWFzZUFycmF5KHNlZW4pLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNTb3J0ZWRcbiAgICAgICAgICAgICAgPyAhaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSBjb21wdXRlZFxuICAgICAgICAgICAgICA6IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQpIDwgMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGlzTGFyZ2UpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgcmVsZWFzZUFycmF5KHNlZW4uYXJyYXkpO1xuICAgICAgICByZWxlYXNlT2JqZWN0KHNlZW4pO1xuICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICByZWxlYXNlQXJyYXkoc2Vlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uemlwYCwgdGhpcyBtZXRob2Qgc3BsaXRzIGdyb3VwcyBvZiBlbGVtZW50cyBpbnRvIGFycmF5c1xuICAgICAqIGNvbXBvc2VkIG9mIGVsZW1lbnRzIGZyb20gZWFjaCBncm91cCBhdCB0aGVpciBjb3JyZXNwb25kaW5nIGluZGV4ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSBjb21wb3NlZCBhcnJheXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW56aXAoW1snbW9lJywgMzAsIHRydWVdLCBbJ2xhcnJ5JywgNDAsIGZhbHNlXV0pO1xuICAgICAqIC8vID0+IFtbJ21vZScsICdsYXJyeSddLCBbMzAsIDQwXSwgW3RydWUsIGZhbHNlXV07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID8gbWF4KHBsdWNrKGFycmF5LCAnbGVuZ3RoJykpIDogMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGggPCAwID8gMCA6IGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBwbHVjayhhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIG9jY3VycmVuY2VzIG9mIHRoZSBwYXNzZWQgdmFsdWVzIHJlbW92ZWQgdXNpbmdcbiAgICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3ZhbHVlMSwgdmFsdWUyLCAuLi5dIFZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzEsIDIsIDEsIDAsIDMsIDEsIDRdLCAwLCAxKTtcbiAgICAgKiAvLyA9PiBbMiwgMywgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3aXRob3V0KGFycmF5KSB7XG4gICAgICByZXR1cm4gZGlmZmVyZW5jZShhcnJheSwgbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggYXJyYXkgYXQgdGhlaXIgY29ycmVzcG9uZGluZyBpbmRleGVzLiBVc2VmdWwgZm9yXG4gICAgICogc2VwYXJhdGUgZGF0YSBzb3VyY2VzIHRoYXQgYXJlIGNvb3JkaW5hdGVkIHRocm91Z2ggbWF0Y2hpbmcgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBGb3IgYSBtYXRyaXggb2YgbmVzdGVkIGFycmF5cywgYF8uemlwLmFwcGx5KC4uLilgIGNhbiB0cmFuc3Bvc2UgdGhlIG1hdHJpeFxuICAgICAqIGluIGEgc2ltaWxhciBmYXNoaW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheTEsIGFycmF5MiwgLi4uXSBBcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydtb2UnLCAnbGFycnknXSwgWzMwLCA0MF0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ21vZScsIDMwLCB0cnVlXSwgWydsYXJyeScsIDQwLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPyB1bnppcChhcmd1bWVudHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC4gUGFzcyBlaXRoZXJcbiAgICAgKiBhIHNpbmdsZSB0d28gZGltZW5zaW9uYWwgYXJyYXksIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYCwgb3JcbiAgICAgKiB0d28gYXJyYXlzLCBvbmUgb2YgYGtleXNgIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBhbGlhcyBvYmplY3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgb2Yga2V5cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBnaXZlbiBrZXlzIGFuZFxuICAgICAqICBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydtb2UnLCAnbGFycnknXSwgWzMwLCA0MF0pO1xuICAgICAqIC8vID0+IHsgJ21vZSc6IDMwLCAnbGFycnknOiA0MCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cyA/IGtleXMubGVuZ3RoIDogMCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXlbMF1dID0ga2V5WzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogSWYgYG5gIGlzIGdyZWF0ZXIgdGhhbiBgMGAsIGEgZnVuY3Rpb24gaXMgY3JlYXRlZCB0aGF0IGlzIHJlc3RyaWN0ZWQgdG9cbiAgICAgKiBleGVjdXRpbmcgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24sIG9ubHkgYWZ0ZXIgaXQgaXMgY2FsbGVkIGBuYCB0aW1lcy4gSWYgYG5gIGlzIGxlc3MgdGhhbiBgMWAsXG4gICAgICogYGZ1bmNgIGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LCB3aXRob3V0IGEgYHRoaXNgIGJpbmRpbmcgb3IgYWRkaXRpb25hbFxuICAgICAqIGFyZ3VtZW50cywgYW5kIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYmVmb3JlXG4gICAgICogaXQgaXMgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlbmRlck5vdGVzID0gXy5hZnRlcihub3Rlcy5sZW5ndGgsIHJlbmRlcik7XG4gICAgICogXy5mb3JFYWNoKG5vdGVzLCBmdW5jdGlvbihub3RlKSB7XG4gICAgICogICBub3RlLmFzeW5jU2F2ZSh7ICdzdWNjZXNzJzogcmVuZGVyTm90ZXMgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gYHJlbmRlck5vdGVzYCBpcyBydW4gb25jZSwgYWZ0ZXIgYWxsIG5vdGVzIGhhdmUgc2F2ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAobiA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kYCBhcmd1bWVudHMgdG8gdGhvc2VcbiAgICAgKiBwYXNzZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW2FyZzEsIGFyZzIsIC4uLl0gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGZ1bmMgPSBfLmJpbmQoZnVuYywgeyAnbmFtZSc6ICdtb2UnIH0sICdoaScpO1xuICAgICAqIGZ1bmMoKTtcbiAgICAgKiAvLyA9PiAnaGkgbW9lJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc0FyZykge1xuICAgICAgLy8gdXNlIGBGdW5jdGlvbiNiaW5kYCBpZiBpdCBleGlzdHMgYW5kIGlzIGZhc3RcbiAgICAgIC8vIChpbiBWOCBgRnVuY3Rpb24jYmluZGAgaXMgc2xvd2VyIGV4Y2VwdCB3aGVuIHBhcnRpYWxseSBhcHBsaWVkKVxuICAgICAgcmV0dXJuIHN1cHBvcnQuZmFzdEJpbmQgfHwgKG5hdGl2ZUJpbmQgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDIpXG4gICAgICAgID8gbmF0aXZlQmluZC5jYWxsLmFwcGx5KG5hdGl2ZUJpbmQsIGFyZ3VtZW50cylcbiAgICAgICAgOiBjcmVhdGVCb3VuZChmdW5jLCB0aGlzQXJnLCBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb24gYG9iamVjdGAgdG8gYG9iamVjdGAsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZyBtZXRob2QuXG4gICAgICogTWV0aG9kIG5hbWVzIG1heSBiZSBzcGVjaWZpZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMgb3IgYXMgYXJyYXlzIG9mIG1ldGhvZFxuICAgICAqIG5hbWVzLiBJZiBubyBtZXRob2QgbmFtZXMgYXJlIHByb3ZpZGVkLCBhbGwgdGhlIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYG9iamVjdGBcbiAgICAgKiB3aWxsIGJlIGJvdW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFttZXRob2ROYW1lMSwgbWV0aG9kTmFtZTIsIC4uLl0gTWV0aG9kIG5hbWVzIG9uIHRoZSBvYmplY3QgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAnb25DbGljayc6IGZ1bmN0aW9uKCkgeyBhbGVydCgnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7IH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcpO1xuICAgICAqIGpRdWVyeSgnI2RvY3MnKS5vbignY2xpY2snLCB2aWV3Lm9uQ2xpY2spO1xuICAgICAqIC8vID0+IGFsZXJ0cyAnY2xpY2tlZCBkb2NzJywgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kQWxsKG9iamVjdCkge1xuICAgICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBjb25jYXQuYXBwbHkoYXJyYXlSZWYsIG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkgOiBmdW5jdGlvbnMob2JqZWN0KSxcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gXG4gICAgICogYW5kIHByZXBlbmRzIGFueSBhZGRpdGlvbmFsIGBiaW5kS2V5YCBhcmd1bWVudHMgdG8gdGhvc2UgcGFzc2VkIHRvIHRoZSBib3VuZFxuICAgICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAgICogcmVmZXJlbmNlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuXG4gICAgICogU2VlIGh0dHA6Ly9taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0aGUgbWV0aG9kIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtNaXhlZH0gW2FyZzEsIGFyZzIsIC4uLl0gQXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ25hbWUnOiAnbW9lJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpIG1vZSdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnLCAnICsgdGhpcy5uYW1lICsgJyEnO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBmdW5jKCk7XG4gICAgICogLy8gPT4gJ2hpLCBtb2UhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmRLZXkob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCb3VuZChvYmplY3QsIGtleSwgbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCBpbmRpY2F0b3JPYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGZ1bmN0aW9ucyxcbiAgICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICAgKiBGb3IgZXhhbXBsZSwgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAgICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Z1bmMxLCBmdW5jMiwgLi4uXSBGdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gJ2hpICcgKyBuYW1lOyB9O1xuICAgICAqIHZhciBleGNsYWltID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7IHJldHVybiBzdGF0ZW1lbnQgKyAnISc7IH07XG4gICAgICogdmFyIHdlbGNvbWUgPSBfLmNvbXBvc2UoZXhjbGFpbSwgZ3JlZXQpO1xuICAgICAqIHdlbGNvbWUoJ21vZScpO1xuICAgICAqIC8vID0+ICdoaSBtb2UhJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3MgPSBbZnVuY3NbbGVuZ3RoXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eVxuICAgICAqIG5hbWUsIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICAgICAqIElmIGBmdW5jYCBpcyBhbiBvYmplY3QsIHRoZSBjcmVhdGVkIGNhbGxiYWNrIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgZWxlbWVudHNcbiAgICAgKiB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnQgb2JqZWN0IHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBgZmFsc2VgLlxuICAgICAqXG4gICAgICogTm90ZTogQWxsIExvLURhc2ggbWV0aG9kcywgdGhhdCBhY2NlcHQgYSBgY2FsbGJhY2tgIGFyZ3VtZW50LCB1c2UgYF8uY3JlYXRlQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFtmdW5jPWlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFthcmdDb3VudD0zXSBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgY2FsbGJhY2sgYWNjZXB0cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHN0b29nZXMgPSBbXG4gICAgICogICB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIHdyYXAgdG8gY3JlYXRlIGN1c3RvbSBjYWxsYmFjayBzaG9ydGhhbmRzXG4gICAgICogXy5jcmVhdGVDYWxsYmFjayA9IF8ud3JhcChfLmNyZWF0ZUNhbGxiYWNrLCBmdW5jdGlvbihmdW5jLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAqICAgdmFyIG1hdGNoID0gL14oLis/KV9fKFtnbF10KSguKykkLy5leGVjKGNhbGxiYWNrKTtcbiAgICAgKiAgIHJldHVybiAhbWF0Y2ggPyBmdW5jKGNhbGxiYWNrLCB0aGlzQXJnKSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAqICAgICByZXR1cm4gbWF0Y2hbMl0gPT0gJ2d0JyA/IG9iamVjdFttYXRjaFsxXV0gPiBtYXRjaFszXSA6IG9iamVjdFttYXRjaFsxXV0gPCBtYXRjaFszXTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihzdG9vZ2VzLCAnYWdlX19ndDQ1Jyk7XG4gICAgICogLy8gPT4gW3sgJ25hbWUnOiAnbGFycnknLCAnYWdlJzogNTAgfV1cbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSBtaXhpbnMgd2l0aCBzdXBwb3J0IGZvciBcIl8ucGx1Y2tcIiBhbmQgXCJfLndoZXJlXCIgY2FsbGJhY2sgc2hvcnRoYW5kc1xuICAgICAqIF8ubWl4aW4oe1xuICAgICAqICAgJ3RvTG9va3VwJzogZnVuY3Rpb24oY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgKiAgICAgY2FsbGJhY2sgPSBfLmNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgKiAgICAgcmV0dXJuIF8ucmVkdWNlKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICogICAgICAgcmV0dXJuIChyZXN1bHRbY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKV0gPSB2YWx1ZSwgcmVzdWx0KTtcbiAgICAgKiAgICAgfSwge30pO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy50b0xvb2t1cChzdG9vZ2VzLCAnbmFtZScpO1xuICAgICAqIC8vID0+IHsgJ21vZSc6IHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sICdsYXJyeSc6IHsgJ25hbWUnOiAnbGFycnknLCAnYWdlJzogNTAgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FsbGJhY2soZnVuYywgdGhpc0FyZywgYXJnQ291bnQpIHtcbiAgICAgIGlmIChmdW5jID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgZnVuYztcbiAgICAgIGlmICh0eXBlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGUgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W2Z1bmNdO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BzID0ga2V5cyhmdW5jKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0ID0gaXNFcXVhbChvYmplY3RbcHJvcHNbbGVuZ3RoXV0sIGZ1bmNbcHJvcHNbbGVuZ3RoXV0sIGluZGljYXRvck9iamVjdCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzQXJnID09ICd1bmRlZmluZWQnIHx8IChyZVRoaXMgJiYgIXJlVGhpcy50ZXN0KGZuVG9TdHJpbmcuY2FsbChmdW5jKSkpKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ0NvdW50ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGFyZ0NvdW50ID09PSAyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhLCBiKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmdDb3VudCA9PT0gNCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIGBmdW5jYCB1bnRpbCBhZnRlclxuICAgICAqIGB3YWl0YCBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGludm9rZWQuIFBhc3NcbiAgICAgKiBhbiBgb3B0aW9uc2Agb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nXG4gICAgICogYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSBkZWJvdW5jZWRcbiAgICAgKiBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgICAqXG4gICAgICogTm90ZTogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIHdpbGwgYmUgY2FsbGVkXG4gICAgICogb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiBpc1xuICAgICAqIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogIFtsZWFkaW5nPWZhbHNlXSBBIGJvb2xlYW4gdG8gc3BlY2lmeSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiAgW21heFdhaXRdIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBjYWxsZWQuXG4gICAgICogIFt0cmFpbGluZz10cnVlXSBBIGJvb2xlYW4gdG8gc3BlY2lmeSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbGF6eUxheW91dCA9IF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAzMDApO1xuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBsYXp5TGF5b3V0KTtcbiAgICAgKlxuICAgICAqIGpRdWVyeSgnI3Bvc3Rib3gnKS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAyMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgY2FsbENvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgbWF4VGltZW91dElkID0gbnVsbCxcbiAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgY2FsbENvdW50ID0gMDtcbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmcgJiYgKCFsZWFkaW5nIHx8IGNhbGxDb3VudCA+IDEpO1xuICAgICAgICBjbGVhcigpO1xuICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICBpZiAobWF4V2FpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBuZXcgRGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtYXhEZWxheWVkKCkge1xuICAgICAgICBjbGVhcigpO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9IG5ldyBEYXRlO1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2FpdCA9IG5hdGl2ZU1heCgwLCB3YWl0IHx8IDApO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgbmF0aXZlTWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHRoaXNBcmcgPSB0aGlzO1xuICAgICAgICBjYWxsQ291bnQrKztcblxuICAgICAgICAvLyBhdm9pZCBpc3N1ZXMgd2l0aCBUaXRhbml1bSBhbmQgYHVuZGVmaW5lZGAgdGltZW91dCBpZHNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FwcGNlbGVyYXRvci90aXRhbml1bV9tb2JpbGUvYmxvYi8zXzFfMF9HQS9hbmRyb2lkL3RpdGFuaXVtL3NyYy9qYXZhL3RpL21vZHVsZXMvdGl0YW5pdW0vVGl0YW5pdW1Nb2R1bGUuamF2YSNMMTg1LUwxOTJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKGxlYWRpbmcgJiYgY2FsbENvdW50IDwgMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlO1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gbm93O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChub3cgLSBsYXN0Q2FsbGVkKTtcbiAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgZXhlY3V0aW5nIHRoZSBgZnVuY2AgZnVuY3Rpb24gdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC5cbiAgICAgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFthcmcxLCBhcmcyLCAuLi5dIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oKSB7IGFsZXJ0KCdkZWZlcnJlZCcpOyB9KTtcbiAgICAgKiAvLyByZXR1cm5zIGZyb20gdGhlIGZ1bmN0aW9uIGJlZm9yZSBgYWxlcnRgIGlzIGNhbGxlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGZ1bmMpIHtcbiAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgMSk7XG4gICAgfVxuICAgIC8vIHVzZSBgc2V0SW1tZWRpYXRlYCBpZiBpdCdzIGF2YWlsYWJsZSBpbiBOb2RlLmpzXG4gICAgaWYgKGlzVjggJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2Ygc2V0SW1tZWRpYXRlID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlZmVyID0gYmluZChzZXRJbW1lZGlhdGUsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBgZnVuY2AgZnVuY3Rpb24gYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiB3aWxsIGJlIHBhc3NlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0ge01peGVkfSBbYXJnMSwgYXJnMiwgLi4uXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9nID0gXy5iaW5kKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgICAgKiBfLmRlbGF5KGxvZywgMTAwMCwgJ2xvZ2dlZCBsYXRlcicpO1xuICAgICAqIC8vID0+ICdsb2dnZWQgbGF0ZXInIChBcHBlYXJzIGFmdGVyIG9uZSBzZWNvbmQuKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbGF5KGZ1bmMsIHdhaXQpIHtcbiAgICAgIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0XG4gICAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gVGhlIHJlc3VsdFxuICAgICAqIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIEEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6aW5nIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmlib25hY2NpID0gXy5tZW1vaXplKGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuIDwgMiA/IG4gOiBmaWJvbmFjY2kobiAtIDEpICsgZmlib25hY2NpKG4gLSAyKTtcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGUsXG4gICAgICAgICAgICBrZXkgPSBrZXlQcmVmaXggKyAocmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdKTtcblxuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwga2V5KVxuICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgIDogKGNhY2hlW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSB7fTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGV4ZWN1dGUgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxscyB0b1xuICAgICAqIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNhbGwuIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWRcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyBgaW5pdGlhbGl6ZWAgZXhlY3V0ZXMgYGNyZWF0ZUFwcGxpY2F0aW9uYCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICB2YXIgcmFuLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmFuKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGBmdW5jYCB2YXJpYWJsZSBzbyB0aGUgZnVuY3Rpb24gbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIGZ1bmMgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggYW55IGFkZGl0aW9uYWxcbiAgICAgKiBgcGFydGlhbGAgYXJndW1lbnRzIHByZXBlbmRlZCB0byB0aG9zZSBwYXNzZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyBzaW1pbGFyIHRvIGBfLmJpbmRgLCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFthcmcxLCBhcmcyLCAuLi5dIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIG5hbWUpIHsgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTsgfTtcbiAgICAgKiB2YXIgaGkgPSBfLnBhcnRpYWwoZ3JlZXQsICdoaScpO1xuICAgICAqIGhpKCdtb2UnKTtcbiAgICAgKiAvLyA9PiAnaGkgbW9lJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWwoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJvdW5kKGZ1bmMsIG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgc2ltaWxhciB0byBgXy5wYXJ0aWFsYCwgZXhjZXB0IHRoYXQgYHBhcnRpYWxgIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBhcHBlbmRlZCB0byB0aG9zZSBwYXNzZWQgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFthcmcxLCBhcmcyLCAuLi5dIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzRGVlcCA9IF8ucGFydGlhbFJpZ2h0KF8ubWVyZ2UsIF8uZGVmYXVsdHMpO1xuICAgICAqXG4gICAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAgICogICAndmFyaWFibGUnOiAnZGF0YScsXG4gICAgICogICAnaW1wb3J0cyc6IHsgJ2pxJzogJCB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzRGVlcChvcHRpb25zLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuICAgICAqXG4gICAgICogb3B0aW9ucy52YXJpYWJsZVxuICAgICAqIC8vID0+ICdkYXRhJ1xuICAgICAqXG4gICAgICogb3B0aW9ucy5pbXBvcnRzXG4gICAgICogLy8gPT4geyAnXyc6IF8sICdqcSc6ICQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnRpYWxSaWdodChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQm91bmQoZnVuYywgbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBudWxsLCBpbmRpY2F0b3JPYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgYGZ1bmNgIGZ1bmN0aW9uXG4gICAgICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBQYXNzIGFuIGBvcHRpb25zYCBvYmplY3QgdG9cbiAgICAgKiBpbmRpY2F0ZSB0aGF0IGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZVxuICAgICAqIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGxcbiAgICAgKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgY2FsbC5cbiAgICAgKlxuICAgICAqIE5vdGU6IElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCB3aWxsIGJlIGNhbGxlZFxuICAgICAqIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gaXNcbiAgICAgKiBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgZXhlY3V0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogIFtsZWFkaW5nPXRydWVdIEEgYm9vbGVhbiB0byBzcGVjaWZ5IGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqICBbdHJhaWxpbmc9dHJ1ZV0gQSBib29sZWFuIHRvIHNwZWNpZnkgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCk7XG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiBqUXVlcnkoJy5pbnRlcmFjdGl2ZScpLm9uKCdjbGljaycsIF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7XG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBnZXRPYmplY3QoKTtcbiAgICAgIG9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICBvcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgb3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucyk7XG4gICAgICByZWxlYXNlT2JqZWN0KG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwYXNzZXMgYHZhbHVlYCB0byB0aGUgYHdyYXBwZXJgIGZ1bmN0aW9uIGFzIGl0c1xuICAgICAqIGZpcnN0IGFyZ3VtZW50LiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHBhc3NlZCB0byB0aGUgYHdyYXBwZXJgIGZ1bmN0aW9uLiBUaGUgYHdyYXBwZXJgIGlzIGV4ZWN1dGVkIHdpdGhcbiAgICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gJ2hlbGxvICcgKyBuYW1lOyB9O1xuICAgICAqIGhlbGxvID0gXy53cmFwKGhlbGxvLCBmdW5jdGlvbihmdW5jKSB7XG4gICAgICogICByZXR1cm4gJ2JlZm9yZSwgJyArIGZ1bmMoJ21vZScpICsgJywgYWZ0ZXInO1xuICAgICAqIH0pO1xuICAgICAqIGhlbGxvKCk7XG4gICAgICogLy8gPT4gJ2JlZm9yZSwgaGVsbG8gbW9lLCBhZnRlcidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3ZhbHVlXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gd3JhcHBlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBgJmAsIGA8YCwgYD5gLCBgXCJgLCBhbmQgYCdgIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdNb2UsIExhcnJ5ICYgQ3VybHknKTtcbiAgICAgKiAvLyA9PiAnTW9lLCBMYXJyeSAmYW1wOyBDdXJseSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG1vZSA9IHsgJ25hbWUnOiAnbW9lJyB9O1xuICAgICAqIG1vZSA9PT0gXy5pZGVudGl0eShtb2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZnVuY3Rpb25zIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uIGFuZCBjaGFpbmFibGVcbiAgICAgKiB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvZiBmdW5jdGlvbiBwcm9wZXJ0aWVzIHRvIGFkZCB0byBgbG9kYXNoYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taXhpbih7XG4gICAgICogICAnY2FwaXRhbGl6ZSc6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ21vZScpO1xuICAgICAqIC8vID0+ICdNb2UnXG4gICAgICpcbiAgICAgKiBfKCdtb2UnKS5jYXBpdGFsaXplKCk7XG4gICAgICogLy8gPT4gJ01vZSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaXhpbihvYmplY3QpIHtcbiAgICAgIGZvckVhY2goZnVuY3Rpb25zKG9iamVjdCksIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV0gPSBvYmplY3RbbWV0aG9kTmFtZV07XG5cbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICAgIGFyZ3MgPSBbdmFsdWVdO1xuXG4gICAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KGxvZGFzaCwgYXJncyk7XG4gICAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcgJiYgdmFsdWUgPT09IHJlc3VsdClcbiAgICAgICAgICAgID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgbG9kYXNoV3JhcHBlcihyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgIGNvbnRleHQuXyA9IG9sZERhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYHZhbHVlYCBpbnRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCBgcmFkaXhgLlxuICAgICAqIElmIGByYWRpeGAgaXMgYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyB0aGVcbiAgICAgKiBgdmFsdWVgIGlzIGEgaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kIGF2b2lkcyBkaWZmZXJlbmNlcyBpbiBuYXRpdmUgRVMzIGFuZCBFUzUgYHBhcnNlSW50YFxuICAgICAqIGltcGxlbWVudGF0aW9ucy4gU2VlIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jRS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXhdIFRoZSByYWRpeCB1c2VkIHRvIGludGVycHJldCB0aGUgdmFsdWUgdG8gcGFyc2UuXG4gICAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgbmV3IGludGVnZXIgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqL1xuICAgIHZhciBwYXJzZUludCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2UgKyAnMDgnKSA9PSA4ID8gbmF0aXZlUGFyc2VJbnQgOiBmdW5jdGlvbih2YWx1ZSwgcmFkaXgpIHtcbiAgICAgIC8vIEZpcmVmb3ggYW5kIE9wZXJhIHN0aWxsIGZvbGxvdyB0aGUgRVMzIHNwZWNpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBgcGFyc2VJbnRgXG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQoaXNTdHJpbmcodmFsdWUpID8gdmFsdWUucmVwbGFjZShyZUxlYWRpbmdTcGFjZXNBbmRaZXJvcywgJycpIDogdmFsdWUsIHJhZGl4IHx8IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAgICogYXJndW1lbnQgaXMgcGFzc2VkLCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4PTFdIFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgYSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICBpZiAobWluID09IG51bGwgJiYgbWF4ID09IG51bGwpIHtcbiAgICAgICAgbWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSArbWF4IHx8IDA7XG4gICAgICB9XG4gICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgcmV0dXJuIChtaW4gJSAxIHx8IG1heCAlIDEpXG4gICAgICAgID8gbWluICsgbmF0aXZlTWluKHJhbmQgKiAobWF4IC0gbWluICsgcGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArJycpLmxlbmd0aCAtIDEpKSksIG1heClcbiAgICAgICAgOiBtaW4gKyBmbG9vcihyYW5kICogKG1heCAtIG1pbiArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgYHByb3BlcnR5YCBvbiBgb2JqZWN0YC4gSWYgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uLFxuICAgICAqIGl0IHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgb2JqZWN0YCBhbmQgaXRzIHJlc3VsdCByZXR1cm5lZCxcbiAgICAgKiBlbHNlIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXR1cm5lZC4gSWYgYG9iamVjdGAgaXMgZmFsc2V5LCB0aGVuIGB1bmRlZmluZWRgXG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnY2hlZXNlJzogJ2NydW1wZXRzJyxcbiAgICAgKiAgICdzdHVmZic6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICByZXR1cm4gJ25vbnNlbnNlJztcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnY2hlZXNlJyk7XG4gICAgICogLy8gPT4gJ2NydW1wZXRzJ1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnc3R1ZmYnKTtcbiAgICAgKiAvLyA9PiAnbm9uc2Vuc2UnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA/IG9iamVjdFtwcm9wZXJ0eV0gOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3RbcHJvcGVydHldKCkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIG1pY3JvLXRlbXBsYXRpbmcgbWV0aG9kIHRoYXQgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzXG4gICAgICogd2hpdGVzcGFjZSwgYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQsIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICAgKiBkZWJ1Z2dpbmcuIFNlZSBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZTpcbiAgICAgKiBodHRwOi8vbG9kYXNoLmNvbS8jY3VzdG9tLWJ1aWxkc1xuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlOlxuICAgICAqIGh0dHA6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9zdGFibGUvZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbC5odG1sXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHRlbXBsYXRlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgb2JqZWN0IHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRleHQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqICBlc2NhcGUgLSBUaGUgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgcmVnZXhwLlxuICAgICAqICBldmFsdWF0ZSAtIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHJlZ2V4cC5cbiAgICAgKiAgaW50ZXJwb2xhdGUgLSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciByZWdleHAuXG4gICAgICogIHNvdXJjZVVSTCAtIFRoZSBzb3VyY2VVUkwgb2YgdGhlIHRlbXBsYXRlJ3MgY29tcGlsZWQgc291cmNlLlxuICAgICAqICB2YXJpYWJsZSAtIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxTdHJpbmd9IFJldHVybnMgYSBjb21waWxlZCBmdW5jdGlvbiB3aGVuIG5vIGBkYXRhYCBvYmplY3RcbiAgICAgKiAgaXMgZ2l2ZW4sIGVsc2UgaXQgcmV0dXJucyB0aGUgaW50ZXJwb2xhdGVkIHRleHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIGEgY29tcGlsZWQgdGVtcGxhdGVcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gbmFtZSAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnbW9lJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbW9lJ1xuICAgICAqXG4gICAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JT0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiBfLnRlbXBsYXRlKGxpc3QsIHsgJ3Blb3BsZSc6IFsnbW9lJywgJ2xhcnJ5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5tb2U8L2xpPjxsaT5sYXJyeTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBIVE1MIGluIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAgICogXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicsIHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIEVTNiBkZWxpbWl0ZXIgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gdGhlIGRlZmF1bHQgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlclxuICAgICAqIF8udGVtcGxhdGUoJ2hlbGxvICR7IG5hbWUgfScsIHsgJ25hbWUnOiAnY3VybHknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBjdXJseSdcbiAgICAgKlxuICAgICAqIC8vIHVzaW5nIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzXG4gICAgICogXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIGVwaXRoZXQpOyAlPiEnLCB7ICdlcGl0aGV0JzogJ3N0b29nZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHN0b29nZSEnXG4gICAgICpcbiAgICAgKiAvLyB1c2luZyBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgKiAgICdpbnRlcnBvbGF0ZSc6IC97eyhbXFxzXFxTXSs/KX19L2dcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy50ZW1wbGF0ZSgnaGVsbG8ge3sgbmFtZSB9fSEnLCB7ICduYW1lJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nLCBudWxsLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gZmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3RvclxuICAgICAqXG4gICAgICogLy8gdXNpbmcgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEubmFtZSAlPiEnLCBudWxsLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqICAgdmFyIF9fdCwgX19wID0gJycsIF9fZSA9IF8uZXNjYXBlO1xuICAgICAqICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEubmFtZSApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqICAgcmV0dXJuIF9fcDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgYSBzdGFjayB0cmFjZVxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGN3ZCwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAvLyBiYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nL1xuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVFxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG4gICAgICB0ZXh0IHx8ICh0ZXh0ID0gJycpO1xuXG4gICAgICAvLyBhdm9pZCBtaXNzaW5nIGRlcGVuZGVuY2llcyB3aGVuIGBpdGVyYXRvclRlbXBsYXRlYCBpcyBub3QgZGVmaW5lZFxuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXR0aW5ncyk7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gZGVmYXVsdHMoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSB2YWx1ZXMoaW1wb3J0cyk7XG5cbiAgICAgIHZhciBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBjb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXJcbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIHRleHQucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzXG4gICAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIHJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgcmVxdWlyZXMgcmV0dXJuaW5nIHRoZSBgbWF0Y2hgXG4gICAgICAgIC8vIHN0cmluZyBpbiBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBpZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQsIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlLFxuICAgICAgICAgIGhhc1ZhcmlhYmxlID0gdmFyaWFibGU7XG5cbiAgICAgIGlmICghaGFzVmFyaWFibGUpIHtcbiAgICAgICAgdmFyaWFibGUgPSAnb2JqJztcbiAgICAgICAgc291cmNlID0gJ3dpdGggKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gY2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIGZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHlcbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgdmFyaWFibGUgKyAnKSB7XFxuJyArXG4gICAgICAgIChoYXNWYXJpYWJsZSA/ICcnIDogdmFyaWFibGUgKyAnIHx8ICgnICsgdmFyaWFibGUgKyAnID0ge30pO1xcbicpICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGVcIiArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcgYW5kIHdyYXAgaW4gYSBtdWx0aS1saW5lIGNvbW1lbnQgdG9cbiAgICAgIC8vIGF2b2lkIGlzc3VlcyB3aXRoIE5hcndoYWwsIElFIGNvbmRpdGlvbmFsIGNvbXBpbGF0aW9uLCBhbmQgdGhlIEpTIGVuZ2luZVxuICAgICAgLy8gZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMuXG4gICAgICAvLyBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsXG4gICAgICB2YXIgc291cmNlVVJMID0gJ1xcbi8qXFxuLy9AIHNvdXJjZVVSTD0nICsgKG9wdGlvbnMuc291cmNlVVJMIHx8ICcvbG9kYXNoL3RlbXBsYXRlL3NvdXJjZVsnICsgKHRlbXBsYXRlQ291bnRlcisrKSArICddJykgKyAnXFxuKi8nO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gRnVuY3Rpb24oaW1wb3J0c0tleXMsICdyZXR1cm4gJyArIHNvdXJjZSArIHNvdXJjZVVSTCkuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQoZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBwcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSB2aWEgaXRzIGB0b1N0cmluZ2AgbWV0aG9kLCBpblxuICAgICAgLy8gc3VwcG9ydGVkIGVudmlyb25tZW50cywgb3IgdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgYGNhbGxiYWNrYCBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0c1xuICAgICAqIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2KSk7XG4gICAgICogLy8gPT4gWzMsIDYsIDRdXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgbWFnZS5jYXN0U3BlbGwobik7IH0pO1xuICAgICAqIC8vID0+IGNhbGxzIGBtYWdlLmNhc3RTcGVsbChuKWAgdGhyZWUgdGltZXMsIHBhc3NpbmcgYG5gIG9mIGAwYCwgYDFgLCBhbmQgYDJgIHJlc3BlY3RpdmVseVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IHRoaXMuY2FzdChuKTsgfSwgbWFnZSk7XG4gICAgICogLy8gPT4gYWxzbyBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIG4gPSAobiA9ICtuKSA+IC0xID8gbiA6IDA7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICAgICAgY2FsbGJhY2sgPSBsb2Rhc2guY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcsIDEpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWAsIHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnTW9lLCBMYXJyeSAmYW1wOyBDdXJseScpO1xuICAgICAqIC8vID0+ICdNb2UsIExhcnJ5ICYgQ3VybHknXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBwYXNzZWQsIHRoZSBJRCB3aWxsIGJlIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIFN0cmluZyhwcmVmaXggPT0gbnVsbCA/ICcnIDogcHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgaW50ZXJjZXB0b3JgIHdpdGggdGhlIGB2YWx1ZWAgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCBhbmQgdGhlblxuICAgICAqIHJldHVybnMgYHZhbHVlYC4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLFxuICAgICAqIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHBhc3MgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzLCA0XSlcbiAgICAgKiAgLmZpbHRlcihmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSlcbiAgICAgKiAgLnRhcChhbGVydClcbiAgICAgKiAgLm1hcChmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIG51bTsgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gLy8gWzIsIDRdIChhbGVydGVkKVxuICAgICAqIC8vID0+IFs0LCAxNl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgdGhlIGB0b1N0cmluZ2AgcmVzdWx0IG9mIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdG9TdHJpbmdcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZyByZXN1bHQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS50b1N0cmluZygpO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKHRoaXMuX193cmFwcGVkX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVPZlxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGFsaWFzIHZhbHVlXG4gICAgICogQGNhdGVnb3J5IENoYWluaW5nXG4gICAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWVPZigpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZU9mKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX193cmFwcGVkX187XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29tcG9zZSA9IGNvbXBvc2U7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGVDYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrO1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5wYWlycyA9IHBhaXJzO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC53aGVyZSA9IHdoZXJlO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuXG4gICAgLy8gYWRkIGFsaWFzZXNcbiAgICBsb2Rhc2guY29sbGVjdCA9IG1hcDtcbiAgICBsb2Rhc2guZHJvcCA9IHJlc3Q7XG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ247XG4gICAgbG9kYXNoLm1ldGhvZHMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLm9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICAgIGxvZGFzaC50YWlsID0gcmVzdDtcbiAgICBsb2Rhc2gudW5pcXVlID0gdW5pcTtcblxuICAgIC8vIGFkZCBmdW5jdGlvbnMgdG8gYGxvZGFzaC5wcm90b3R5cGVgXG4gICAgbWl4aW4obG9kYXNoKTtcblxuICAgIC8vIGFkZCBVbmRlcnNjb3JlIGNvbXBhdFxuICAgIGxvZGFzaC5jaGFpbiA9IGxvZGFzaDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBhZGQgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgd2hlbiBjaGFpbmluZ1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC5hbGwgPSBldmVyeTtcbiAgICBsb2Rhc2guYW55ID0gc29tZTtcbiAgICBsb2Rhc2guZGV0ZWN0ID0gZmluZDtcbiAgICBsb2Rhc2guZmluZFdoZXJlID0gZmluZDtcbiAgICBsb2Rhc2guZm9sZGwgPSByZWR1Y2U7XG4gICAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLmluY2x1ZGUgPSBjb250YWlucztcbiAgICBsb2Rhc2guaW5qZWN0ID0gcmVkdWNlO1xuXG4gICAgZm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgaWYgKCFsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl9fd3JhcHBlZF9fXTtcbiAgICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobG9kYXNoLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gYWRkIGZ1bmN0aW9ucyBjYXBhYmxlIG9mIHJldHVybmluZyB3cmFwcGVkIGFuZCB1bndyYXBwZWQgdmFsdWVzIHdoZW4gY2hhaW5pbmdcbiAgICBsb2Rhc2guZmlyc3QgPSBmaXJzdDtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG5cbiAgICAvLyBhZGQgYWxpYXNlc1xuICAgIGxvZGFzaC50YWtlID0gZmlyc3Q7XG4gICAgbG9kYXNoLmhlYWQgPSBmaXJzdDtcblxuICAgIGZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIGlmICghbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jKHRoaXMuX193cmFwcGVkX18sIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgPT0gbnVsbCB8fCAodGhpc0FyZyAmJiB0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgID8gcmVzdWx0XG4gICAgICAgICAgICA6IG5ldyBsb2Rhc2hXcmFwcGVyKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gJzEuMy4xJztcblxuICAgIC8vIGFkZCBcIkNoYWluaW5nXCIgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyXG4gICAgbG9kYXNoLnByb3RvdHlwZS50b1N0cmluZyA9IHdyYXBwZXJUb1N0cmluZztcbiAgICBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlT2Y7XG4gICAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gd3JhcHBlclZhbHVlT2Y7XG5cbiAgICAvLyBhZGQgYEFycmF5YCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydqb2luJywgJ3BvcCcsICdzaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLl9fd3JhcHBlZF9fLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIGFkZCBgQXJyYXlgIGZ1bmN0aW9ucyB0aGF0IHJldHVybiB0aGUgd3JhcHBlZCB2YWx1ZVxuICAgIGZvckVhY2goWydwdXNoJywgJ3JldmVyc2UnLCAnc29ydCcsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmMuYXBwbHkodGhpcy5fX3dyYXBwZWRfXywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gYWRkIGBBcnJheWAgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIG5ldyB3cmFwcGVkIHZhbHVlc1xuICAgIGZvckVhY2goWydjb25jYXQnLCAnc2xpY2UnLCAnc3BsaWNlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbG9kYXNoV3JhcHBlcihmdW5jLmFwcGx5KHRoaXMuX193cmFwcGVkX18sIGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvc2UgTG8tRGFzaFxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIHNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMby1EYXNoIHRvIHRoZSBnbG9iYWwgb2JqZWN0IGV2ZW4gd2hlbiBhbiBBTUQgbG9hZGVyIGlzIHByZXNlbnQgaW5cbiAgICAvLyBjYXNlIExvLURhc2ggd2FzIGluamVjdGVkIGJ5IGEgdGhpcmQtcGFydHkgc2NyaXB0IGFuZCBub3QgaW50ZW5kZWQgdG8gYmVcbiAgICAvLyBsb2FkZWQgYXMgYSBtb2R1bGUuIFRoZSBnbG9iYWwgYXNzaWdubWVudCBjYW4gYmUgcmV2ZXJ0ZWQgaW4gdGhlIExvLURhc2hcbiAgICAvLyBtb2R1bGUgdmlhIGl0cyBgbm9Db25mbGljdCgpYCBtZXRob2QuXG4gICAgd2luZG93Ll8gPSBfO1xuXG4gICAgLy8gZGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBjaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0XG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG4gICAgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICB9XG4gICAgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cbiAgICBlbHNlIHtcbiAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBpbiBhIGJyb3dzZXIgb3IgUmhpbm9cbiAgICB3aW5kb3cuXyA9IF87XG4gIH1cbn0odGhpcykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5pbnRGcm9tQm9vbGVhbiA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICByZXR1cm4gYiA/IDEgOiAwO1xyXG59O1xyXG5cclxuZXhwb3J0cy5ib29sZWFuRnJvbUludCA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICByZXR1cm4gKGkgPT09IG51bGwpID8gZmFsc2UgOiBpID4gMDtcclxufTsiLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDEwLCBKZWFzaCBjb250cmlidXRvcnMuXHJcbiAqIFxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqIFxyXG4gKiAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcclxuICogICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogICAtIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXHJcbiAqICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiBcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcclxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxyXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxyXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUiBDT05UUklCVVRPUlMgQkVcclxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxyXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxyXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcclxuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cclxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcclxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcclxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxuLypcclxuXHJcbiAgIENvbnRyYXJ5IHRvIGFueSBhZG9iZSBkb2N1bWVudGF0aW9uICwgcG9pbnRzIHRyYW5zZm9ybSB3aXRoOlxyXG5cclxuXHJcbiAgIFsgWCcgIFknICBdICAgPSAgWyBYICBZICAxIF0gWyAgYSAgIGIgXVxyXG4gICBbICBjICAgZCBdXHJcbiAgIFsgIHR4ICB0eV1cclxuXHJcblxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vamFuaWNlay9jb3JlJyk7XHJcbnZhciBkZWYgPSBjb3JlLmRlZjtcclxudmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbkEsIGluQiwgaW5DLCBpbkQsIGluVHgsIGluVHkpIHtcclxuICAgIFxyXG4gICAgdmFyIHB1YiA9IHtcclxuXHJcbiAgICAgICAgYTogZGVmKGluQSwgMS4wKSxcclxuICAgICAgICBiOiBkZWYoaW5CLCAwLjApLFxyXG4gICAgICAgIGM6IGRlZihpbkMsIDAuMCksXHJcbiAgICAgICAgZDogZGVmKGluRCwgMS4wKSxcclxuICAgICAgICB0eDogZGVmKGluVHgsIDAuMCksXHJcbiAgICAgICAgdHk6IGRlZihpblR5LCAwLjApLFxyXG5cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0cml4KHB1Yi5hLCBwdWIuYiwgcHViLmMsIHB1Yi5kLCBwdWIudHgsIHB1Yi50eSk7IH0sXHJcblxyXG4gICAgICAgIGNyZWF0ZUdyYWRpZW50Qm94OiBmdW5jdGlvbiAoaW5XaWR0aCwgaW5IZWlnaHQsIHJvdGF0aW9uLCBpblR4LCBpblR5KSB7XHJcbiAgICAgICAgICAgIHB1Yi5hID0gaW5XaWR0aCAvIDE2MzguNDtcclxuICAgICAgICAgICAgcHViLmQgPSBpbkhlaWdodCAvIDE2MzguNDtcclxuXHJcbiAgICAgICAgICAgIC8vIHJvdGF0aW9uIGlzIGNsb2Nrd2lzZVxyXG4gICAgICAgICAgICBpZiAoIWNvcmUuaXNVbmRlZmluZWRPck51bGwocm90YXRpb24pICYmIHJvdGF0aW9uICE9PSAwLjApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4ocm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgcHViLmIgPSBzaW4gKiBwdWIuZDtcclxuICAgICAgICAgICAgICAgIHB1Yi5jID0gLXNpbiAqIHB1Yi5hO1xyXG4gICAgICAgICAgICAgICAgcHViLmEgKj0gY29zO1xyXG4gICAgICAgICAgICAgICAgcHViLmQgKj0gY29zO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHViLmIgPSBwdWIuYyA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1Yi50eCA9ICFjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKGluVHgpID8gaW5UeCArIGluV2lkdGggLyAyIDogaW5XaWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHB1Yi50eSA9ICFjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKGluVHkpID8gaW5UeSArIGluSGVpZ2h0IC8gMiA6IGluSGVpZ2h0IC8gMjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXRSb3RhdGlvbjogZnVuY3Rpb24gKGluVGhldGEsIGluU2NhbGUpIHtcclxuICAgICAgICAgICAgdmFyIHNjYWxlID0gY29yZS5pc1VuZGVmaW5lZE9yTnVsbChpblNjYWxlKSA/IDEuMCA6IGluU2NhbGU7XHJcbiAgICAgICAgICAgIHB1Yi5hID0gTWF0aC5jb3MoaW5UaGV0YSkgKiBzY2FsZTtcclxuICAgICAgICAgICAgcHViLmMgPSBNYXRoLnNpbihpblRoZXRhKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICBwdWIuYiA9IC1wdWIuYztcclxuICAgICAgICAgICAgcHViLmQgPSBwdWIuYTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpbnZlcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5vcm0gPSBwdWIuYSAqIHB1Yi5kIC0gcHViLmIgKiBwdWIuYztcclxuICAgICAgICAgICAgaWYgKG5vcm0gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHB1Yi5hID0gcHViLmIgPSBwdWIuYyA9IHB1Yi5kID0gMDtcclxuICAgICAgICAgICAgICAgIHB1Yi50eCA9IC1wdWIudHg7XHJcbiAgICAgICAgICAgICAgICBwdWIudHkgPSAtcHViLnR5O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9ybSA9IDEuMCAvIG5vcm07XHJcbiAgICAgICAgICAgICAgICB2YXIgYTEgPSBwdWIuZCAqIG5vcm07XHJcbiAgICAgICAgICAgICAgICBwdWIuZCA9IHB1Yi5hICogbm9ybTtcclxuICAgICAgICAgICAgICAgIHB1Yi5hID0gYTE7XHJcbiAgICAgICAgICAgICAgICBwdWIuYiAqPSAtbm9ybTtcclxuICAgICAgICAgICAgICAgIHB1Yi5jICo9IC1ub3JtO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0eDEgPSAtIHB1Yi5hICogcHViLnR4IC0gcHViLmMgKiBwdWIudHk7XHJcbiAgICAgICAgICAgICAgICBwdWIudHkgPSAtIHB1Yi5iICogcHViLnR4IC0gcHViLmQgKiBwdWIudHk7XHJcbiAgICAgICAgICAgICAgICBwdWIudHggPSB0eDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uIChpblBvcykge1xyXG4gICAgICAgICAgICByZXR1cm4ge3g6IGluUG9zLnggKiBwdWIuYSArIGluUG9zLnkgKiBwdWIuYyArIHB1Yi50eCwgeTogaW5Qb3MueCAqIHB1Yi5iICsgaW5Qb3MueSAqIHB1Yi5kICsgcHViLnR5IH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoaW5EWCwgaW5EWSkge1xyXG4gICAgICAgICAgICBwdWIudHggKz0gaW5EWDtcclxuICAgICAgICAgICAgcHViLnR5ICs9IGluRFk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgICBSb3RhdGUgb2JqZWN0IFwiYWZ0ZXJcIiBvdGhlciB0cmFuc2Zvcm1zXHJcblxyXG4gICAgICAgICAgIFsgIGEgIGIgICAwIF1bICBtYSBtYiAgMCBdXHJcbiAgICAgICAgICAgWyAgYyAgZCAgIDAgXVsgIG1jIG1kICAwIF1cclxuICAgICAgICAgICBbICB0eCB0eSAgMSBdWyAgbXR4IG10eSAxIF1cclxuXHJcbiAgICAgICAgICAgbWEgPSBtZCA9IGNvc1xyXG4gICAgICAgICAgIG1iID0gLXNpblxyXG4gICAgICAgICAgIG1jID0gc2luXHJcbiAgICAgICAgICAgbXR4ID0gbXkgPSAwXHJcblxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uIChpblRoZXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhpblRoZXRhKTtcclxuICAgICAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGluVGhldGEpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGExID0gcHViLmEgKiBjb3MgLSBwdWIuYiAqIHNpbjtcclxuICAgICAgICAgICAgcHViLmIgPSBwdWIuYSAqIHNpbiArIHB1Yi5iICogY29zO1xyXG4gICAgICAgICAgICBwdWIuYSA9IGExO1xyXG5cclxuICAgICAgICAgICAgdmFyIGMxID0gcHViLmMgKiBjb3MgLSBwdWIuZCAqIHNpbjtcclxuICAgICAgICAgICAgcHViLmQgPSBwdWIuYyAqIHNpbiArIHB1Yi5kICogY29zO1xyXG4gICAgICAgICAgICBwdWIuYyA9IGMxO1xyXG5cclxuICAgICAgICAgICAgdmFyIHR4MSA9IHB1Yi50eCAqIGNvcyAtIHB1Yi50eSAqIHNpbjtcclxuICAgICAgICAgICAgcHViLnR5ID0gcHViLnR4ICogc2luICsgcHViLnR5ICogY29zO1xyXG4gICAgICAgICAgICBwdWIudHggPSB0eDE7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLypcclxuXHJcbiAgICAgICAgICAgU2NhbGUgb2JqZWN0IFwiYWZ0ZXJcIiBvdGhlciB0cmFuc2Zvcm1zXHJcblxyXG4gICAgICAgICAgIFsgIGEgIGIgICAwIF1bICBzeCAgMCAgIDAgXVxyXG4gICAgICAgICAgIFsgIGMgIGQgICAwIF1bICAwICAgc3kgIDAgXVxyXG4gICAgICAgICAgIFsgIHR4IHR5ICAxIF1bICAwICAgMCAgIDEgXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNjYWxlOiBmdW5jdGlvbiAoaW5TWCwgaW5TWSkge1xyXG4gICAgICAgICAgICBwdWIuYSAqPSBpblNYO1xyXG4gICAgICAgICAgICBwdWIuYiAqPSBpblNZO1xyXG5cclxuICAgICAgICAgICAgcHViLmMgKj0gaW5TWDtcclxuICAgICAgICAgICAgcHViLmQgKj0gaW5TWTtcclxuXHJcbiAgICAgICAgICAgIHB1Yi50eCAqPSBpblNYO1xyXG4gICAgICAgICAgICBwdWIudHkgKj0gaW5TWTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKlxyXG5cclxuICAgICAgICAgICBBIFwidHJhbnNsYXRlXCIgLiBjb25jYXQgXCJyb3RhdGVcIiByb3RhdGVzIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQuXHJcbiAgICAgICAgICAgaWUsXHJcblxyXG4gICAgICAgICAgIFtYJ10gPSBbWF1bdHJhbnNdW3JvdGF0ZV1cclxuXHJcblxyXG4gICAgICAgICAgIE11bHRpcGx5IFwiYWZ0ZXJcIiBvdGhlciB0cmFuc2Zvcm1zIC4uLlxyXG5cclxuXHJcbiAgICAgICAgICAgWyAgYSAgYiAgIDAgXVsgIG1hIG1iICAwIF1cclxuICAgICAgICAgICBbICBjICBkICAgMCBdWyAgbWMgbWQgIDAgXVxyXG4gICAgICAgICAgIFsgIHR4IHR5ICAxIF1bICBtdHggbXR5IDEgXVxyXG5cclxuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICB2YXIgYTEgPSBwdWIuYSAqIG0uYSArIHB1Yi5iICogbS5jO1xyXG4gICAgICAgICAgICBwdWIuYiA9IHB1Yi5hICogbS5iICsgcHViLmIgKiBtLmQ7XHJcbiAgICAgICAgICAgIHB1Yi5hID0gYTE7XHJcblxyXG4gICAgICAgICAgICB2YXIgYzEgPSBwdWIuYyAqIG0uYSArIHB1Yi5kICogbS5jO1xyXG4gICAgICAgICAgICBwdWIuZCA9IHB1Yi5jICogbS5iICsgcHViLmQgKiBtLmQ7XHJcbiAgICAgICAgICAgIHB1Yi5jID0gYzE7XHJcblxyXG4gICAgICAgICAgICB2YXIgdHgxID0gcHViLnR4ICogbS5hICsgcHViLnR5ICogbS5jICsgbS50eDtcclxuICAgICAgICAgICAgcHViLnR5ID0gcHViLnR4ICogbS5iICsgcHViLnR5ICogbS5kICsgbS50eTtcclxuICAgICAgICAgICAgcHViLnR4ID0gdHgxO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG11bHQ6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtYXRyaXgoKTtcclxuICAgICAgICAgICAgcmVzdWx0LmEgPSBwdWIuYSAqIG0uYSArIHB1Yi5iICogbS5jO1xyXG4gICAgICAgICAgICByZXN1bHQuYiA9IHB1Yi5hICogbS5iICsgcHViLmIgKiBtLmQ7XHJcbiAgICAgICAgICAgIHJlc3VsdC5jID0gcHViLmMgKiBtLmEgKyBwdWIuZCAqIG0uYztcclxuICAgICAgICAgICAgcmVzdWx0LmQgPSBwdWIuYyAqIG0uYiArIHB1Yi5kICogbS5kO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnR4ID0gcHViLnR4ICogbS5hICsgcHViLnR5ICogbS5jICsgbS50eDtcclxuICAgICAgICAgICAgcmVzdWx0LnR5ID0gcHViLnR4ICogbS5iICsgcHViLnR5ICogbS5kICsgbS50eTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpZGVudGl0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBwdWIuYSA9IDE7XHJcbiAgICAgICAgICAgIHB1Yi5iID0gMDtcclxuICAgICAgICAgICAgcHViLmMgPSAwO1xyXG4gICAgICAgICAgICBwdWIuZCA9IDE7XHJcbiAgICAgICAgICAgIHB1Yi50eCA9IDA7XHJcbiAgICAgICAgICAgIHB1Yi50eSA9IDA7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9Nb3pTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG0gPSAnbWF0cml4KCc7XHJcbiAgICAgICAgICAgIG0gKz0gcHViLmEgKyAnLCAnO1xyXG4gICAgICAgICAgICBtICs9IHB1Yi5iICsgJywgJztcclxuICAgICAgICAgICAgbSArPSBwdWIuYyArICcsICc7XHJcbiAgICAgICAgICAgIG0gKz0gcHViLmQgKyAnLCAnO1xyXG4gICAgICAgICAgICBtICs9IHB1Yi50eCArICdweCwgJztcclxuICAgICAgICAgICAgbSArPSBwdWIudHkgKyAncHgpJztcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG0gPSAnbWF0cml4KCc7XHJcbiAgICAgICAgICAgIG0gKz0gcHViLmEgKyAnLCAnO1xyXG4gICAgICAgICAgICBtICs9IHB1Yi5iICsgJywgJztcclxuICAgICAgICAgICAgbSArPSBwdWIuYyArICcsICc7XHJcbiAgICAgICAgICAgIG0gKz0gcHViLmQgKyAnLCAnO1xyXG4gICAgICAgICAgICBtICs9IHB1Yi50eCArICcsICc7XHJcbiAgICAgICAgICAgIG0gKz0gcHViLnR5ICsgJyknO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBwdWI7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgZnJvbSAoMCwwKSB0byB0aGlzIHBvaW50LlxyXG4gICAgICovXHJcbiAgICBkaXN0YW5jZUZyb21PcmlnaW46IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChhLnggLSBiLngpLCAyKSArIE1hdGgucG93KChhLnkgLSBiLnkpLCAyKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBhIHBvaW50IGJldHdlZW4gdHdvIHNwZWNpZmllZCBwb2ludHMuIFRoZSBwYXJhbWV0ZXIgZiBkZXRlcm1pbmVzIHdoZXJlIHRoZSBuZXcgaW50ZXJwb2xhdGVkIHBvaW50IGlzIFxyXG4gICAgICogbG9jYXRlZCByZWxhdGl2ZSB0byB0aGUgdHdvIGVuZCBwb2ludHMgc3BlY2lmaWVkIGJ5IHBhcmFtZXRlcnMgcHQxIGFuZCBwdDIuIFRoZSBjbG9zZXIgdGhlIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIgZiBcclxuICAgICAqIGlzIHRvIDEuMCwgdGhlIGNsb3NlciB0aGUgaW50ZXJwb2xhdGVkIHBvaW50IGlzIHRvIHRoZSBmaXJzdCBwb2ludCAocGFyYW1ldGVyIHB0MSkuIFRoZSBjbG9zZXIgdGhlIHZhbHVlIG9mIHRoZVxyXG4gICAgICogcGFyYW1ldGVyIGYgaXMgdG8gMCwgdGhlIGNsb3NlciB0aGUgaW50ZXJwb2xhdGVkIHBvaW50IGlzIHRvIHRoZSBzZWNvbmQgcG9pbnQgKHBhcmFtZXRlciBwdDIpLlxyXG4gICAgICogQHBhcmFtICAgcHQxIFRoZSBmaXJzdCBwb2ludC5cclxuICAgICAqIEBwYXJhbSAgIHB0MiBUaGUgc2Vjb25kIHBvaW50LlxyXG4gICAgICogQHBhcmFtICAgZiBUaGUgbGV2ZWwgb2YgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLiBJbmRpY2F0ZXMgd2hlcmUgdGhlIG5ldyBwb2ludCB3aWxsIGJlLCBhbG9uZyB0aGUgbGluZSBiZXR3ZWVuIHB0MSBhbmQgcHQyLiBJZiBmPTEsIHB0MSBpcyByZXR1cm5lZDsgaWYgZj0wLCBwdDIgaXMgcmV0dXJuZWQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBuZXcsIGludGVycG9sYXRlZCBwb2ludC5cclxuICAgICAqL1xyXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwdDEsIHB0MiwgZikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IChwdDEueCAtIHB0Mi54KSAqIGYgKyBwdDIueCwgeTogKHB0MS55IC0gcHQyLnkpICogZiArIHB0Mi55IH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoZSBsaW5lIHNlZ21lbnQgYmV0d2VlbiAoMCwwKSBhbmQgdGhlIGN1cnJlbnQgcG9pbnQgdG8gYSBzZXQgbGVuZ3RoLlxyXG4gICAgICogQHBhcmFtICAgdGhpY2tuZXNzIFRoZSBzY2FsaW5nIHZhbHVlLiBGb3IgZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgcG9pbnQgaXMgKDAsNSksIGFuZCB5b3Ugbm9ybWFsaXplIGl0IHRvIDEsIHRoZSBwb2ludCByZXR1cm5lZCBpcyBhdCAoMCwxKS5cclxuICAgICAqL1xyXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiAocCwgdGhpY2tuZXNzKSB7XHJcbiAgICAgICAgaWYgKHAueCA9PT0gMCAmJiBwLnkgPT09IDApIHtcclxuICAgICAgICAgICAgcC54ID0gdGhpY2tuZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vcm0gPSB0aGlja25lc3MgLyBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcclxuICAgICAgICAgICAgcC54ICo9IG5vcm07XHJcbiAgICAgICAgICAgIHAueSAqPSBub3JtO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBjb29yZGluYXRlcyBvZiAyIHBvaW50cyB0byBjcmVhdGUgYSBuZXcgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIGFkZDogZnVuY3Rpb24gKHAxLCBwMikge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHAyLnggKyBwMS54LCB5OiBwMi55ICsgcDEueSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIHN1YnRyYWN0IGZpcnN0IHBvaW50IGFuZCBzZWNvbmQgcG9pbnRcclxuICAgICAqIEBwYXJhbSAgIHAwXHJcbiAgICAgKiBAcGFyYW0gICBwMVxyXG4gICAgICogQHJldHVyblxyXG4gICAgICovXHJcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHAwLCBwMSkge1xyXG4gICAgICAgIHJldHVybiB7IHg6IHAwLnggLSBwMS54LCB5OiBwMC55IC0gcDEueSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICBoYXNoOiBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHJldHVybiBwLnggKyAnLCcgKyBwLnk7XHJcbiAgICB9XHJcblxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgeDogeCB8fCAwLFxyXG4gICAgICAgIHk6IHkgfHwgMCxcclxuICAgICAgICB3aWR0aDogd2lkdGggfHwgMCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCAwXHJcbiAgICB9O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMuY29yZSA9IGZ1bmN0aW9uIChyZWN0YW5nbGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVjdGFuZ2xlLng7IH0sXHJcbiAgICAgICAgcmlnaHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoOyB9LFxyXG4gICAgICAgIHRvcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVjdGFuZ2xlLnk7IH0sXHJcbiAgICAgICAgYm90dG9tOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQ7IH1cclxuICAgIH07XHJcbn07IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMCwgSmVhc2ggY29udHJpYnV0b3JzLlxyXG4gKiBcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XHJcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKiBcclxuICogICAtIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbiAqICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxyXG4gKiAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxyXG4gKiAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXHJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcclxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcclxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcclxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcclxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXHJcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXHJcbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXHJcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXHJcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbi8vIEByNTg3XHJcblxyXG4vKiBqc2hpbnQgZXMzOmZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZGVmID0gcmVxdWlyZSgnLi4vamFuaWNlay9jb3JlJykuZGVmO1xyXG5cclxudmFyIFZlY3RvcjNEID0gZnVuY3Rpb24gKHgsIHksIHosIHcpIHtcclxuICAgIHRoaXMudyA9IGRlZih3LCAwKTtcclxuICAgIHRoaXMueCA9IGRlZih4LCAwKTtcclxuICAgIHRoaXMueSA9IGRlZih5LCAwKTtcclxuICAgIHRoaXMueiA9IGRlZih6LCAwKTtcclxufTtcclxuXHJcblZlY3RvcjNELnByb3RvdHlwZSA9IHtcclxuXHJcbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMobW9kdWxlLmV4cG9ydHMuZGlzdGFuY2UodGhpcywgbW9kdWxlLmV4cG9ydHMubWFrZSgpKSk7XHJcbiAgICB9LFxyXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuZ2V0TGVuZ3RoKCk7IH0sXHJcblxyXG4gICAgZ2V0TGVuZ3RoU3F1YXJlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAqIHRoaXMubGVuZ3RoO1xyXG4gICAgfSxcclxuICAgIGdldCBsZW5ndGhTcXVhcmVkKCkgeyByZXR1cm4gdGhpcy5nZXRMZW5ndGhTcXVhcmVkKCk7IH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cy5tYWtlKHRoaXMueCArIGEueCwgdGhpcy55ICsgYS55LCB0aGlzLnogKyBhLnopO1xyXG4gICAgfSxcclxuXHJcbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cy5tYWtlKHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyb3NzUHJvZHVjdDogZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMubWFrZSh0aGlzLnkgKiBhLnogLSB0aGlzLnogKiBhLnksIHRoaXMueiAqIGEueCAtIHRoaXMueCAqIGEueiwgdGhpcy54ICogYS55IC0gdGhpcy55ICogYS54LCAxKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGVjcmVtZW50Qnk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdGhpcy54IC09IGEueDtcclxuICAgICAgICB0aGlzLnkgLT0gYS55O1xyXG4gICAgICAgIHRoaXMueiAtPSBhLno7XHJcbiAgICB9LFxyXG5cclxuICAgIGRvdFByb2R1Y3Q6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIGEueCArIHRoaXMueSAqIGEueSArIHRoaXMueiAqIGEuejtcclxuICAgIH0sXHJcblxyXG4gICAgZXF1YWxzOiBmdW5jdGlvbiAodG9Db21wYXJlLCBhbGxGb3VyKSB7XHJcbiAgICAgICAgYWxsRm91ciA9IGRlZihhbGxGb3VyLCBmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gdG9Db21wYXJlLnggJiYgdGhpcy55ID09PSB0b0NvbXBhcmUueSAmJiB0aGlzLnogPT09IHRvQ29tcGFyZS56ICYmICghYWxsRm91ciB8fCB0aGlzLncgPT09IHRvQ29tcGFyZS53KTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5jcmVtZW50Qnk6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdGhpcy54ICs9IGEueDtcclxuICAgICAgICB0aGlzLnkgKz0gYS55O1xyXG4gICAgICAgIHRoaXMueiArPSBhLno7XHJcbiAgICB9LFxyXG5cclxuICAgIG5lYXJFcXVhbHM6IGZ1bmN0aW9uICh0b0NvbXBhcmUsIHRvbGVyYW5jZSwgYWxsRm91cikge1xyXG4gICAgICAgIGFsbEZvdXIgPSBkZWYoYWxsRm91ciwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB0b0NvbXBhcmUueCkgPCB0b2xlcmFuY2UgJiZcclxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy55IC0gdG9Db21wYXJlLnkpIDwgdG9sZXJhbmNlICYmXHJcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMueiAtIHRvQ29tcGFyZS56KSA8IHRvbGVyYW5jZSAmJlxyXG4gICAgICAgICAgICAoIWFsbEZvdXIgfHwgTWF0aC5hYnModGhpcy53IC0gdG9Db21wYXJlLncpIDwgdG9sZXJhbmNlKTtcclxuICAgIH0sXHJcblxyXG4gICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy54ICo9IC0xO1xyXG4gICAgICAgIHRoaXMueSAqPSAtMTtcclxuICAgICAgICB0aGlzLnogKj0gLTE7XHJcbiAgICB9LFxyXG5cclxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGwgIT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy54IC89IGw7XHJcbiAgICAgICAgICAgIHRoaXMueSAvPSBsO1xyXG4gICAgICAgICAgICB0aGlzLnogLz0gbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGw7XHJcbiAgICB9LFxyXG5cclxuICAgIHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnggLz0gdGhpcy53O1xyXG4gICAgICAgIHRoaXMueSAvPSB0aGlzLnc7XHJcbiAgICAgICAgdGhpcy56IC89IHRoaXMudztcclxuICAgIH0sXHJcblxyXG4gICAgc2NhbGVCeTogZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICB0aGlzLnggKj0gcztcclxuICAgICAgICB0aGlzLnkgKj0gcztcclxuICAgICAgICB0aGlzLnogKj0gcztcclxuICAgIH0sXHJcblxyXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzLm1ha2UodGhpcy54IC0gYS54LCB0aGlzLnkgLSBhLnksIHRoaXMueiAtIGEueik7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdWZWN0b3IzRCgnICsgdGhpcy54ICsgJywgJyArIHRoaXMueSArICcsICcgKyB0aGlzLnogKyAnKSc7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIG1ha2U6IGZ1bmN0aW9uICh4LCB5LCB6LCB3KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzRCh4LCB5LCB6LCB3KTtcclxuICAgIH0sXHJcblxyXG4gICAgYW5nbGVCZXR3ZWVuOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBhMCA9IGEuY2xvbmUoKTtcclxuICAgICAgICBhMC5ub3JtYWxpemUoKTtcclxuICAgICAgICB2YXIgYjAgPSBiLmNsb25lKCk7XHJcbiAgICAgICAgYjAubm9ybWFsaXplKCk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhhMC5kb3RQcm9kdWN0KGIwKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAocHQxLCBwdDIpIHtcclxuICAgICAgICB2YXIgeCA9IHB0Mi54IC0gcHQxLng7XHJcbiAgICAgICAgdmFyIHkgPSBwdDIueSAtIHB0MS55O1xyXG4gICAgICAgIHZhciB6ID0gcHQyLnogLSBwdDEuejtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldCBYX0FYSVMoKSB7IHJldHVybiB0aGlzLm1ha2UoMSwgMCwgMCk7IH0sXHJcbiAgICBnZXQgWV9BWElTKCkgeyByZXR1cm4gdGhpcy5tYWtlKDAsIDEsIDApOyB9LFxyXG4gICAgZ2V0IFpfQVhJUygpIHsgcmV0dXJuIHRoaXMubWFrZSgwLCAwLCAxKTsgfVxyXG59O1xyXG4iLCIvKiBqc2hpbnQgY2FtZWxjYXNlOmZhbHNlICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciBjYW52YXNDb3JlID0gcmVxdWlyZSgnLi9qYW5pY2VrL2NhbnZhcycpO1xyXG52YXIgY2FudmFzUmVuZGVyTW9kdWxlID0gcmVxdWlyZSgnLi92b3Jvbm9pbWFwL2NhbnZhcy1yZW5kZXInKTtcclxudmFyIGNvbG9yTW9kdWxlID0gcmVxdWlyZSgnLi9qYW5pY2VrL2h0bWwtY29sb3InKTtcclxudmFyIGlzbGFuZFNoYXBlTW9kdWxlID0gcmVxdWlyZSgnLi92b3Jvbm9pbWFwL2lzbGFuZC1zaGFwZScpO1xyXG52YXIgbGF2YU1vZHVsZSA9IHJlcXVpcmUoJy4vdm9yb25vaW1hcC9sYXZhJyk7XHJcbnZhciBtYXBNb2R1bGUgPSByZXF1aXJlKCcuL3Zvcm9ub2ltYXAvbWFwJyk7XHJcbnZhciBub2lzeUVkZ2VzTW9kdWxlID0gcmVxdWlyZSgnLi92b3Jvbm9pbWFwL25vaXN5LWVkZ2VzJyk7XHJcbnZhciBwcm5nID0gcmVxdWlyZSgnLi9qYW5pY2VrL3BzZXVkby1yYW5kb20tbnVtYmVyLWdlbmVyYXRvcnMnKTtcclxudmFyIHJvYWRzTW9kdWxlID0gcmVxdWlyZSgnLi92b3Jvbm9pbWFwL3JvYWRzJyk7XHJcbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuL2phbmljZWsvc3RyaW5nJyk7XHJcbnZhciBzdHlsZSA9IHJlcXVpcmUoJy4vdm9yb25vaW1hcC9zdHlsZScpO1xyXG52YXIgd2F0ZXJzaGVkc01vZHVsZSA9IHJlcXVpcmUoJy4vdm9yb25vaW1hcC93YXRlcnNoZWRzJyk7XHJcbnZhciB0aW1lciA9IHJlcXVpcmUoJy4vamFuaWNlay90aW1lcicpKCk7XHJcblxyXG52YXIgaHRtbCA9IHtcclxuICAgIElEX21hcDogJ21hcCcsXHJcblxyXG4gICAgU19hZGROb2lzZTogJyNhZGROb2lzZScsXHJcbiAgICBTX2VkZ2VOb2lzZTogJyNlZGdlTm9pc2UnLFxyXG4gICAgU19maWVsZHM6ICcjZmllbGRzJyxcclxuICAgIFNfZmllbGRzZXQ6ICcjZmllbGRzZXQnLFxyXG4gICAgU19nZW5lcmF0ZTogJyNnZW5lcmF0ZScsXHJcbiAgICBTX2hlaWdodDogJyNoZWlnaHQnLFxyXG4gICAgU19pbWFnZUZpbGU6ICcjaW1hZ2VGaWxlJyxcclxuICAgIFNfaW1hZ2VUaHJlc2hvbGQ6ICcjaW1hZ2VUaHJlc2hvbGQnLFxyXG4gICAgU19pbWFnZVRodW1iOiAnI2ltYWdlVGh1bWInLFxyXG4gICAgU19pbnZlcnRJbWFnZTogJyNpbnZlcnRJbWFnZScsXHJcbiAgICBTX2lzbGFuZEZhY3RvcjogJyNpc2xhbmRGYWN0b3InLFxyXG4gICAgU19pc2xhbmRTaGFwZTogJyNpc2xhbmRTaGFwZScsXHJcbiAgICBTX2xha2VUaHJlc2hvbGQ6ICcjbGFrZVRocmVzaG9sZCcsXHJcbiAgICBTX2xsb3lkSXRlcmF0aW9uczogJyNsbG95ZEl0ZXJhdGlvbnMnLFxyXG4gICAgU19tYXA6ICcjbWFwJyxcclxuICAgIFNfbnVtYmVyT2ZMYW5kczogJyNudW1iZXJPZkxhbmRzJyxcclxuICAgIFNfbnVtYmVyT2ZQb2ludHM6ICcjbnVtYmVyT2ZQb2ludHMnLFxyXG4gICAgU19vY2VhblJhdGlvOiAnI29jZWFuUmF0aW8nLFxyXG4gICAgU19yYW5kb206ICcjcmFuZG9tJyxcclxuICAgIFNfcml2ZXJDaGFuY2U6ICcjcml2ZXJDaGFuY2UnLFxyXG4gICAgU19yb2FkRWxldmF0aW9uVGhyZXNob2xkczogJyNyb2FkRWxldmF0aW9uVGhyZXNob2xkcycsXHJcbiAgICBTX3NlZWQ6ICcjc2VlZCcsXHJcbiAgICBTX3NoYXBlUmFuZG9tOiAnI3NoYXBlUmFuZG9tJyxcclxuICAgIFNfc2hhcGVTZWVkOiAnI3NoYXBlU2VlZCcsXHJcbiAgICBTX3RvZ2dsZTogJyN0b2dnbGUnLFxyXG4gICAgU192aWV3OiAnI3ZpZXcnLFxyXG4gICAgU192aWV3QnJpZGdlczogJyN2aWV3QnJpZGdlcycsXHJcbiAgICBTX3ZpZXdFZGdlczogJyN2aWV3RWRnZXMnLFxyXG4gICAgU192aWV3Uml2ZXJzOiAnI3ZpZXdSaXZlcnMnLFxyXG4gICAgU192aWV3Um9hZHM6ICcjdmlld1JvYWRzJyxcclxuICAgIFNfdmlld1dhdGVyc2hlZHM6ICcjdmlld1dhdGVyc2hlZHMnLFxyXG4gICAgU193aWR0aDogJyN3aWR0aCdcclxufTtcclxuXHJcbnZhciBpbWFnZTtcclxudmFyIHN0YXRlO1xyXG5cclxuZnVuY3Rpb24gdXBkYXRlVGh1bWIoKSB7XHJcbiAgICB2YXIgdGhyZXNob2xkID0gJChodG1sLlNfaW1hZ2VUaHJlc2hvbGQpLnZhbCgpO1xyXG4gICAgdmFyIGNvbG9yMSA9IHN0eWxlLmRpc3BsYXlDb2xvcnMuT0NFQU47XHJcbiAgICB2YXIgY29sb3IyID0gc3R5bGUuZGlzcGxheUNvbG9ycy5HUkFTU0xBTkQ7XHJcbiAgICBpZiAoJChodG1sLlNfaW52ZXJ0SW1hZ2UpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgICAgdmFyIGNvbG9ySG9sZCA9IGNvbG9yMTtcclxuICAgICAgICBjb2xvcjEgPSBjb2xvcjI7XHJcbiAgICAgICAgY29sb3IyID0gY29sb3JIb2xkO1xyXG4gICAgfVxyXG4gICAgdmFyIHRocmVzaG9sZEltYWdlRGF0YSA9IGNhbnZhc0NvcmUubWFrZUF2ZXJhZ2VUaHJlc2hvbGRJbWFnZURhdGEoY2FudmFzQ29yZS5nZXRJbWFnZURhdGEoaW1hZ2UpLCB0aHJlc2hvbGQsIGNvbG9yMSwgY29sb3IyKTtcclxuICAgIHZhciBpbWFnZURhdGFVcmwgPSBjYW52YXNDb3JlLm1ha2VJbWFnZURhdGFVcmxGcm9tSW1hZ2VEYXRhKHRocmVzaG9sZEltYWdlRGF0YSk7XHJcbiAgICAkKGh0bWwuU19pbWFnZVRodW1iKS5hdHRyKCdzcmMnLCBpbWFnZURhdGFVcmwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXIoc3RhdGUpIHtcclxuICAgIHZhciBjID0gZXhwb3J0cy5nZXRDb250ZXh0KCk7XHJcbiAgICBjYW52YXNSZW5kZXJNb2R1bGUuZ3JhcGhpY3NSZXNldChjLCBzdGF0ZS5tYXAuU0laRS53aWR0aCwgc3RhdGUubWFwLlNJWkUuaGVpZ2h0LCBzdHlsZS5kaXNwbGF5Q29sb3JzKTtcclxuICAgIHN3aXRjaCAoJChodG1sLlNfdmlldykudmFsKCkpIHtcclxuICAgIGNhc2UgJ2RlYnVnIHBvbHlnb25zJzpcclxuICAgICAgICBjYW52YXNSZW5kZXJNb2R1bGUucmVuZGVyRGVidWdQb2x5Z29ucyhjLCBzdGF0ZS5tYXAsIHN0eWxlLmRpc3BsYXlDb2xvcnMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnc21vb3RoJzpcclxuICAgICAgICBjYW52YXNSZW5kZXJNb2R1bGUucmVuZGVyUG9seWdvbnMoYywgc3R5bGUuZGlzcGxheUNvbG9ycywgbnVsbCwgY2FudmFzUmVuZGVyTW9kdWxlLmNvbG9yV2l0aFNsb3BlLCBzdGF0ZS5tYXAsIHN0YXRlLm5vaXN5RWRnZXMpO1xyXG4gICAgICAgIGNhbnZhc1JlbmRlck1vZHVsZS5yZW5kZXJFZGdlcyhjLCBzdHlsZS5kaXNwbGF5Q29sb3JzLCBzdGF0ZS5tYXAsIHN0YXRlLm5vaXN5RWRnZXMsIHN0YXRlLmxhdmEsICQoaHRtbC5TX3ZpZXdSaXZlcnMpLmlzKCc6Y2hlY2tlZCcpKTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoJChodG1sLlNfdmlld0VkZ2VzKS5pcygnOmNoZWNrZWQnKSkge1xyXG4gICAgICAgIGNhbnZhc1JlbmRlck1vZHVsZS5yZW5kZXJBbGxFZGdlcyhjLCBjb2xvck1vZHVsZS5yZ2JhKDB4ZDAsIDB4ZDAsIDB4ZDAsIDAuMjUpLCBzdGF0ZS5tYXAsIHN0YXRlLm5vaXN5RWRnZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgkKGh0bWwuU192aWV3Um9hZHMpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgICAgY2FudmFzUmVuZGVyTW9kdWxlLnJlbmRlclJvYWRzKGMsIHN0YXRlLm1hcCwgc3RhdGUucm9hZHMsIHN0eWxlLmRpc3BsYXlDb2xvcnMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoJChodG1sLlNfdmlld0JyaWRnZXMpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgICAgY2FudmFzUmVuZGVyTW9kdWxlLnJlbmRlckJyaWRnZXMoYywgc3RhdGUubWFwLCBzdGF0ZS5yb2Fkcywgc3R5bGUuZGlzcGxheUNvbG9ycyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICgkKGh0bWwuU192aWV3V2F0ZXJzaGVkcykuaXMoJzpjaGVja2VkJykpIHtcclxuICAgICAgICBjYW52YXNSZW5kZXJNb2R1bGUucmVuZGVyV2F0ZXJzaGVkcyhjLCBzdGF0ZS5tYXAsIHN0YXRlLndhdGVyc2hlZHMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoJChodG1sLlNfYWRkTm9pc2UpLmlzKCc6Y2hlY2tlZCcpKSB7XHJcbiAgICAgICAgY2FudmFzQ29yZS5hZGROb2lzZVRvQ2FudmFzKGMsIDY2NiwgMTAsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnRzLmluaXRpYWxpemVVaSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJChodG1sLlNfaW1hZ2VUaHVtYikuYXR0cignc3JjJywgaW1hZ2Uuc3JjKTtcclxuICAgICAgICB1cGRhdGVUaHVtYigpO1xyXG4gICAgfTtcclxuICAgIGltYWdlLnNyYyA9ICd3b3JsZC1tYXAuanBnJztcclxuICAgIFxyXG4gICAgJChodG1sLlNfcmFuZG9tKS5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJChodG1sLlNfc2VlZCkudmFsKFN0cmluZyhwcm5nLm1ha2VSYW5kb21TZWVkKCkpKTtcclxuICAgIH0pO1xyXG4gICAgJChodG1sLlNfc2hhcGVSYW5kb20pLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkKGh0bWwuU19zaGFwZVNlZWQpLnZhbChTdHJpbmcocHJuZy5tYWtlUmFuZG9tU2VlZCgpKSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgJChodG1sLlNfaXNsYW5kU2hhcGUpLmNoYW5nZShmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICQoW2h0bWwuU19pc2xhbmRGYWN0b3IsIGh0bWwuU19vY2VhblJhdGlvLCBodG1sLlNfc2hhcGVTZWVkLCBodG1sLlNfaW1hZ2VGaWxlLCBodG1sLlNfaW1hZ2VUaHVtYiwgaHRtbC5TX2ludmVydEltYWdlLCBodG1sLlNfaW1hZ2VUaHJlc2hvbGRdLnRvU3RyaW5nKCkpLnBhcmVudCgpLmhpZGUoKTtcclxuICAgICAgICBzd2l0Y2ggKCQoaHRtbC5TX2lzbGFuZFNoYXBlKS52YWwoKSkge1xyXG4gICAgICAgIGNhc2UgJ2JpdG1hcCc6XHJcbiAgICAgICAgICAgICQoW2h0bWwuU19pbWFnZUZpbGUsIGh0bWwuU19pbWFnZVRodW1iLCBodG1sLlNfaW52ZXJ0SW1hZ2UsIGh0bWwuU19pbWFnZVRocmVzaG9sZF0udG9TdHJpbmcoKSkucGFyZW50KCkuc2hvdygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdub2lzZSc6XHJcbiAgICAgICAgICAgICQoaHRtbC5TX3NoYXBlU2VlZCkucGFyZW50KCkuc2hvdygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdwZXJsaW4nOlxyXG4gICAgICAgICAgICAkKFtodG1sLlNfb2NlYW5SYXRpbywgaHRtbC5TX3NoYXBlU2VlZF0udG9TdHJpbmcoKSkucGFyZW50KCkuc2hvdygpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdyYWRpYWwnOlxyXG4gICAgICAgICAgICAkKFtodG1sLlNfaXNsYW5kRmFjdG9yLCBodG1sLlNfc2hhcGVTZWVkXS50b1N0cmluZygpKS5wYXJlbnQoKS5zaG93KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAkKGh0bWwuU19pbWFnZUZpbGUpLmNoYW5nZShmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdmaWxlIGNoYW5nZWQnKTtcclxuICAgICAgICB2YXIgZmlsZVVwbG9hZCA9ICQoaHRtbC5TX2ltYWdlRmlsZSkuZ2V0KClbMF07XHJcbiAgICAgICAgdmFyIGZpbGVzID0gZmlsZVVwbG9hZC5maWxlcztcclxuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbMF07XHJcbiAgICAgICAgICAgIGlmIChzdHJpbmcoZmlsZS50eXBlKS5zdGFydHNXaXRoKCdpbWFnZScpKSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNDb3JlLmxvYWRGaWxlSW50b0ltYWdlKGZpbGUsIGltYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgICQoW2h0bWwuU19pbnZlcnRJbWFnZSwgaHRtbC5TX2ltYWdlVGhyZXNob2xkXS50b1N0cmluZygpKS5jaGFuZ2UoZnVuY3Rpb24gKGUpIHsgdXBkYXRlVGh1bWIoKTsgfSk7XHJcbiAgICBcclxuICAgIGlmICgkKGh0bWwuU193aWR0aCkudmFsKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgJChodG1sLlNfd2lkdGgpLnZhbChTdHJpbmcod2luZG93LmlubmVyV2lkdGgpKTtcclxuICAgIH1cclxuICAgIGlmICgkKGh0bWwuU19oZWlnaHQpLnZhbCgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICQoaHRtbC5TX2hlaWdodCkudmFsKFN0cmluZyh3aW5kb3cuaW5uZXJIZWlnaHQpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgJChodG1sLlNfdmlldykuY2hhbmdlKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgc3dpdGNoICgkKGh0bWwuU192aWV3KS52YWwoKSkge1xyXG4gICAgICAgIGNhc2UgJ2RlYnVnIHBvbHlnb25zJzpcclxuICAgICAgICAgICAgJChodG1sLlNfYWRkTm9pc2UpLnJlbW92ZUF0dHIoJ2NoZWNrZWQnKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc21vb3RoJzpcclxuICAgICAgICAgICAgJChodG1sLlNfYWRkTm9pc2UpLmF0dHIoJ2NoZWNrZWQnLCAndHJ1ZScpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgJChbaHRtbC5TX3ZpZXcsIGh0bWwuU192aWV3Uml2ZXJzLCBodG1sLlNfdmlld1JvYWRzLCBodG1sLlNfdmlld0JyaWRnZXMsIGh0bWwuU192aWV3V2F0ZXJzaGVkcywgaHRtbC5TX3ZpZXdFZGdlcywgaHRtbC5TX2FkZE5vaXNlXS50b1N0cmluZygpKS5jaGFuZ2UoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZW5kZXIoc3RhdGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJChodG1sLlNfdmlld1JvYWRzKS5jaGFuZ2UoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAkKGh0bWwuU19yb2FkRWxldmF0aW9uVGhyZXNob2xkcykucGFyZW50KCkudG9nZ2xlKCk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgJChodG1sLlNfZ2VuZXJhdGUpLmNsaWNrKGZ1bmN0aW9uICgpIHsgc3RhdGUgPSBleHBvcnRzLmdlbmVyYXRlKCk7IH0pO1xyXG4gICAgXHJcbiAgICAkKGh0bWwuU190b2dnbGUpLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZmllbGRzID0gJChodG1sLlNfZmllbGRzKTtcclxuICAgICAgICBmaWVsZHMudG9nZ2xlKDUwMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAkKGh0bWwuU190b2dnbGUpLnRleHQoZmllbGRzLmlzKCc6dmlzaWJsZScpID8gJ2hpZGUnIDogJ3Nob3cnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuZXhwb3J0cy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGh0bWwuSURfbWFwKTtcclxuICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGZpbmRPckNyZWF0ZUNhbnZhcygpIHtcclxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sLklEX21hcCk7XHJcbiAgICBpZiAoY2FudmFzID09PSBudWxsKSB7XHJcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgY2FudmFzLmlkID0gaHRtbC5JRF9tYXA7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gY2FudmFzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRJbnRlZ2VyT3JTdHJpbmdTZWVkKHMpIHtcclxuICAgIGlmIChfKHMpLmlzTnVtYmVyKCkpIHtcclxuICAgICAgICByZXR1cm4gXyhzKS5wYXJzZUludCgpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gTWF0aC5hYnMocHJuZy5zdHJpbmdUb1NlZWQocykpO1xyXG59XHJcblxyXG5leHBvcnRzLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGltZXIuc3RhcnQoKTtcclxuXHJcbiAgICB2YXIgc3RhdGUgPSB7IG1hcCA6IG51bGwsIG5vaXN5RWRnZXMgOiBudWxsLCByb2FkcyA6IG51bGwsIHdhdGVyc2hlZHMgOiBudWxsLCBsYXZhIDogbnVsbCB9O1xyXG4gICAgXHJcbiAgICB2YXIgY2FudmFzID0gZmluZE9yQ3JlYXRlQ2FudmFzKCk7XHJcbiAgICBjYW52YXMud2lkdGggPSBfKCQoaHRtbC5TX3dpZHRoKS52YWwoKSkucGFyc2VJbnQoKTtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBfKCQoaHRtbC5TX2hlaWdodCkudmFsKCkpLnBhcnNlSW50KCk7XHJcbiAgICBcclxuICAgIHN0YXRlLm1hcCA9IG1hcE1vZHVsZS5tYWtlKHsgd2lkdGg6IGNhbnZhcy53aWR0aCArIDAuMCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0ICsgMC4wIH0pO1xyXG4gICAgdmFyIHNlZWQgPSBnZXRJbnRlZ2VyT3JTdHJpbmdTZWVkKCQoaHRtbC5TX3NlZWQpLnZhbCgpKTtcclxuICAgIHZhciBzaGFwZVNlZWQgPSBnZXRJbnRlZ2VyT3JTdHJpbmdTZWVkKCQoaHRtbC5TX3NoYXBlU2VlZCkudmFsKCkpO1xyXG4gICAgXHJcbiAgICB2YXIgaXNsYW5kU2hhcGUgPSAkKGh0bWwuU19pc2xhbmRTaGFwZSkudmFsKCk7XHJcbiAgICBcclxuICAgIHN3aXRjaCAoaXNsYW5kU2hhcGUpIHtcclxuICAgIGNhc2UgJ2JpdG1hcCcgOlxyXG4gICAgICAgIHZhciBpbWFnZURhdGEgPSBjYW52YXNDb3JlLmdldEltYWdlRGF0YShpbWFnZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJChodG1sLlNfaW1hZ2VUaHJlc2hvbGQpLnZhbCgpKTtcclxuICAgICAgICB2YXIgYml0bWFwID0gY2FudmFzQ29yZS5tYWtlQXZlcmFnZVRocmVzaG9sZEJpdG1hcChpbWFnZURhdGEsICQoaHRtbC5TX2ltYWdlVGhyZXNob2xkKS52YWwoKSk7XHJcbiAgICAgICAgaWYgKCQoaHRtbC5TX2ludmVydEltYWdlKS5pcygnOmNoZWNrZWQnKSkge1xyXG4gICAgICAgICAgICBiaXRtYXAgPSBiaXRtYXAuaW52ZXJ0Qml0bWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLm1hcC5uZXdJc2xhbmQoaXNsYW5kU2hhcGVNb2R1bGUubWFrZUJpdG1hcChiaXRtYXApLCBzZWVkKTtcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgJ2Jsb2InIDpcclxuICAgICAgICBzdGF0ZS5tYXAubmV3SXNsYW5kKGlzbGFuZFNoYXBlTW9kdWxlLm1ha2VCbG9iKCksIHNlZWQpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnbm9pc2UnIDpcclxuICAgICAgICBzdGF0ZS5tYXAubmV3SXNsYW5kKGlzbGFuZFNoYXBlTW9kdWxlLm1ha2VOb2lzZShzaGFwZVNlZWQpLCBzZWVkKTtcclxuICAgICAgICBicmVhaztcclxuICAgIGNhc2UgJ3BlcmxpbicgOlxyXG4gICAgICAgIHN0YXRlLm1hcC5uZXdJc2xhbmQoaXNsYW5kU2hhcGVNb2R1bGUubWFrZVBlcmxpbihzaGFwZVNlZWQsICQoaHRtbC5TX29jZWFuUmF0aW8pLnZhbCgpKSwgc2VlZCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdyYWRpYWwnIDpcclxuICAgICAgICBzdGF0ZS5tYXAubmV3SXNsYW5kKGlzbGFuZFNoYXBlTW9kdWxlLm1ha2VSYWRpYWwoc2hhcGVTZWVkLCAkKGh0bWwuU19pc2xhbmRGYWN0b3IpLnZhbCgpKSwgc2VlZCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdzcXVhcmUnIDpcclxuICAgICAgICBzdGF0ZS5tYXAubmV3SXNsYW5kKGlzbGFuZFNoYXBlTW9kdWxlLm1ha2VTcXVhcmUoKSwgc2VlZCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHN0YXRlLndhdGVyc2hlZHMgPSB3YXRlcnNoZWRzTW9kdWxlKCk7XHJcbiAgICBzdGF0ZS5ub2lzeUVkZ2VzID0gbm9pc3lFZGdlc01vZHVsZS5tYWtlKCk7XHJcbiAgICBzdGF0ZS5sYXZhID0gbGF2YU1vZHVsZS5tYWtlKCk7XHJcbiAgICBzdGF0ZS5yb2FkcyA9IHJvYWRzTW9kdWxlKCk7XHJcbiAgICBcclxuICAgIHZhciBudW1iZXJPZkxhbmRzID0gJChodG1sLlNfbnVtYmVyT2ZMYW5kcykudmFsKCk7XHJcbiAgICBpZiAoXyhudW1iZXJPZkxhbmRzKS5pc051bWJlcigpKSB7XHJcbiAgICAgICAgbWFwTW9kdWxlLnRyeU11dGF0ZU1hcFBvaW50c1RvR2V0TnVtYmVyTGFuZHMoc3RhdGUubWFwLCBudW1iZXJPZkxhbmRzLCAzMCwgbnVtYmVyT2ZMYW5kcyAqIDIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3RhdGUubWFwLmdvMFBsYWNlUG9pbnRzKCQoaHRtbC5TX251bWJlck9mUG9pbnRzKS52YWwoKSk7XHJcbiAgICAgICAgc3RhdGUubWFwLmdvMUltcHJvdmVQb2ludHMoJChodG1sLlNfbGxveWRJdGVyYXRpb25zKS52YWwoKSk7XHJcbiAgICAgICAgc3RhdGUubWFwLmdvMkJ1aWxkR3JhcGgoKTtcclxuICAgICAgICBzdGF0ZS5tYXAuZ28zQXNzaWduRWxldmF0aW9ucygkKGh0bWwuU19sYWtlVGhyZXNob2xkKS52YWwoKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0ZS5tYXAuZ280QXNzaWduTW9pc3R1cmUoJChodG1sLlNfcml2ZXJDaGFuY2UpLnZhbCgpKTtcclxuICAgIHN0YXRlLm1hcC5nbzVEZWNvcmF0ZU1hcCgpO1xyXG4gICAgXHJcbiAgICB2YXIgdGhyZXNob2xkcyA9ICQoaHRtbC5TX3JvYWRFbGV2YXRpb25UaHJlc2hvbGRzKS52YWwoKS5zcGxpdCgnLCcpO1xyXG4gICAgc3RhdGUucm9hZHMuY3JlYXRlUm9hZHMoc3RhdGUubWFwLCB0aHJlc2hvbGRzKTtcclxuICAgIHN0YXRlLndhdGVyc2hlZHMuY3JlYXRlV2F0ZXJzaGVkcyhzdGF0ZS5tYXApO1xyXG4gICAgc3RhdGUubm9pc3lFZGdlcy5idWlsZE5vaXN5RWRnZXMoc3RhdGUubWFwLCBzdGF0ZS5sYXZhLCBzZWVkLCAkKGh0bWwuU19lZGdlTm9pc2UpLnZhbCgpKTtcclxuXHJcbiAgICB0aW1lci5sb2coJ2dlbmVyYXRlJyk7XHJcbiAgICBcclxuICAgIHJlbmRlcihzdGF0ZSk7XHJcblxyXG4gICAgdGltZXIubG9nKCdyZW5kZXInKTtcclxuXHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIE1haW5cclxuXHJcbmZ1bmN0aW9uIG1haW4oKSB7XHJcbiAgICBleHBvcnRzLmluaXRpYWxpemVVaSgpO1xyXG4gICAgc3RhdGUgPSBleHBvcnRzLmdlbmVyYXRlKCk7XHJcbiAgICByZXF1aXJlKCcuL2phbmljZWsvbG9nJykubG9nQ291bnRlcnMoKTtcclxufVxyXG5cclxubWFpbigpOyIsIi8qIGpzaGludCBiaXR3aXNlOmZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5cclxuLyoqXHJcbiAqIFR3byBkaW1lbnNpb25hbCBhcnJheSBmdW5jdGlvbnMuXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgYXJyYXkgPSBjb3JlLmRlZihhcnJheSwgW10pO1xyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICAgICAgdmFsdWU6IGFycmF5LFxyXG5cclxuICAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHZhbHVlIGF0IGluZGV4LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgaWYgKF8oYXJyYXlbeV0pLmlzVW5kZWZpbmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheVt5XVt4XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdmFsdWUgYXQgaW5kZXguXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoeCwgeSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgYXJyYXlbeV0gPSBjb3JlLmRlZihhcnJheVt5XSwgW10pO1xyXG4gICAgICAgICAgICBhcnJheVt5XVt4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcHV0ZSB0d28gZGltZW5zaW9uYWwgaW5kaWNlcyBvZiBhIGZsYXQgaW5kZXggYmFzZWQgb24gYXJyYXkgd2lkdGggYW5kIGJsb2NrIHNpemUuXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHdpZHRoXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGJsb2NrU2l6ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEluZGljZXM6IGZ1bmN0aW9uIChpbmRleCwgd2lkdGgsIGJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICBibG9ja1NpemUgPSBjb3JlLmRlZihibG9ja1NpemUsIDEpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeCA6IChpbmRleCAvIGJsb2NrU2l6ZSkgJSB3aWR0aCxcclxuICAgICAgICAgICAgICAgIHkgOiBjb3JlLnRvSW50KChpbmRleCAvIGJsb2NrU2l6ZSkgLyB3aWR0aClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdGVyYXRlIHJvd3MuXHJcbiAgICAgICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHJldHVyblJvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZvcmVhY2hZOiBmdW5jdGlvbiAocmV0dXJuUm93KSB7XHJcbiAgICAgICAgICAgIF8oYXJyYXkpLmVhY2goZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghXyh5KS5pc1VuZGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuUm93KHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdGVyYXRlIGNlbGxzLlxyXG4gICAgICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSByZXR1cm5YWUFuZFZhbHVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9yZWFjaFhZOiBmdW5jdGlvbiAocmV0dXJuWFlBbmRWYWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgeUluZGV4O1xyXG4gICAgICAgICAgICBmb3IgKHlJbmRleCA9IDA7IHlJbmRleCA8IGFycmF5Lmxlbmd0aDsgeUluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIGlmICghXyhhcnJheVt5SW5kZXhdKS5pc1VuZGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHhJbmRleCA9IDA7IHhJbmRleCA8IGFycmF5W3lJbmRleF0ubGVuZ3RoOyB4SW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV8oYXJyYXlbeUluZGV4XVt4SW5kZXhdKS5pc1VuZGVmaW5lZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVt5SW5kZXhdW3hJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5YWUFuZFZhbHVlKHhJbmRleCwgeUluZGV4LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIGluZGV4IG9mIGFueXRoaW5nIGluIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB0ZXN0VmFsdWUgRnVuY3Rpb24gc2hvdWxkIHJldHVybiB0cnVlIGZvciBtYXRjaCwgZWxzZSBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBhbnk6IGZ1bmN0aW9uICh0ZXN0VmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHlJbmRleDtcclxuICAgICAgICAgICAgZm9yICh5SW5kZXggPSAwOyB5SW5kZXggPCBhcnJheS5sZW5ndGg7IHlJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV8oYXJyYXlbeUluZGV4XSkuaXNVbmRlZmluZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh4SW5kZXggPSAwOyB4SW5kZXggPCBhcnJheVt5SW5kZXhdLmxlbmd0aDsgeEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfKGFycmF5W3lJbmRleF1beEluZGV4XSkuaXNVbmRlZmluZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbeUluZGV4XVt4SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt4OiB4SW5kZXgsIHk6IHlJbmRleCB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgZGltZW5zaW9ucyBvZiBhcnJheS5cclxuICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IHggaXMgd2lkdGgsIHkgaXMgaGVpZ2h0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGltZW5zaW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5mb3JlYWNoWShmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgeS5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7eDogd2lkdGgsIHk6IGhlaWdodH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xyXG52YXIgaHRtbENvbG9yID0gcmVxdWlyZSgnLi9odG1sLWNvbG9yJyk7XHJcbnZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XHJcbnZhciBwcm5nID0gcmVxdWlyZSgnLi9wc2V1ZG8tcmFuZG9tLW51bWJlci1nZW5lcmF0b3JzJyk7XHJcblxyXG5cclxudmFyIENBTlZBU19FTEVNRU5UU19QRVJfUElYRUwgPSA0O1xyXG52YXIgQ0FOVkFTX1JFRF9PRkZTRVQgPSAwO1xyXG52YXIgQ0FOVkFTX0dSRUVOX09GRlNFVCA9IDE7XHJcbnZhciBDQU5WQVNfQkxVRV9PRkZTRVQgPSAyO1xyXG52YXIgQ0FOVkFTX0FMUEhBX09GRlNFVCA9IDM7XHJcblxyXG5cclxuLyoqXHJcbiAqIEl0ZXJhdGUgY2FudmFzIHBpeGVsIGFycmF5IGNvbG9yIGNoYW5uZWxzLlxyXG4gKiBGdW5jdG9yIGlzIGNhbGxlZCB3aXRoIHJlZCwgZ3JlZW4sIGJsdWUsIGFuZCBhbHBoYSBjaGFubmVsIHZhbHVlcyBmb3IgZWFjaCBwaXhlbC5cclxuICogRnVuY3RvciBjYW4gcmV0dXJuIG5ldyBjb2xvciBjaGFubmVsIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFzc2lnbmVkIHRvIHBpeGVsLiBOdWxsIHZhbHVlcyBhcmUgaWdub3JlZC5cclxuICogXHJcbiAqIENhbiBiZSB1c2VkIHRvIGFuYWx5emUgYW5kIHRyYW5zZm9ybSBhIGNhbnZhcyBwaXhlbCBhcnJheS5cclxuICovXHJcbmV4cG9ydHMucmVuZGVyQ2FudmFzUGl4ZWxBcnJheSA9IGZ1bmN0aW9uIChpbWFnZURhdGEsIGYpIHtcclxuICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgIHZhciBpbmRleDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29yZS50b0ludChwaXhlbHMubGVuZ3RoIC8gQ0FOVkFTX0VMRU1FTlRTX1BFUl9QSVhFTCk7IGkrKykge1xyXG4gICAgICAgIGluZGV4ID0gaSAqIENBTlZBU19FTEVNRU5UU19QRVJfUElYRUw7XHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IGYoaW5kZXgsIHBpeGVsc1tpbmRleCArIENBTlZBU19SRURfT0ZGU0VUXSwgcGl4ZWxzW2luZGV4ICsgQ0FOVkFTX0dSRUVOX09GRlNFVF0sIHBpeGVsc1tpbmRleCArIENBTlZBU19CTFVFX09GRlNFVF0sIHBpeGVsc1tpbmRleCArIENBTlZBU19BTFBIQV9PRkZTRVRdKTtcclxuICAgICAgICBpZiAobmV3VmFsdWVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZXMucmVkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwaXhlbHNbaW5kZXggKyBDQU5WQVNfUkVEX09GRlNFVF0gPSBuZXdWYWx1ZXMucmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZXMuZ3JlZW4gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHBpeGVsc1tpbmRleCArIENBTlZBU19HUkVFTl9PRkZTRVRdID0gbmV3VmFsdWVzLmdyZWVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZXMuYmx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxzW2luZGV4ICsgQ0FOVkFTX0JMVUVfT0ZGU0VUXSA9IG5ld1ZhbHVlcy5ibHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZXMuYWxwaGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHBpeGVsc1tpbmRleCArIENBTlZBU19BTFBIQV9PRkZTRVRdID0gbmV3VmFsdWVzLmFscGhhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZCByYW5kb20gbm9pc2UgdG8gaW1hZ2UgZGF0YSBieSBtb2RpZnlpbmcgZWFjaCBwaXhlbCBjb2xvciBjaGFubmVsIGJ5IGEgcmFuZG9tIGFtb3VudCBiZXR3ZWVuICsgYW5kIC0gbm9pc2VMZXZlbC5cclxuICogQHBhcmFtICAgbm9pc2VMZXZlbCBWYWx1ZSBiZXR3ZWVuIDEgYW5kIDI1NVxyXG4gKiBAcGFyYW0gICBncmF5U2NhbGUgVHJ1ZSB0byBjaGFuZ2UgYWxsIGNvbG9yIGNoYW5uZWxzIGJ5IHNhbWUgYW1vdW50IHNvIG9ubHkgYnJpZ2h0bmVzcyBvZiBwaXhlbCBpcyBjaGFuZ2VkIGFuZCBub3QgY29sb3IuIERvZXNuJ3QgYWZmZWN0IGFscGhhLiAoRGVmYXVsdCA9IGZhbHNlKVxyXG4gKiBAcGFyYW0gICByZWQgQWRkIG5vaXNlIHRvIHJlZCBjaGFubmVsLiAoRGVmYXVsdCA9IHRydWUpXHJcbiAqIEBwYXJhbSAgIGdyZWVuIEFkZCBub2lzZSB0byBncmVlbiBjaGFubmVsLiAoRGVmYXVsdCA9IHRydWUpXHJcbiAqIEBwYXJhbSAgIGJsdWUgQWRkIG5vaXNlIHRvIGJsdWUgY2hhbm5lbC4gKERlZmF1bHQgPSB0cnVlKVxyXG4gKiBAcGFyYW0gICBhbHBoYSBBZGQgbm9pc2UgdG8gYWxwaGEgY2hhbm5lbC4gKERlZmF1bHQgPSBmYWxzZSlcclxuICogQHJldHVybiAgTmV3IGJpdG1hcCBjb250YWluaW5nIHRoZSBiaXRtYXAgcGFzc2VkIGluIHdpdGggbm9pc2UgYWRkZWQuXHJcbiAqL1xyXG5leHBvcnRzLmFkZE5vaXNlID0gZnVuY3Rpb24gKHBpeGVsRGF0YSwgcmFuZG9tU2VlZCwgbm9pc2VMZXZlbCwgZ3JheVNjYWxlLCBjaGFuZ2VSZWQsIGNoYW5nZUdyZWVuLCBjaGFuZ2VCbHVlLCBjaGFuZ2VBbHBoYSkge1xyXG5cclxuICAgIGdyYXlTY2FsZSA9IGNvcmUuZGVmKGdyYXlTY2FsZSwgZmFsc2UpO1xyXG4gICAgY2hhbmdlUmVkID0gY29yZS5kZWYoY2hhbmdlUmVkLCB0cnVlKTtcclxuICAgIGNoYW5nZUdyZWVuID0gY29yZS5kZWYoY2hhbmdlR3JlZW4sIHRydWUpO1xyXG4gICAgY2hhbmdlQmx1ZSA9IGNvcmUuZGVmKGNoYW5nZUJsdWUsIHRydWUpO1xyXG4gICAgY2hhbmdlQWxwaGEgPSBjb3JlLmRlZihjaGFuZ2VBbHBoYSwgZmFsc2UpO1xyXG5cclxuICAgIHZhciBnZW4gPSBwcm5nLnJhbmRvbUdlbmVyYXRvcihyYW5kb21TZWVkLCBwcm5nLm5leHRQYXJrTWlsbGVyKTtcclxuXHJcbiAgICBub2lzZUxldmVsID0gbWF0aC5jbGFtcChub2lzZUxldmVsLCAxLCAyNTUpO1xyXG4gICAgdmFyIGRlbHRhO1xyXG4gICAgXHJcbiAgICBleHBvcnRzLnJlbmRlckNhbnZhc1BpeGVsQXJyYXkocGl4ZWxEYXRhLCBmdW5jdGlvbiAoaW5kZXgsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XHJcbiAgICAgICAgZGVsdGEgPSBwcm5nLnRvSW50UmFuZ2UoZ2VuKCksIC1ub2lzZUxldmVsLCBub2lzZUxldmVsKTtcclxuICAgICAgICB2YXIgbmV3Q29sb3JzID0geyByZWQ6IG51bGwsIGdyZWVuOiBudWxsLCBibHVlOiBudWxsLCBhbHBoYTogbnVsbCB9O1xyXG4gICAgICAgIGlmIChjaGFuZ2VSZWQpIHtcclxuICAgICAgICAgICAgbmV3Q29sb3JzLnJlZCA9IHJlZCArIGRlbHRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlR3JlZW4pIHtcclxuICAgICAgICAgICAgbmV3Q29sb3JzLmdyZWVuID0gZ3JlZW4gKyAoZ3JheVNjYWxlID8gZGVsdGEgOiBwcm5nLnRvSW50UmFuZ2UoZ2VuKCksIC1ub2lzZUxldmVsLCBub2lzZUxldmVsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VCbHVlKSB7XHJcbiAgICAgICAgICAgIG5ld0NvbG9ycy5ibHVlID0gYmx1ZSArIChncmF5U2NhbGUgPyBkZWx0YSA6IHBybmcudG9JbnRSYW5nZShnZW4oKSwgLW5vaXNlTGV2ZWwsIG5vaXNlTGV2ZWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZUFscGhhKSB7XHJcbiAgICAgICAgICAgIG5ld0NvbG9ycy5hbHBoYSA9IGFscGhhICsgcHJuZy50b0ludFJhbmdlKGdlbigpLCAtbm9pc2VMZXZlbCwgbm9pc2VMZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdDb2xvcnM7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHBpeGVsRGF0YTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgbm9pc2UgdG8gY2FudmFzLlxyXG4gKiBAcGFyYW0gICBjb250ZXh0IENhbnZhcyBkcmF3aW5nIGNvbnRleHQuXHJcbiAqIEBwYXJhbSAgIHJhbmRvbVNlZWQgUmFuZG9tIHNlZWQgdG8gdXNlIHRvIG1ha2UgcmFuZG9tIG5vaXNlLlxyXG4gKiBAcGFyYW0gICBub2lzZUxldmVsIFZhbHVlIGJldHdlZW4gMSBhbmQgMjU1XHJcbiAqIEBwYXJhbSAgIGdyYXlTY2FsZSBUcnVlIHRvIGNoYW5nZSBhbGwgY29sb3IgY2hhbm5lbHMgYnkgc2FtZSBhbW91bnQgc28gb25seSBicmlnaHRuZXNzIG9mIHBpeGVsIGlzIGNoYW5nZWQgYW5kIG5vdCBjb2xvci4gRG9lc24ndCBhZmZlY3QgYWxwaGEuIChEZWZhdWx0ID0gZmFsc2UpXHJcbiAqIEBwYXJhbSAgIHJlZCBBZGQgbm9pc2UgdG8gcmVkIGNoYW5uZWwuIChEZWZhdWx0ID0gdHJ1ZSlcclxuICogQHBhcmFtICAgZ3JlZW4gQWRkIG5vaXNlIHRvIGdyZWVuIGNoYW5uZWwuIChEZWZhdWx0ID0gdHJ1ZSlcclxuICogQHBhcmFtICAgYmx1ZSBBZGQgbm9pc2UgdG8gYmx1ZSBjaGFubmVsLiAoRGVmYXVsdCA9IHRydWUpXHJcbiAqIEBwYXJhbSAgIGFscGhhIEFkZCBub2lzZSB0byBhbHBoYSBjaGFubmVsLiAoRGVmYXVsdCA9IGZhbHNlKVxyXG4gKi9cclxuZXhwb3J0cy5hZGROb2lzZVRvQ2FudmFzID0gZnVuY3Rpb24gKGNvbnRleHQsIHJhbmRvbVNlZWQsIG5vaXNlTGV2ZWwsIGdyYXlTY2FsZSwgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcclxuICAgIGdyYXlTY2FsZSA9IGNvcmUuZGVmKGdyYXlTY2FsZSwgZmFsc2UpO1xyXG4gICAgcmVkID0gY29yZS5kZWYocmVkLCB0cnVlKTtcclxuICAgIGdyZWVuID0gY29yZS5kZWYoZ3JlZW4sIHRydWUpO1xyXG4gICAgYmx1ZSA9IGNvcmUuZGVmKGJsdWUsIHRydWUpO1xyXG4gICAgYWxwaGEgPSBjb3JlLmRlZihhbHBoYSwgZmFsc2UpO1xyXG5cclxuICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjb250ZXh0LmNhbnZhcy53aWR0aCwgY29udGV4dC5jYW52YXMuaGVpZ2h0KTtcclxuICAgIGltYWdlRGF0YSA9IGV4cG9ydHMuYWRkTm9pc2UoaW1hZ2VEYXRhLCByYW5kb21TZWVkLCBub2lzZUxldmVsLCBncmF5U2NhbGUsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKTtcclxuICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XHJcbn07XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gSW1hZ2VzXHJcblxyXG4vKipcclxuICogTG9hZCBhIGZpbGUgaW50byBhbiBpbWFnZS5cclxuICovXHJcbmV4cG9ydHMubG9hZEZpbGVJbnRvSW1hZ2UgPSBmdW5jdGlvbiAoZmlsZSwgaW1nKSB7XHJcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpbWcuc3JjID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgaW1hZ2UgZGF0YSBmcm9tIGFuIEhUTUwgaW1hZ2UuXHJcbiAqL1xyXG5leHBvcnRzLmdldEltYWdlRGF0YSA9IGZ1bmN0aW9uIChpbWFnZSkge1xyXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgcmV0dXJuIGltYWdlRGF0YTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlIGltYWdlIGRhdGEgVVJMIGZyb20gaW1hZ2UgZGF0YS5cclxuICovXHJcbmV4cG9ydHMubWFrZUltYWdlRGF0YVVybEZyb21JbWFnZURhdGEgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XHJcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZURhdGEud2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcclxuICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcclxufTtcclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBNb25vY2hyb21lIENvbnZlcnRlcnNcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBIVE1MNSBpbWFnZSBkYXRhIHRvIG1vbm9jaHJvbWUgaW1hZ2UgZGF0YSBieSBjb21wYXJpbmcgdGhlIGF2ZXJhZ2Ugb2YgZWFjaCBjb2xvciBjaGFubmVsIHRvIGFcclxuICogdGhyZXNob2xkIHZhbHVlIHRvIGRldGVybWluZSB3aGljaCBjb2xvciBjaGFubmVscyBhcmUgY29udmVydGVkIHRvIHRhcmdldCBtb25vY2hyb21lIGNvbG9ycy5cclxuICogQHBhcmFtICAgdGhyZXNob2xkIFZhbHVlIGJldHdlZW4gMCBhbmQgMjU1LlxyXG4gKiBAcGFyYW0gICBsZXNzdGhhblRocmVzaG9sZENvbG9yIENvbG9yIHRvIHVzZSBmb3IgcGl4ZWxzIGJlbG93IHRocmVzaG9sZC5cclxuICogQHBhcmFtICAgZ3JlYXRlcnRoYW5PckVxdWFsVG9UaHJlc2hvbGRDb2xvciBDb2xvciB0byB1c2UgZm9yIHBpeGVscyBlcXVhbCB0byBvciBhYm92ZSB0aHJlc2hvbGQuXHJcbiAqIEBwYXJhbSAgIGFscGhhIE9wdGlvYWwgYWxwaGEgdG8gYXNzaWduIHRvIHJlc3VsdCBwaXhlbHMuIChkZWZhdWx0ID0gMS4wKVxyXG4gKi9cclxuZXhwb3J0cy5tYWtlQXZlcmFnZVRocmVzaG9sZEltYWdlRGF0YSA9IGZ1bmN0aW9uIChpbWFnZURhdGEsIHRocmVzaG9sZCwgbGVzc3RoYW5UaHJlc2hvbGRDb2xvciwgZ3JlYXRlcnRoYW5PckVxdWFsVG9UaHJlc2hvbGRDb2xvciwgYWxwaGEpIHtcclxuICAgIGFscGhhID0gY29yZS5kZWYoYWxwaGEsIDEuMCk7XHJcbiAgICB2YXIgaW50QWxwaGEgPSBodG1sQ29sb3IuY29sb3JGcmFjdGlvbihhbHBoYSk7XHJcbiAgICBleHBvcnRzLnJlbmRlckNhbnZhc1BpeGVsQXJyYXkoaW1hZ2VEYXRhLCBmdW5jdGlvbiAoaW5kZXgsIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XHJcbiAgICAgICAgdmFyIGNvbG9yID0gbWF0aC5hdmVyYWdlKFtyZWQsIGdyZWVuLCBibHVlXSkgPj0gdGhyZXNob2xkID8gZ3JlYXRlcnRoYW5PckVxdWFsVG9UaHJlc2hvbGRDb2xvciA6IGxlc3N0aGFuVGhyZXNob2xkQ29sb3I7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcmVkIDogaHRtbENvbG9yLmdldFJlZENvbXBvbmVudChjb2xvciksXHJcbiAgICAgICAgICAgIGdyZWVuIDogaHRtbENvbG9yLmdldEdyZWVuQ29tcG9uZW50KGNvbG9yKSxcclxuICAgICAgICAgICAgYmx1ZSA6IGh0bWxDb2xvci5nZXRCbHVlQ29tcG9uZW50KGNvbG9yKSxcclxuICAgICAgICAgICAgYWxwaGEgOiBpbnRBbHBoYVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpbWFnZURhdGE7XHJcbn07IiwiLyoganNoaW50IGJpdHdpc2U6ZmFsc2UgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHZhbHVlIG9yIGRlZmF1bHQgaWYgdW5kZWZpbmVkLlxyXG4gICAgICogVXNlZnVsbCBmb3IgYXNzaWduaW5nIGFyZ3VtZW50IGRlZmF1bHQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBkZWY6IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uaXNVbmRlZmluZWQodmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvSW50OiBmdW5jdGlvbiAoc29tZXRoaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvbWV0aGluZyB8IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGZpcnN0IGFyZ3VtZW50IHRoYXQgaXMgbm90IHVuZGVmaW5lZCBhbmQgbm90IG51bGwuXHJcbiAgICAgKi9cclxuICAgIGNvYWxlc2NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uZmluZChhcmd1bWVudHMsIGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFfLmlzTnVsbChhcmcpICYmICFfLmlzVW5kZWZpbmVkKGFyZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGlzVW5kZWZpbmVkT3JOdWxsOiBmdW5jdGlvbiAodGhpbmcpIHtcclxuICAgICAgICByZXR1cm4gXy5pc1VuZGVmaW5lZCh0aGluZykgfHwgXy5pc051bGwodGhpbmcpO1xyXG4gICAgfVxyXG59OyIsIi8qKlxyXG4gKiBqYW5pY2VrLWNvcmUtanNcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIE15IHBlcnNvbmFsIGNvbGxlY3Rpb24gb2YgSmF2YVNjcmlwdCBjb3JlIGxpYnJhcmllcy5cclxuICogQ29weXJpZ2h0IChjKSAyMDEzIFJpY2hhcmQgSmFuaWNlaywgaHR0cDovL3d3dy5qYW5pY2VrLmNvXHJcbiAqIFxyXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVCkgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICogXHJcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xyXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuICogXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXHJcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcclxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xyXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAqIFxyXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cclxuICogXHJcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXHJcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cclxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXHJcbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxyXG4gKi9cclxuXHJcbi8qIGpzaGludCBiaXR3aXNlOmZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQ29tcHV0ZSBzdHJpbmcgaGFzaCB1c2luZyBkamIyIGFsZ29yaXRobS5cclxuICogXHJcbiAqIEhhcyBhIGdvb2QgYmFsYW5jZSBvZiBiZWluZyBleHRyZW1lbHkgZmFzdCwgd2hpbGUgcHJvdmlkaW5nIGEgcmVhc29uYWJsZSBkaXN0cmlidXRpb24gb2YgaGFzaCB2YWx1ZXMuXHJcbiAqIEBzZWUgaHR0cDovL3d3dy5jc2UueW9ya3UuY2Evfm96L2hhc2guaHRtbFxyXG4gKi9cclxuZXhwb3J0cy5kamIyID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgdmFyIGhhc2ggPSA1MzgxO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSArIGhhc2gpICsgc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHN0cmluZyBoYXNoIHVzaW5nIHNkYm0gYWxnb3JpdGhtLlxyXG4gKiBcclxuICogVGhpcyBhbGdvcml0aG0gd2FzIGNyZWF0ZWQgZm9yIHNkYm0gKGEgcHVibGljLWRvbWFpbiByZWltcGxlbWVudGF0aW9uIG9mIG5kYm0pIGRhdGFiYXNlIGxpYnJhcnkuXHJcbiAqIEl0IHdhcyBmb3VuZCB0byBkbyB3ZWxsIGluIHNjcmFtYmxpbmcgYml0cywgY2F1c2luZyBiZXR0ZXIgZGlzdHJpYnV0aW9uIG9mIHRoZSBrZXlzIGFuZCBmZXdlciBzcGxpdHMuXHJcbiAqIEl0IGFsc28gaGFwcGVucyB0byBiZSBhIGdvb2QgZ2VuZXJhbCBoYXNoaW5nIGZ1bmN0aW9uIHdpdGggZ29vZCBkaXN0cmlidXRpb24uXHJcbiAqIEBzZWUgaHR0cDovL3d3dy5jc2UueW9ya3UuY2Evfm96L2hhc2guaHRtbFxyXG4gKi9cclxuZXhwb3J0cy5zZGJtID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgdmFyIGhhc2ggPSAwO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaGFzaCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpICsgKGhhc2ggPDwgNikgKyAoaGFzaCA8PCAxNikgLSBoYXNoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc2g7XHJcbn07XHJcblxyXG4vKipcclxuICogSmF2YSdzIFN0cmluZy5oYXNoQ29kZSgpIG1ldGhvZCBpbXBsZW1lbnRlZCBpbiBIYXhlLlxyXG4gKiBAc2VlIGh0dHA6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzEuNC4yL2RvY3MvYXBpL2phdmEvbGFuZy9TdHJpbmcuaHRtbCNoYXNoQ29kZSUyOCUyOVxyXG4gKi9cclxuZXhwb3J0cy5qYXZhSGFzaENvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICB2YXIgaGFzaCA9IDA7XHJcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gaGFzaDsgfVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBoYXNoID0gaGFzaCAmIGhhc2g7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc2g7XHJcbn07IiwiLyoganNoaW50IGJpdHdpc2U6ZmFsc2UgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XHJcblxyXG5leHBvcnRzLk1BWF9DT0xPUl9DT01QT05FTlQgPSAweGZmO1xyXG5cclxuLyoqXHJcbiAqIEdldCByZWQgY29tcG9uZW50IG9mIEludCBjb2xvci5cclxuICovXHJcbmV4cG9ydHMuZ2V0UmVkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGMpIHtcclxuICAgIHJldHVybiAoYyA+PiAxNikgJiAweGZmO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBncmVlbiBjb21wb25lbnQgb2YgSW50IGNvbG9yLlxyXG4gKi9cclxuZXhwb3J0cy5nZXRHcmVlbkNvbXBvbmVudCA9IGZ1bmN0aW9uIChjKSB7XHJcbiAgICByZXR1cm4gKGMgPj4gOCkgJiAweGZmO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBibHVlIGNvbXBvbmVudCBvZiBJbnQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnRzLmdldEJsdWVDb21wb25lbnQgPSBmdW5jdGlvbiAoYykge1xyXG4gICAgcmV0dXJuIGMgJiAweGZmO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVycG9sYXRlIGNvbG9yIGJldHdlZW4gY29sb3IwIGFuZCBjb2xvcjEgdXNpbmcgZnJhY3Rpb24gZi4gV2hlbiBmPT0wLCByZXN1bHQgaXMgY29sb3IwLiBXaGVuIGY9PTEsIHJlc3VsdCBpcyBjb2xvcjEuXHJcbiAqIEBhdXRob3IgQW1pdCBQYXRlbFxyXG4gKi9cclxuZXhwb3J0cy5pbnRlcnBvbGF0ZUNvbG9yID0gZnVuY3Rpb24gKGNvbG9yMCwgY29sb3IxLCBmKSB7XHJcbiAgICB2YXIgciA9IGNvcmUudG9JbnQoKDEgLSBmKSAqIChjb2xvcjAgPj4gMTYpICsgZiAqIChjb2xvcjEgPj4gMTYpKTtcclxuICAgIHZhciBnID0gY29yZS50b0ludCgoMSAtIGYpICogKChjb2xvcjAgPj4gOCkgJiAweGZmKSArIGYgKiAoKGNvbG9yMSA+PiA4KSAmIDB4ZmYpKTtcclxuICAgIHZhciBiID0gY29yZS50b0ludCgoMSAtIGYpICogKGNvbG9yMCAmIDB4ZmYpICsgZiAqIChjb2xvcjEgJiAweGZmKSk7XHJcbiAgICBpZiAociA+IDI1NSkgeyByID0gMjU1OyB9XHJcbiAgICBpZiAoZyA+IDI1NSkgeyBnID0gMjU1OyB9XHJcbiAgICBpZiAoYiA+IDI1NSkgeyBiID0gMjU1OyB9XHJcbiAgICByZXR1cm4gKHIgPDwgMTYpIHwgKGcgPDwgOCkgfCBiO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBmcmFjdGlvbiAoMC4wIC0gMS4wKSB0byBhIGNvbG9yIHZhbHVlICgwIC0gMHhmZikuXHJcbiAqL1xyXG5leHBvcnRzLmNvbG9yRnJhY3Rpb24gPSBmdW5jdGlvbiAoZnJhY3Rpb24pIHtcclxuICAgIHJldHVybiBjb3JlLnRvSW50KGV4cG9ydHMuTUFYX0NPTE9SX0NPTVBPTkVOVCAqIGZyYWN0aW9uKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlIEhUTUwgaGV4IGNvbG9yIHN0cmluZyBmcm9tIEludCB2YWx1ZS4gRXhhbXBsZTogMCAtPiAjMDAwMDAwXHJcbiAqIEBwYXJhbSAgIGNvbG9yIEludCBjb2xvciB2YWx1ZS5cclxuICogQHJldHVybiAgSFRNTCBjb2xvciBzdHJpbmcuXHJcbiAqL1xyXG5leHBvcnRzLmludFRvSGV4Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuICAgIHJldHVybiAnIycgKyAoJzAwMDAwJyArIGNvbG9yLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zdWJzdHIoLTYpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1ha2UgSFRNTCByZ2IocixnLGIsYSkgY29sb3Igc3RyaW5nLlxyXG4gKiBAcGFyYW0gICByZWQgUmVkIGNoYW5uZWwgKDAgLSAweGZmKS5cclxuICogQHBhcmFtICAgZ3JlZW4gR3JlZW4gY2hhbm5lbCAoMCAtIDB4ZmYpLlxyXG4gKiBAcGFyYW0gICBibHVlIEJsdWUgY2hhbm5lbCAoMCAtIDB4ZmYpLlxyXG4gKi9cclxuZXhwb3J0cy5yZ2IgPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSkge1xyXG4gICAgcmV0dXJuICdyZ2IoJyArIHJlZCArICcsJyArIGdyZWVuICsgJywnICsgYmx1ZSArICcpJztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlIEhUTUwgcmdiYShyLGcsYixhKSBjb2xvciBzdHJpbmcuXHJcbiAqIEBwYXJhbSAgIHJlZCBSZWQgY2hhbm5lbCAoMCAtIDB4ZmYpLlxyXG4gKiBAcGFyYW0gICBncmVlbiBHcmVlbiBjaGFubmVsICgwIC0gMHhmZikuXHJcbiAqIEBwYXJhbSAgIGJsdWUgQmx1ZSBjaGFubmVsICgwIC0gMHhmZikuXHJcbiAqIEBwYXJhbSAgIGFscGhhIEFscGhhIGNoYW5uZWwgKDAuMCAtIDEuMCkuXHJcbiAqL1xyXG5leHBvcnRzLnJnYmEgPSBmdW5jdGlvbiAocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcclxuICAgIHJldHVybiAncmdiYSgnICsgcmVkICsgJywnICsgZ3JlZW4gKyAnLCcgKyBibHVlICsgJywnICsgYWxwaGEgKyAnKSc7XHJcbn07XHJcblxyXG4vKipcclxuICogTWFrZSBIVE1MIHJnYihyLGcsYikgY29sb3Igc3RyaW5nIHVzaW5nIGZyYWN0aW9ucy5cclxuICogQHBhcmFtICAgcmVkIFJlZCBjaGFubmVsICgwLjAgLSAxLjApLlxyXG4gKiBAcGFyYW0gICBncmVlbiBHcmVlbiBjaGFubmVsICgwLjAgLSAxLjApLlxyXG4gKiBAcGFyYW0gICBibHVlIEJsdWUgY2hhbm5lbCAoMC4wIC0gMS4wKS5cclxuICovXHJcbmV4cG9ydHMucmdiRiA9IGZ1bmN0aW9uIChyZWQsIGdyZWVuLCBibHVlKSB7XHJcbiAgICByZXR1cm4gJ3JnYignICsgcmVkICogMTAwICsgJyUsJyArIGdyZWVuICogMTAwICsgJyUsJyArIGJsdWUgKiAxMDAgKyAnJSknO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1ha2UgSFRNTCByZ2JhKHIsZyxiLGEpIGNvbG9yIHN0cmluZyB1c2luZyBmcmFjdGlvbnMuXHJcbiAqIEBwYXJhbSAgIHJlZCBSZWQgY2hhbm5lbCAoMC4wIC0gMS4wKS5cclxuICogQHBhcmFtICAgZ3JlZW4gR3JlZW4gY2hhbm5lbCAoMC4wIC0gMS4wKS5cclxuICogQHBhcmFtICAgYmx1ZSBCbHVlIGNoYW5uZWwgKDAuMCAtIDEuMCkuXHJcbiAqIEBwYXJhbSAgIGFscGhhIEFscGhhIGNoYW5uZWwgKDAuMCAtIDEuMCkuXHJcbiAqL1xyXG5leHBvcnRzLnJnYmFGID0gZnVuY3Rpb24gKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XHJcbiAgICByZXR1cm4gJ3JnYmEoJyArIHJlZCAqIDEwMCArICclLCcgKyBncmVlbiAqIDEwMCArICclLCcgKyBibHVlICogMTAwICsgJyUsJyArIGFscGhhICsgJyknO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1ha2UgSFRNTCBoc2woaCxzLGwpIGNvbG9yIHN0cmluZy5cclxuICogQHBhcmFtICAgaHVlIEEgZGVncmVlIG9uIHRoZSBjb2xvciB3aGVlbCAoZnJvbSAwIHRvIDM2MCkgLSAwIChvciAzNjApIGlzIHJlZCwgMTIwIGlzIGdyZWVuLCAyNDAgaXMgYmx1ZS4gXHJcbiAqIEBwYXJhbSAgIHNhdHVyYXRpb24gQSBwZXJjZW50YWdlIHZhbHVlOyAwLjAgbWVhbnMgYSBzaGFkZSBvZiBncmF5IGFuZCAxLjAgaXMgdGhlIGZ1bGwgY29sb3IuXHJcbiAqIEBwYXJhbSAgIGxpZ2h0bmVzcyBMaWdodG5lc3MgaXMgYWxzbyBhIHBlcmNlbnRhZ2U7IDAuMCBpcyBibGFjaywgMS4wIGlzIHdoaXRlLlxyXG4gKiBAcmV0dXJuICBIVE1MIGNvbG9yIHN0cmluZy5cclxuICovXHJcbmV4cG9ydHMuaHNsID0gZnVuY3Rpb24gKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSB7XHJcbiAgICByZXR1cm4gJ2hzbCgnICsgaHVlICsgJywnICsgc2F0dXJhdGlvbiAqIDEwMCArICclLCcgKyBsaWdodG5lc3MgKiAxMDAgKyAnJSknO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1ha2UgSFRNTCBoc2xhKGgscyxsLGEpIGNvbG9yIHN0cmluZy5cclxuICogQHBhcmFtICAgaHVlIEEgZGVncmVlIG9uIHRoZSBjb2xvciB3aGVlbCAoZnJvbSAwIHRvIDM2MCkgLSAwIChvciAzNjApIGlzIHJlZCwgMTIwIGlzIGdyZWVuLCAyNDAgaXMgYmx1ZS4gXHJcbiAqIEBwYXJhbSAgIHNhdHVyYXRpb24gQSBwZXJjZW50YWdlIHZhbHVlOyAwLjAgbWVhbnMgYSBzaGFkZSBvZiBncmF5IGFuZCAxLjAgaXMgdGhlIGZ1bGwgY29sb3IuXHJcbiAqIEBwYXJhbSAgIGxpZ2h0bmVzcyBMaWdodG5lc3MgaXMgYWxzbyBhIHBlcmNlbnRhZ2U7IDAuMCBpcyBibGFjaywgMS4wIGlzIHdoaXRlLlxyXG4gKiBAcGFyYW0gICBhbHBoYSBOdW1iZXIgYmV0d2VlbiAwLjAgKGZ1bGx5IHRyYW5zcGFyZW50KSBhbmQgMS4wIChmdWxseSBvcGFxdWUpLlxyXG4gKiBAcmV0dXJuICBIVE1MIGNvbG9yIHN0cmluZy5cclxuICovXHJcbmV4cG9ydHMuaHNsYSA9IGZ1bmN0aW9uIChodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGEpIHtcclxuICAgIHJldHVybiAnaHNsYSgnICsgaHVlICsgJywnICsgc2F0dXJhdGlvbiAqIDEwMCArICclLCcgKyBsaWdodG5lc3MgKiAxMDAgKyAnJSwnICsgYWxwaGEgKyAnKSc7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbmV4cG9ydHMuY291bnRlcnMgPSB7fTtcclxuXHJcbmV4cG9ydHMuYnVtcENvdW50ZXIgPSBmdW5jdGlvbiAoY291bnRlcikge1xyXG4gICAgaWYgKCFleHBvcnRzLmNvdW50ZXJzW2NvdW50ZXJdKSB7XHJcbiAgICAgICAgZXhwb3J0cy5jb3VudGVyc1tjb3VudGVyXSA9IDA7XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLmNvdW50ZXJzW2NvdW50ZXJdKys7XHJcbn07XHJcblxyXG5leHBvcnRzLmxvZ0NvdW50ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgXy5lYWNoKGV4cG9ydHMuY291bnRlcnMsIGZ1bmN0aW9uIChjb3VudGVyLCBrZXkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhrZXksIGNvdW50ZXIpO1xyXG4gICAgfSk7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxuXHJcbmV4cG9ydHMuYXZlcmFnZSA9IGZ1bmN0aW9uIChudW1iZXJzKSB7XHJcbiAgICByZXR1cm4gXy5yZWR1Y2UobnVtYmVycywgZnVuY3Rpb24gKHRvdGFsLCBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdG90YWwgKyBudW1iZXI7XHJcbiAgICB9KSAvIF8uc2l6ZShudW1iZXJzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBjbGFtcCBhIEZsb2F0IHRvIGFuIGludGVydmFsXHJcbiAqIGludGVydmFsIGVuZHBvaW50cyBhcmUgY29tcGFyZWQgdG8gZ2V0IG1pbiBhbmQgbWF4LCBzbyBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IG9yZGVyIHRoZXkgYXJlIHBhc3NlZCBpblxyXG4gKiBAcGFyYW0gICB2YWx1ZSB2YWx1ZSB0byBjbGFtcFxyXG4gKiBAcGFyYW0gICBtaW5Pck1heDEgaW50ZXJ2YWwgZW5kcG9pbnRcclxuICogQHBhcmFtICAgbWluT3JNYXgyIGludGVydmFsIGVuZHBvaW50XHJcbiAqIEByZXR1cm4gIGNsYW1wZWQgdmFsdWUgdG8gZ2l2ZW4gaW50ZXJ2YWxcclxuICovXHJcbmV4cG9ydHMuY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbk9yTWF4MSwgbWluT3JNYXgyKSB7XHJcbiAgICB2YXIgbWluID0gTWF0aC5taW4obWluT3JNYXgxLCBtaW5Pck1heDIpO1xyXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KG1pbk9yTWF4MSwgbWluT3JNYXgyKTtcclxuICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XHJcbn07IiwiLyoganNoaW50IGJpdHdpc2U6ZmFsc2UgKi9cclxuXHJcbi8qKlxyXG5UaXRsZTogICAgICAgICAgUGVybGluIG5vaXNlXHJcblZlcnNpb246ICAgICAgICAxLjNcclxuQXV0aG9yOiAgICAgICAgIFJvbiBWYWxzdGFyXHJcbkF1dGhvciBVUkk6ICAgICBodHRwOi8vd3d3LnNqZWl0aS5jb20vXHJcbk9yaWdpbmFsIGNvZGUgcG9ydCBmcm9tIGh0dHA6Ly9tcmwubnl1LmVkdS9+cGVybGluL25vaXNlL1xyXG5hbmQgc29tZSBoZWxwIGZyb20gaHR0cDovL2ZyZWVzcGFjZS52aXJnaW4ubmV0L2h1Z28uZWxpYXMvbW9kZWxzL21fcGVybGluLmh0bVxyXG5BUzMgb3B0aW1pemF0aW9ucyBieSBNYXJpbyBLbGluZ2VtYW5uIGh0dHA6Ly93d3cucXVhc2ltb25kby5jb21cclxuSGF4ZSBwb3J0IGFuZCBvcHRpbWl6YXRpb24gYnkgTmljb2xhcyBDYW5uYXNzZSBodHRwOi8vaGF4ZS5vcmdcclxuSmF2YVNjcmlwdCBwb3J0IGFuZCBzaW1wbGlmaWVkIGJ5IFJpY2hhcmQgSmFuaWNlayBodHRwOi8vamFuaWNlay5jb1xyXG4qL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGRlZiA9IHJlcXVpcmUoJy4vY29yZScpLmRlZjtcclxudmFyIGFycmF5MmQgPSByZXF1aXJlKCcuL2FycmF5MmQnKTtcclxuXHJcbnZhciBwID0gW1xyXG4gICAgMTUxLCAxNjAsIDEzNywgOTEsIDkwLCAxNSwgMTMxLCAxMywgMjAxLCA5NSxcclxuICAgIDk2LCA1MywgMTk0LCAyMzMsIDcsIDIyNSwgMTQwLCAzNiwgMTAzLCAzMCwgNjksXHJcbiAgICAxNDIsIDgsIDk5LCAzNywgMjQwLCAyMSwgMTAsIDIzLCAxOTAsIDYsIDE0OCxcclxuICAgIDI0NywgMTIwLCAyMzQsIDc1LCAwLCAyNiwgMTk3LCA2MiwgOTQsIDI1MixcclxuICAgIDIxOSwgMjAzLCAxMTcsIDM1LCAxMSwgMzIsIDU3LCAxNzcsIDMzLCA4OCxcclxuICAgIDIzNywgMTQ5LCA1NiwgODcsIDE3NCwgMjAsIDEyNSwgMTM2LCAxNzEsXHJcbiAgICAxNjgsIDY4LCAxNzUsIDc0LCAxNjUsIDcxLCAxMzQsIDEzOSwgNDgsIDI3LFxyXG4gICAgMTY2LCA3NywgMTQ2LCAxNTgsIDIzMSwgODMsIDExMSwgMjI5LCAxMjIsXHJcbiAgICA2MCwgMjExLCAxMzMsIDIzMCwgMjIwLCAxMDUsIDkyLCA0MSwgNTUsIDQ2LFxyXG4gICAgMjQ1LCA0MCwgMjQ0LCAxMDIsIDE0MywgNTQsIDY1LCAyNSwgNjMsIDE2MSxcclxuICAgIDEsIDIxNiwgODAsIDczLCAyMDksIDc2LCAxMzIsIDE4NywgMjA4LCA4OSxcclxuICAgIDE4LCAxNjksIDIwMCwgMTk2LCAxMzUsIDEzMCwgMTE2LCAxODgsIDE1OSxcclxuICAgIDg2LCAxNjQsIDEwMCwgMTA5LCAxOTgsIDE3MywgMTg2LCAzLCA2NCwgNTIsXHJcbiAgICAyMTcsIDIyNiwgMjUwLCAxMjQsIDEyMywgNSwgMjAyLCAzOCwgMTQ3LCAxMTgsXHJcbiAgICAxMjYsIDI1NSwgODIsIDg1LCAyMTIsIDIwNywgMjA2LCA1OSwgMjI3LCA0NyxcclxuICAgIDE2LCA1OCwgMTcsIDE4MiwgMTg5LCAyOCwgNDIsIDIyMywgMTgzLCAxNzAsXHJcbiAgICAyMTMsIDExOSwgMjQ4LCAxNTIsIDIsIDQ0LCAxNTQsIDE2MywgNzAsIDIyMSxcclxuICAgIDE1MywgMTAxLCAxNTUsIDE2NywgNDMsIDE3MiwgOSwgMTI5LCAyMiwgMzksXHJcbiAgICAyNTMsIDE5LCA5OCwgMTA4LCAxMTAsIDc5LCAxMTMsIDIyNCwgMjMyLFxyXG4gICAgMTc4LCAxODUsIDExMiwgMTA0LCAyMTgsIDI0NiwgOTcsIDIyOCwgMjUxLFxyXG4gICAgMzQsIDI0MiwgMTkzLCAyMzgsIDIxMCwgMTQ0LCAxMiwgMTkxLCAxNzksXHJcbiAgICAxNjIsIDI0MSwgODEsIDUxLCAxNDUsIDIzNSwgMjQ5LCAxNCwgMjM5LFxyXG4gICAgMTA3LCA0OSwgMTkyLCAyMTQsIDMxLCAxODEsIDE5OSwgMTA2LCAxNTcsXHJcbiAgICAxODQsIDg0LCAyMDQsIDE3NiwgMTE1LCAxMjEsIDUwLCA0NSwgMTI3LCA0LFxyXG4gICAgMTUwLCAyNTQsIDEzOCwgMjM2LCAyMDUsIDkzLCAyMjIsIDExNCwgNjcsIDI5LFxyXG4gICAgMjQsIDcyLCAyNDMsIDE0MSwgMTI4LCAxOTUsIDc4LCA2NiwgMjE1LCA2MSxcclxuICAgIDE1NiwgMTgwLCAxNTEsIDE2MCwgMTM3LCA5MSwgOTAsIDE1LCAxMzEsIDEzLFxyXG4gICAgMjAxLCA5NSwgOTYsIDUzLCAxOTQsIDIzMywgNywgMjI1LCAxNDAsIDM2LFxyXG4gICAgMTAzLCAzMCwgNjksIDE0MiwgOCwgOTksIDM3LCAyNDAsIDIxLCAxMCwgMjMsXHJcbiAgICAxOTAsIDYsIDE0OCwgMjQ3LCAxMjAsIDIzNCwgNzUsIDAsIDI2LCAxOTcsXHJcbiAgICA2MiwgOTQsIDI1MiwgMjE5LCAyMDMsIDExNywgMzUsIDExLCAzMiwgNTcsXHJcbiAgICAxNzcsIDMzLCA4OCwgMjM3LCAxNDksIDU2LCA4NywgMTc0LCAyMCwgMTI1LFxyXG4gICAgMTM2LCAxNzEsIDE2OCwgNjgsIDE3NSwgNzQsIDE2NSwgNzEsIDEzNCwgMTM5LFxyXG4gICAgNDgsIDI3LCAxNjYsIDc3LCAxNDYsIDE1OCwgMjMxLCA4MywgMTExLCAyMjksXHJcbiAgICAxMjIsIDYwLCAyMTEsIDEzMywgMjMwLCAyMjAsIDEwNSwgOTIsIDQxLCA1NSxcclxuICAgIDQ2LCAyNDUsIDQwLCAyNDQsIDEwMiwgMTQzLCA1NCwgNjUsIDI1LCA2MyxcclxuICAgIDE2MSwgMSwgMjE2LCA4MCwgNzMsIDIwOSwgNzYsIDEzMiwgMTg3LCAyMDgsXHJcbiAgICA4OSwgMTgsIDE2OSwgMjAwLCAxOTYsIDEzNSwgMTMwLCAxMTYsIDE4OCxcclxuICAgIDE1OSwgODYsIDE2NCwgMTAwLCAxMDksIDE5OCwgMTczLCAxODYsIDMsIDY0LFxyXG4gICAgNTIsIDIxNywgMjI2LCAyNTAsIDEyNCwgMTIzLCA1LCAyMDIsIDM4LCAxNDcsXHJcbiAgICAxMTgsIDEyNiwgMjU1LCA4MiwgODUsIDIxMiwgMjA3LCAyMDYsIDU5LFxyXG4gICAgMjI3LCA0NywgMTYsIDU4LCAxNywgMTgyLCAxODksIDI4LCA0MiwgMjIzLFxyXG4gICAgMTgzLCAxNzAsIDIxMywgMTE5LCAyNDgsIDE1MiwgMiwgNDQsIDE1NCxcclxuICAgIDE2MywgNzAsIDIyMSwgMTUzLCAxMDEsIDE1NSwgMTY3LCA0MywgMTcyLCA5LFxyXG4gICAgMTI5LCAyMiwgMzksIDI1MywgMTksIDk4LCAxMDgsIDExMCwgNzksIDExMyxcclxuICAgIDIyNCwgMjMyLCAxNzgsIDE4NSwgMTEyLCAxMDQsIDIxOCwgMjQ2LCA5NyxcclxuICAgIDIyOCwgMjUxLCAzNCwgMjQyLCAxOTMsIDIzOCwgMjEwLCAxNDQsIDEyLFxyXG4gICAgMTkxLCAxNzksIDE2MiwgMjQxLCA4MSwgNTEsIDE0NSwgMjM1LCAyNDksXHJcbiAgICAxNCwgMjM5LCAxMDcsIDQ5LCAxOTIsIDIxNCwgMzEsIDE4MSwgMTk5LFxyXG4gICAgMTA2LCAxNTcsIDE4NCwgODQsIDIwNCwgMTc2LCAxMTUsIDEyMSwgNTAsXHJcbiAgICA0NSwgMTI3LCA0LCAxNTAsIDI1NCwgMTM4LCAyMzYsIDIwNSwgOTMsXHJcbiAgICAyMjIsIDExNCwgNjcsIDI5LCAyNCwgNzIsIDI0MywgMTQxLCAxMjgsXHJcbiAgICAxOTUsIDc4LCA2NiwgMjE1LCA2MSwgMTU2LCAxODBcclxuXTtcclxuXHJcbi8qXHJcbiAqIE1ha2VzIHNvbWUgUGVybGluIE5vaXNlLlxyXG4gKiBAcmV0dXJucyBbW2ludF1dIEEgYml0bWFwIG9mIFBlcmxpbiBOb2lzZS5cclxuICovXHJcbmV4cG9ydHMubWFrZVBlcmxpbk5vaXNlID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIF94LCBfeSwgX3osIHNlZWQsIG9jdGF2ZXMsIGZhbGxvZmYpIHtcclxuICAgIHNlZWQgPSBkZWYoc2VlZCwgNjY2KTtcclxuICAgIG9jdGF2ZXMgPSBkZWYob2N0YXZlcywgNCk7XHJcbiAgICBmYWxsb2ZmID0gZGVmKGZhbGxvZmYsIDAuNSk7XHJcblxyXG4gICAgdmFyIGJhc2VGYWN0b3IgPSAxIC8gNjQ7XHJcbiAgICBcclxuICAgIHZhciBpWG9mZnNldCA9IHNlZWQgPSAoc2VlZCAqIDE2ODA3LjApICUgMjE0NzQ4MzY0NztcclxuICAgIHZhciBpWW9mZnNldCA9IHNlZWQgPSAoc2VlZCAqIDE2ODA3LjApICUgMjE0NzQ4MzY0NztcclxuICAgIHZhciBpWm9mZnNldCA9IHNlZWQgPSAoc2VlZCAqIDE2ODA3LjApICUgMjE0NzQ4MzY0NztcclxuICBcclxuICAgIHZhciBhT2N0RnJlcSA9IFtdOyAvLyBmcmVxdWVuY3kgcGVyIG9jdGF2ZVxyXG4gICAgdmFyIGFPY3RQZXJzID0gW107IC8vIHBlcnNpc3RlbmNlIHBlciBvY3RhdmVcclxuICAgIHZhciBmUGVyc01heCA9IDAuMDsgLy8gMSAvIG1heCBwZXJzaXN0ZW5jZVxyXG5cclxuICAgIHZhciBmRnJlcSwgZlBlcnM7XHJcblxyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2N0YXZlczsgaSsrKSB7XHJcbiAgICAgICAgZkZyZXEgPSBNYXRoLnBvdygyLCBpKTtcclxuICAgICAgICBmUGVycyA9IE1hdGgucG93KGZhbGxvZmYsIGkpO1xyXG4gICAgICAgIGZQZXJzTWF4ICs9IGZQZXJzO1xyXG4gICAgICAgIGFPY3RGcmVxLnB1c2goZkZyZXEpO1xyXG4gICAgICAgIGFPY3RQZXJzLnB1c2goZlBlcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGZQZXJzTWF4ID0gMSAvIGZQZXJzTWF4O1xyXG5cclxuICAgIHZhciBiaXRtYXAgPSBhcnJheTJkKFtdKTsgLy8gQXJyYXk8QXJyYXk8SW50Pj5cclxuICAgIFxyXG4gICAgdmFyIGJhc2VYID0gX3ggKiBiYXNlRmFjdG9yICsgaVhvZmZzZXQ7XHJcbiAgICBfeSA9IF95ICogYmFzZUZhY3RvciArIGlZb2Zmc2V0O1xyXG4gICAgX3ogPSBfeiAqIGJhc2VGYWN0b3IgKyBpWm9mZnNldDtcclxuXHJcbiAgICB2YXIgcHk7XHJcbiAgICBmb3IgKHB5ID0gMDsgcHkgPCBoZWlnaHQ7IHB5KyspIHtcclxuICAgICAgICBfeCA9IGJhc2VYO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBweDtcclxuICAgICAgICBmb3IgKHB4ID0gMDsgcHggPCB3aWR0aDsgcHgrKykge1xyXG4gICAgICAgICAgICB2YXIgcyA9IDAuMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvY3RhdmVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmRnJlcTIgPSBhT2N0RnJlcVtpXTtcclxuICAgICAgICAgICAgICAgIHZhciBmUGVyczIgPSBhT2N0UGVyc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IF94ICogZkZyZXEyO1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSBfeSAqIGZGcmVxMjtcclxuICAgICAgICAgICAgICAgIHZhciB6ID0gX3ogKiBmRnJlcTI7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHhmID0geCAtICh4ICUgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeWYgPSB5IC0gKHkgJSAxKTtcclxuICAgICAgICAgICAgICAgIHZhciB6ZiA9IHogLSAoeiAlIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBYID0geGYgJiAyNTU7XHJcbiAgICAgICAgICAgICAgICB2YXIgWSA9IHlmICYgMjU1O1xyXG4gICAgICAgICAgICAgICAgdmFyIFogPSB6ZiAmIDI1NTtcclxuXHJcbiAgICAgICAgICAgICAgICB4IC09IHhmO1xyXG4gICAgICAgICAgICAgICAgeSAtPSB5ZjtcclxuICAgICAgICAgICAgICAgIHogLT0gemY7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHUgPSB4ICogeCAqIHggKiAoeCAqICh4ICogNiAtIDE1KSArIDEwKTtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0geSAqIHkgKiB5ICogKHkgKiAoeSAqIDYgLSAxNSkgKyAxMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdyA9IHogKiB6ICogeiAqICh6ICogKHogKiA2IC0gMTUpICsgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBBICA9IChwW1hdKSArIFk7XHJcbiAgICAgICAgICAgICAgICB2YXIgQUEgPSAocFtBXSkgKyBaO1xyXG4gICAgICAgICAgICAgICAgdmFyIEFCID0gKHBbQSArIDFdKSArIFo7XHJcbiAgICAgICAgICAgICAgICB2YXIgQiAgPSAocFtYICsgMV0pICsgWTtcclxuICAgICAgICAgICAgICAgIHZhciBCQSA9IChwW0JdKSArIFo7XHJcbiAgICAgICAgICAgICAgICB2YXIgQkIgPSAocFtCICsgMV0pICsgWjtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeDEgPSB4IC0gMTtcclxuICAgICAgICAgICAgICAgIHZhciB5MSA9IHkgLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHoxID0geiAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGhhc2ggPSAocFtCQiArIDFdKSAmIDE1O1xyXG4gICAgICAgICAgICAgICAgdmFyIGcxID0gKChoYXNoJjEpID09PSAwID8gKGhhc2ggPCA4ID8geDEgOiB5MSkgOiAoaGFzaCA8IDggPyAteDEgOiAteTEpKSArICgoaGFzaCYyKSA9PT0gMCA/IGhhc2ggPCA0ID8geTEgOiAoaGFzaCA9PT0gMTIgPyB4MSA6IHoxKSA6IGhhc2ggPCA0ID8gLXkxIDogKGhhc2ggPT09IDE0ID8gLXgxIDogLXoxKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaGFzaCA9IChwW0FCICsgMV0pICYgMTU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZzIgPSAoKGhhc2gmMSkgPT09IDAgPyAoaGFzaCA8IDggPyB4ICA6IHkxKSA6IChoYXNoIDwgOCA/IC14ICA6IC15MSkpICsgKChoYXNoJjIpID09PSAwID8gaGFzaCA8IDQgPyB5MSA6IChoYXNoID09PSAxMiA/IHggIDogejEpIDogaGFzaCA8IDQgPyAteTEgOiAoaGFzaCA9PT0gMTQgPyAteCA6IC16MSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGhhc2ggPSAocFtCQSArIDFdKSAmIDE1O1xyXG4gICAgICAgICAgICAgICAgdmFyIGczID0gKChoYXNoJjEpID09PSAwID8gKGhhc2ggPCA4ID8geDEgOiB5KSA6IChoYXNoIDwgOCA/IC14MSA6IC15KSkgKyAoKGhhc2gmMikgPT09IDAgPyBoYXNoIDwgNCA/IHkgIDogKGhhc2ggPT09IDEyID8geDEgOiB6MSkgOiBoYXNoIDwgNCA/IC15ICA6IChoYXNoID09PSAxNCA/IC14MSA6IC16MSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGhhc2ggPSAocFtBQSArIDFdKSAmIDE1O1xyXG4gICAgICAgICAgICAgICAgdmFyIGc0ID0gKChoYXNoJjEpID09PSAwID8gKGhhc2ggPCA4ID8geCAgOiB5KSA6IChoYXNoIDwgOCA/IC14ICA6IC15KSkgKyAoKGhhc2gmMikgPT09IDAgPyBoYXNoIDwgNCA/IHkgIDogKGhhc2ggPT09IDEyID8geCAgOiB6MSkgOiBoYXNoIDwgNCA/IC15ICA6IChoYXNoID09PSAxNCA/IC14ICA6IC16MSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGhhc2ggPSAocFtCQl0pICYgMTU7XHJcbiAgICAgICAgICAgICAgICB2YXIgZzUgPSAoKGhhc2gmMSkgPT09IDAgPyAoaGFzaCA8IDggPyB4MSA6IHkxKSA6IChoYXNoIDwgOCA/IC14MSA6IC15MSkpICsgKChoYXNoJjIpID09PSAwID8gaGFzaCA8IDQgPyB5MSA6IChoYXNoID09PSAxMiA/IHgxIDogeikgOiBoYXNoIDwgNCA/IC15MSA6IChoYXNoID09PSAxNCA/IC14MSA6IC16KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaGFzaCA9IChwW0FCXSkgJiAxNTtcclxuICAgICAgICAgICAgICAgIHZhciBnNiA9ICgoaGFzaCYxKSA9PT0gMCA/IChoYXNoIDwgOCA/IHggIDogeTEpIDogKGhhc2ggPCA4ID8gLXggIDogLXkxKSkgKyAoKGhhc2gmMikgPT09IDAgPyBoYXNoIDwgNCA/IHkxIDogKGhhc2ggPT09IDEyID8geCAgOiB6KSA6IGhhc2ggPCA0ID8gLXkxIDogKGhhc2ggPT09IDE0ID8gLXggIDogLXopKTtcclxuXHJcbiAgICAgICAgICAgICAgICBoYXNoID0gKHBbQkFdKSAmIDE1O1xyXG4gICAgICAgICAgICAgICAgdmFyIGc3ID0gKChoYXNoJjEpID09PSAwID8gKGhhc2ggPCA4ID8geDEgOiB5KSA6IChoYXNoIDwgOCA/IC14MSA6IC15KSkgKyAoKGhhc2gmMikgPT09IDAgPyBoYXNoIDwgNCA/IHkgIDogKGhhc2ggPT09IDEyID8geDEgOiB6KSA6IGhhc2ggPCA0ID8gLXkgIDogKGhhc2ggPT09IDE0ID8gLXgxIDogLXopKTtcclxuXHJcbiAgICAgICAgICAgICAgICBoYXNoID0gKHBbQUFdKSAmIDE1O1xyXG4gICAgICAgICAgICAgICAgdmFyIGc4ID0gKChoYXNoJjEpID09PSAwID8gKGhhc2ggPCA4ID8geCAgOiB5KSA6IChoYXNoIDwgOCA/IC14ICA6IC15KSkgKyAoKGhhc2gmMikgPT09IDAgPyBoYXNoIDwgNCA/IHkgIDogKGhhc2ggPT09IDEyID8geCAgOiB6KSA6IGhhc2ggPCA0ID8gLXkgIDogKGhhc2ggPT09IDE0ID8gLXggIDogLXopKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnMiArPSB1ICogKGcxIC0gZzIpO1xyXG4gICAgICAgICAgICAgICAgZzQgKz0gdSAqIChnMyAtIGc0KTtcclxuICAgICAgICAgICAgICAgIGc2ICs9IHUgKiAoZzUgLSBnNik7XHJcbiAgICAgICAgICAgICAgICBnOCArPSB1ICogKGc3IC0gZzgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGc0ICs9IHYgKiAoZzIgLSBnNCk7XHJcbiAgICAgICAgICAgICAgICBnOCArPSB2ICogKGc2IC0gZzgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHMgKz0gKGc4ICsgdyAqIChnNCAtIGc4KSkgKiBmUGVyczI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjb2xvciA9IChzICogZlBlcnNNYXggKyAxKSAqIDEyODtcclxuXHJcbiAgICAgICAgICAgIGJpdG1hcC5zZXQocHgsIHB5LCAweGZmMDAwMDAwIHwgY29sb3IgPDwgMTYgfCBjb2xvciA8PCA4IHwgY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgX3ggKz0gYmFzZUZhY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF95ICs9IGJhc2VGYWN0b3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYml0bWFwLnZhbHVlO1xyXG59OyIsIi8qIGpzaGludCBiaXR3aXNlOmZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpO1xyXG5cclxuLyoqXHJcbiAqIChhIE1lcnNlbm5lIHByaW1lIE0zMSkgbW9kdWx1cyBjb25zdGFudCA9IDJeMzEgLSAxID0gMHg3ZmZmZmZmZVxyXG4gKi9cclxudmFyIE1QTSA9IDIxNDc0ODM2NDcuMDtcclxuXHJcbi8qKlxyXG4gKiAoYSBwcmltaXRpdmUgcm9vdCBtb2R1bG8gTTMxKVxyXG4gKi9cclxudmFyIE1JTlNURCA9IDE2ODA3LjA7XHJcblxyXG4vKipcclxuICogTWFrZSBhIG5vbiBkZXRlcm1pbmlzdGljIHJhbmRvbSBzZWVkIHVzaW5nIHN0YW5kYXJkIGxpYnJhcmllcy5cclxuICogQHJldHVybiBOb24gZGV0ZXJtaW5pc3RpYyByYW5kb20gc2VlZC5cclxuICovXHJcbmV4cG9ydHMubWFrZVJhbmRvbVNlZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTVBNKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQYXJrLU1pbGxlci1DYXJ0YSBhbGdvcml0aG0uXHJcbiAqIEBzZWUgPGEgaHJlZj1cImh0dHA6Ly9sYWIucG9seWdvbmFsLmRlLz9wPTE2MlwiPmh0dHA6Ly9sYWIucG9seWdvbmFsLmRlLz9wPTE2MjwvYT5cclxuICogQHNlZSA8YSBocmVmPVwiaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHlnb25hbC9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9saWIvZGUvcG9seWdvbmFsL2NvcmUvbWF0aC9yYW5kb20vUGFya01pbGxlci5oeD9yPTU0N1wiPmh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5Z29uYWwvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbGliL2RlL3BvbHlnb25hbC9jb3JlL21hdGgvcmFuZG9tL1BhcmtNaWxsZXIuaHg/cj01NDc8L2E+IFxyXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xlaG1lcl9yYW5kb21fbnVtYmVyX2dlbmVyYXRvclwiPmh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGVobWVyX3JhbmRvbV9udW1iZXJfZ2VuZXJhdG9yPC9hPlxyXG4gKiBAcmV0dXJuIFJldHVybnMgdGhlIG5leHQgcHNldWRvLXJhbmRvbSBpbnQgdmFsdWUuXHJcbiAqL1xyXG5leHBvcnRzLm5leHRQYXJrTWlsbGVyID0gZnVuY3Rpb24gKHNlZWQpIHtcclxuICAgIHJldHVybiAoc2VlZCAqIE1JTlNURCkgJSBNUE07XHJcbn07XHJcblxyXG4vKipcclxuICogPHA+QSBQYXJrLU1pbGxlci1DYXJ0YSBQUk5HIChwc2V1ZG8gcmFuZG9tIG51bWJlciBnZW5lcmF0b3IpLjwvcD5cclxuICogPHA+SW50ZWdlciBpbXBsZW1lbnRhdGlvbiwgdXNpbmcgb25seSAzMiBiaXQgaW50ZWdlciBtYXRocyBhbmQgbm8gZGl2aXNpb25zLjwvcD5cclxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3BvbHlnb25hbC9jb3JlL2Jsb2IvZGV2L3NyYy9kZS9wb2x5Z29uYWwvY29yZS9tYXRoL3JhbmRvbS9QYXJrTWlsbGVyMzEuaHhcIj5QT0xZR09OQUwgLSBBIEhBWEUgTElCUkFSWSBGT1IgR0FNRSBERVZFTE9QRVJTPC9hPlxyXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmZpcnN0cHIuY29tLmF1L2RzcC9yYW5kMzEvcmFuZDMxLXBhcmstbWlsbGVyLWNhcnRhLmNjLnR4dFwiIHRhcmdldD1cIl9ibGFua1wiPmh0dHA6Ly93d3cuZmlyc3Rwci5jb20uYXUvZHNwL3JhbmQzMS9yYW5kMzEtcGFyay1taWxsZXItY2FydGEuY2MudHh0PC9hPlxyXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcmslRTIlODAlOTNNaWxsZXJfcmFuZG9tX251bWJlcl9nZW5lcmF0b3JcIiB0YXJnZXQ9XCJfYmxhbmtcIj5QYXJrLU1pbGxlciByYW5kb20gbnVtYmVyIGdlbmVyYXRvcjwvYT4uXHJcbiAqIEBzZWUgPGEgaHJlZj1cImh0dHA6Ly9sYWIucG9seWdvbmFsLmRlLz9wPTE2MlwiIHRhcmdldD1cIl9ibGFua1wiPkEgZ29vZCBQc2V1ZG8tUmFuZG9tIE51bWJlciBHZW5lcmF0b3IgKFBSTkcpPC9hPi5cclxuICovXHJcbmV4cG9ydHMubmV4dFBhcmtNaWxsZXIzMSA9IGZ1bmN0aW9uIChzZWVkKSB7XHJcbiAgICB2YXIgbG8gPSAxNjgwNyAqIChzZWVkICYgMHhmZmZmKTtcclxuICAgIHZhciBoaSA9IDE2ODA3ICogKHNlZWQgPj4+IDE2KTtcclxuICAgIGxvICs9IChoaSAmIDB4N2ZmZikgPDwgMTY7XHJcbiAgICBsbyArPSBoaSA+Pj4gMTU7XHJcbiAgICBpZiAobG8gPiAweDdmZmZmZmZmKSB7IGxvIC09IDB4N2ZmZmZmZmY7IH1cclxuICAgIHJldHVybiBsbztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMaW5lYXIgY29uZ3J1ZW50aWFsIGdlbmVyYXRvciB1c2luZyBHTElCQyBjb25zdGFudHMuXHJcbiAqIFxyXG4gKiBAc2VlIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9jb25ncnVlbnRpYWxfZ2VuZXJhdG9yXCI+aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvcjwvYT5cclxuICogQHNlZSA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2FkdXJvcy9mbGFtYmUvYmxvYi9tYXN0ZXIvc3JjL2ZsYW1iZS91dGlsL1JhbmRvbS5oeFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9hZHVyb3MvZmxhbWJlL2Jsb2IvbWFzdGVyL3NyYy9mbGFtYmUvdXRpbC9SYW5kb20uaHg8L2E+XHJcbiAqIEByZXR1cm4gUmV0dXJucyBhbiBpbnRlZ2VyIGluIFswLCBJTlRfTUFYKVxyXG4gKi9cclxuZXhwb3J0cy5uZXh0TENHID0gZnVuY3Rpb24gKHNlZWQpIHtcclxuICAgIC8vIFRoZXNlIGNvbnN0YW50cyBib3Jyb3dlZCBmcm9tIGdsaWJjXHJcbiAgICAvLyBGb3JjZSBmbG9hdCBtdWx0aXBsaWNhdGlvbiBoZXJlIHRvIGF2b2lkIG92ZXJmbG93IGluIEZsYXNoIChhbmQga2VlcCBwYXJpdHkgd2l0aCBKUylcclxuICAgIHJldHVybiAoMTEwMzUxNTI0NS4wICogc2VlZCArIDEyMzQ1KSAlIE1QTTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwc2V1ZG8tcmFuZG9tIGRvdWJsZSB2YWx1ZSB4IGluIHRoZSByYW5nZSAwIDw9IHggPCAxLlxyXG4gKi9cclxuZXhwb3J0cy50b0Zsb2F0ID0gZnVuY3Rpb24gKHNlZWQpIHtcclxuICAgIHJldHVybiBzZWVkIC8gTVBNO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwc2V1ZG8tcmFuZG9tIGJvb2xlYW4gdmFsdWUgKGNvaW4gZmxpcCkuXHJcbiAqL1xyXG5leHBvcnRzLnRvQm9vbCA9IGZ1bmN0aW9uIChzZWVkKSB7XHJcbiAgICByZXR1cm4gZXhwb3J0cy50b0Zsb2F0KHNlZWQpID4gMC41O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwc2V1ZG8tcmFuZG9tIGRvdWJsZSB2YWx1ZSB4IGluIHRoZSByYW5nZSBtaW4gPD0geCA8PSBtYXguXHJcbiAqL1xyXG5leHBvcnRzLnRvRmxvYXRSYW5nZSA9IGZ1bmN0aW9uIChzZWVkLCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIG1pbiArIChtYXggLSBtaW4pICogZXhwb3J0cy50b0Zsb2F0KHNlZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwc2V1ZG8tcmFuZG9tIGludGVncmFsIHZhbHVlIHggaW4gdGhlIHJhbmdlIG1pbiA8PSB4IDw9IG1heC5cclxuICovXHJcbmV4cG9ydHMudG9JbnRSYW5nZSA9IGZ1bmN0aW9uIChzZWVkLCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKG1pbiAtIDAuNDk5OSkgKyAoKG1heCArIDAuNDk5OSkgLSAobWluIC0gMC40OTk5KSkgKiBleHBvcnRzLnRvRmxvYXQoc2VlZCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgc2VlZC5cclxuICogTGV0cyB5b3UgdXNlIHdvcmRzIGFzIHNlZWRzLlxyXG4gKi9cclxuZXhwb3J0cy5zdHJpbmdUb1NlZWQgPSBmdW5jdGlvbiAocykge1xyXG4gICAgcmV0dXJuIGhhc2guZGpiMihzKSAlIE1QTTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbG9zdXJlIGZvciB0cmFja2luZyByYW5kb20gbnVtYmVyIHN0YXRlLlxyXG4gKiBAcGFyYW0gICBzZWVkXHJcbiAqIEBwYXJhbSAgIGFsZ29yaXRobVxyXG4gKi9cclxuZXhwb3J0cy5yYW5kb21HZW5lcmF0b3IgPSBmdW5jdGlvbiAoc2VlZCwgbmV4dFJhbmRvbU51bWJlckFsZ29yaXRobSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWVkID0gbmV4dFJhbmRvbU51bWJlckFsZ29yaXRobShzZWVkKTtcclxuICAgICAgICByZXR1cm4gc2VlZDtcclxuICAgIH07XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuaW5kZXhPZihwYXR0ZXJuKSA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBzdGFydDtcclxuICAgIHZhciBsYXN0O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBsYXN0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBsb2c6IGZ1bmN0aW9uIChsYWJlbCkge1xyXG4gICAgICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobGFiZWwsIG5vdyAtIGxhc3QsIG5vdyAtIHN0YXJ0KTtcclxuICAgICAgICAgICAgbGFzdCA9IG5vdztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxuIiwiLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIFRPUDogMSxcclxuICAgIEJPVFRPTTogMixcclxuICAgIExFRlQ6IDQsXHJcbiAgICBSSUdIVDogOCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gYm91bmRzXHJcbiAgICAgKiBAcmV0dXJuIGFuIGludCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBiaXRzIHNldCBpZiB0aGUgUG9pbnQgbGllcyBvbiB0aGUgY29ycmVzcG9uZGluZyBib3VuZHMgbGluZXNcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBjaGVjazogZnVuY3Rpb24gKHBvaW50LCBib3VuZHMpIHtcclxuICAgICAgICBib3VuZHMgPSByZXF1aXJlKCcuLi8uLi9hczMvcmVjdGFuZ2xlJykuY29yZShib3VuZHMpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IDA7XHJcbiAgICAgICAgaWYgKHBvaW50LnggPT09IGJvdW5kcy5sZWZ0KCkpIHtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy5MRUZUO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9pbnQueCA9PT0gYm91bmRzLnJpZ2h0KCkpIHtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy5SSUdIVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvaW50LnkgPT09IGJvdW5kcy50b3AoKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLlRPUDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvaW50LnkgPT09IGJvdW5kcy5ib3R0b20oKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLkJPVFRPTTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgdmVydGV4OiAndmVydGV4JyxcclxuICAgIHNpdGU6ICdzaXRlJ1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICBkZWxhdW5heUxpbmVzRm9yRWRnZXM6IGZ1bmN0aW9uIChlZGdlcykge1xyXG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIF8oZWRnZXMpLmVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcclxuICAgICAgICAgICAgc2VnbWVudHMucHVzaChlZGdlLmRlbGF1bmF5TGluZSgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc2VnbWVudHM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNlbGVjdEVkZ2VzRm9yU2l0ZVBvaW50OiBmdW5jdGlvbiAoY29vcmQsIGVkZ2VzVG9UZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIF8oZWRnZXNUb1Rlc3QpLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKChlZGdlLmxlZnRTaXRlICE9PSBudWxsICYmIGVkZ2UubGVmdFNpdGUuY29vcmQgPT09IGNvb3JkKSB8fFxyXG4gICAgICAgICAgICAgICAgKGVkZ2UucmlnaHRTaXRlICE9PSBudWxsICYmIGVkZ2UucmlnaHRTaXRlLmNvb3JkID09PSBjb29yZCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZWxlY3ROb25JbnRlcnNlY3RpbmdFZGdlczogZnVuY3Rpb24gKGtlZXBPdXRNYXNrLCBlZGdlc1RvVGVzdCkge1xyXG4gICAgICAgIGlmIChrZWVwT3V0TWFzayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWRnZXNUb1Rlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB6ZXJvUG9pbnQgPSB7eDogMC4wLCB5OiAwLjB9O1xyXG4gICAgICAgIHJldHVybiBfKGVkZ2VzVG9UZXN0KS5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGRlbGF1bmF5TGluZUJtcCA9IGVkZ2UubWFrZURlbGF1bmF5TGluZUJtcCgpO1xyXG4gICAgICAgICAgICB2YXIgbm90SW50ZXJzZWN0aW5nID0gIShrZWVwT3V0TWFzay5oaXRUZXN0KHplcm9Qb2ludCwgMSwgZGVsYXVuYXlMaW5lQm1wLCB6ZXJvUG9pbnQsIDEpKTtcclxuICAgICAgICAgICAgZGVsYXVuYXlMaW5lQm1wLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vdEludGVyc2VjdGluZztcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgdmlzaWJsZUxpbmVTZWdtZW50czogZnVuY3Rpb24gKGVkZ2VzKSB7XHJcbiAgICAgICAgdmFyIGxyID0gcmVxdWlyZSgnLi9scicpO1xyXG4gICAgICAgIHZhciBsaW5lU2VnbWVudCA9IHJlcXVpcmUoJy4uL2dlb20vbGluZS1zZWdtZW50Jyk7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgXyhlZGdlcykuZWFjaChmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgICAgICBpZiAoZWRnZS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcDEgPSBlZGdlLmNsaXBwZWRFbmRzW2xyLkxFRlRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAyID0gZWRnZS5jbGlwcGVkRW5kc1tsci5SSUdIVF07XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGxpbmVTZWdtZW50Lm1ha2UocDEsIHAyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc2VnbWVudHM7XHJcbiAgICB9XHJcblxyXG59OyIsIi8qIGpzaGludCBiaXR3aXNlOmZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaGFsZmVkZ2VNb2R1bGUgPSByZXF1aXJlKCcuL2hhbGZlZGdlJyk7XHJcbnZhciBlZGdlTW9kdWxlID0gcmVxdWlyZSgnLi9lZGdlJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4bWluLCBkZWx0YXgsIHNxcnROc2l0ZXMpIHtcclxuICAgIHZhciBwdWIgPSB7fTtcclxuXHJcbiAgICB2YXIgX2RlbHRheCA9IDAuMDtcclxuICAgIHZhciBfeG1pbiAgPSAwLjA7XHJcbiAgICBcclxuICAgIHZhciBfaGFzaHNpemUgPSAwO1xyXG4gICAgdmFyIF9oYXNoID0gW107IC8vIFZlY3RvcjxIYWxmZWRnZT47XHJcblxyXG4gICAgdmFyIF9sZWZ0RW5kID0gbnVsbDsgLy9IYWxmZWRnZTtcclxuICAgIHB1Yi5nZXRMZWZ0RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfbGVmdEVuZDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwdWIsIHtcclxuICAgICAgICAnbGVmdEVuZCc6IHtnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1Yi5nZXRMZWZ0RW5kKCk7IH19XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgX3JpZ2h0RW5kID0gbnVsbDsgLy9IYWxmZWRnZTtcclxuICAgIHB1Yi5nZXRSaWdodEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3JpZ2h0RW5kO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHB1Yiwge1xyXG4gICAgICAgICdyaWdodEVuZCc6IHtnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1Yi5nZXRSaWdodEVuZCgpOyB9fVxyXG4gICAgfSk7XHJcblxyXG4gICAgcHViLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhhbGZFZGdlID0gX2xlZnRFbmQ7XHJcbiAgICAgICAgdmFyIHByZXZIZTtcclxuICAgICAgICB3aGlsZSAoaGFsZkVkZ2UgIT09IF9yaWdodEVuZCkge1xyXG4gICAgICAgICAgICBwcmV2SGUgPSBoYWxmRWRnZTtcclxuICAgICAgICAgICAgaGFsZkVkZ2UgPSBoYWxmRWRnZS5lZGdlTGlzdFJpZ2h0TmVpZ2hib3I7XHJcbiAgICAgICAgICAgIHByZXZIZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9sZWZ0RW5kID0gbnVsbDtcclxuICAgICAgICBfcmlnaHRFbmQuZGlzcG9zZSgpO1xyXG4gICAgICAgIF9yaWdodEVuZCA9IG51bGw7XHJcblxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfaGFzaHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBfaGFzaFtpXSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9oYXNoID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnQgbmV3SGFsZmVkZ2UgdG8gdGhlIHJpZ2h0IG9mIGxiIFxyXG4gICAgICogQHBhcmFtIGxiXHJcbiAgICAgKiBAcGFyYW0gbmV3SGFsZmVkZ2VcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBwdWIuaW5zZXJ0ID0gZnVuY3Rpb24gKGxiLCBuZXdIYWxmZWRnZSkge1xyXG4gICAgICAgIG5ld0hhbGZlZGdlLmVkZ2VMaXN0TGVmdE5laWdoYm9yID0gbGI7XHJcbiAgICAgICAgbmV3SGFsZmVkZ2UuZWRnZUxpc3RSaWdodE5laWdoYm9yID0gbGIuZWRnZUxpc3RSaWdodE5laWdoYm9yO1xyXG4gICAgICAgIGxiLmVkZ2VMaXN0UmlnaHROZWlnaGJvci5lZGdlTGlzdExlZnROZWlnaGJvciA9IG5ld0hhbGZlZGdlO1xyXG4gICAgICAgIGxiLmVkZ2VMaXN0UmlnaHROZWlnaGJvciA9IG5ld0hhbGZlZGdlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gb25seSByZW1vdmVzIHRoZSBIYWxmZWRnZSBmcm9tIHRoZSBsZWZ0LXJpZ2h0IGxpc3QuXHJcbiAgICAgKiBXZSBjYW5ub3QgZGlzcG9zZSBpdCB5ZXQgYmVjYXVzZSB3ZSBhcmUgc3RpbGwgdXNpbmcgaXQuIFxyXG4gICAgICogQHBhcmFtIGhhbGZFZGdlXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgcHViLnJlbW92ZSA9IGZ1bmN0aW9uIChoYWxmRWRnZSkge1xyXG4gICAgICAgIGhhbGZFZGdlLmVkZ2VMaXN0TGVmdE5laWdoYm9yLmVkZ2VMaXN0UmlnaHROZWlnaGJvciA9IGhhbGZFZGdlLmVkZ2VMaXN0UmlnaHROZWlnaGJvcjtcclxuICAgICAgICBoYWxmRWRnZS5lZGdlTGlzdFJpZ2h0TmVpZ2hib3IuZWRnZUxpc3RMZWZ0TmVpZ2hib3IgPSBoYWxmRWRnZS5lZGdlTGlzdExlZnROZWlnaGJvcjtcclxuICAgICAgICBoYWxmRWRnZS5lZGdlID0gZWRnZU1vZHVsZS5ERUxFVEVEO1xyXG4gICAgICAgIGhhbGZFZGdlLmVkZ2VMaXN0TGVmdE5laWdoYm9yID0gaGFsZkVkZ2UuZWRnZUxpc3RSaWdodE5laWdoYm9yID0gbnVsbDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qIEdldCBlbnRyeSBmcm9tIGhhc2ggdGFibGUsIHBydW5pbmcgYW55IGRlbGV0ZWQgbm9kZXMgKi9cclxuICAgIGZ1bmN0aW9uIGdldEhhc2goYikge1xyXG4gICAgICAgIHZhciBoYWxmRWRnZTtcclxuICAgIFxyXG4gICAgICAgIGlmIChiIDwgMCB8fCBiID49IF9oYXNoc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFsZkVkZ2UgPSBfaGFzaFtiXTtcclxuICAgICAgICBpZiAoaGFsZkVkZ2UgIT09IG51bGwgJiYgaGFsZkVkZ2UuZWRnZSA9PT0gZWRnZU1vZHVsZS5ERUxFVEVEKSB7XHJcbiAgICAgICAgICAgIC8qIEhhc2ggdGFibGUgcG9pbnRzIHRvIGRlbGV0ZWQgaGFsZmVkZ2UuICBQYXRjaCBhcyBuZWNlc3NhcnkuICovXHJcbiAgICAgICAgICAgIF9oYXNoW2JdID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gc3RpbGwgY2FuJ3QgZGlzcG9zZSBoYWxmRWRnZSB5ZXQhXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYWxmRWRnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSByaWdodG1vc3QgSGFsZmVkZ2UgdGhhdCBpcyBzdGlsbCBsZWZ0IG9mIHAgXHJcbiAgICAgKiBAcGFyYW0gcFxyXG4gICAgICogQHJldHVybiBcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBwdWIuZWRnZUxpc3RMZWZ0TmVpZ2hib3IgPSBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIHZhciBidWNrZXQ7XHJcbiAgICAgICAgdmFyIGhhbGZFZGdlO1xyXG4gICAgXHJcbiAgICAgICAgLyogVXNlIGhhc2ggdGFibGUgdG8gZ2V0IGNsb3NlIHRvIGRlc2lyZWQgaGFsZmVkZ2UgKi9cclxuICAgICAgICBidWNrZXQgPSAoKHAueCAtIF94bWluKSAvIF9kZWx0YXgpICogX2hhc2hzaXplO1xyXG4gICAgICAgIGlmIChidWNrZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIGJ1Y2tldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChidWNrZXQgPj0gX2hhc2hzaXplKSB7XHJcbiAgICAgICAgICAgIGJ1Y2tldCA9IF9oYXNoc2l6ZSAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbGZFZGdlID0gZ2V0SGFzaChidWNrZXQpO1xyXG4gICAgICAgIGlmIChoYWxmRWRnZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9IDE7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGhhbGZFZGdlID0gdGhpcy5nZXRIYXNoKGJ1Y2tldCAtIGkpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChoYWxmRWRnZSA9IHRoaXMuZ2V0SGFzaChidWNrZXQgKyBpKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIE5vdyBzZWFyY2ggbGluZWFyIGxpc3Qgb2YgaGFsZmVkZ2VzIGZvciB0aGUgY29ycmVjdCBvbmUgKi9cclxuICAgICAgICBpZiAoaGFsZkVkZ2UgPT09IHRoaXMuZ2V0TGVmdEVuZCgpICB8fCAoaGFsZkVkZ2UgIT09IHRoaXMuZ2V0UmlnaHRFbmQoKSAmJiBoYWxmRWRnZS5pc0xlZnRPZihwKSkpIHtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaGFsZkVkZ2UgPSBoYWxmRWRnZS5lZGdlTGlzdFJpZ2h0TmVpZ2hib3I7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGhhbGZFZGdlICE9PSB0aGlzLmdldFJpZ2h0RW5kKCkgJiYgaGFsZkVkZ2UuaXNMZWZ0T2YocCkpO1xyXG4gICAgICAgICAgICBoYWxmRWRnZSA9IGhhbGZFZGdlLmVkZ2VMaXN0TGVmdE5laWdoYm9yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGhhbGZFZGdlID0gaGFsZkVkZ2UuZWRnZUxpc3RMZWZ0TmVpZ2hib3I7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGhhbGZFZGdlICE9PSB0aGlzLmdldExlZnRFbmQoKSAmJiAhaGFsZkVkZ2UuaXNMZWZ0T2YocCkpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgIC8qIFVwZGF0ZSBoYXNoIHRhYmxlIGFuZCByZWZlcmVuY2UgY291bnRzICovXHJcbiAgICAgICAgaWYgKGJ1Y2tldCA+IDAgJiYgYnVja2V0IDwgX2hhc2hzaXplIC0gMSkge1xyXG4gICAgICAgICAgICBfaGFzaFtidWNrZXRdID0gaGFsZkVkZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYWxmRWRnZTtcclxuICAgIH07XHJcblxyXG4gICAgX3htaW4gPSB4bWluO1xyXG4gICAgX2RlbHRheCA9IGRlbHRheDtcclxuICAgIF9oYXNoc2l6ZSA9IDIgKiBzcXJ0TnNpdGVzO1xyXG5cclxuICAgIC8vdmFyIGk6SW50O1xyXG4gICAgX2hhc2ggPSBbXTtcclxuICAgIFxyXG4gICAgLy8gdHdvIGR1bW15IEhhbGZlZGdlczpcclxuICAgIF9sZWZ0RW5kID0gaGFsZmVkZ2VNb2R1bGUuY3JlYXRlRHVtbXkoKTtcclxuICAgIF9yaWdodEVuZCA9IGhhbGZlZGdlTW9kdWxlLmNyZWF0ZUR1bW15KCk7XHJcbiAgICBfbGVmdEVuZC5lZGdlTGlzdExlZnROZWlnaGJvciA9IG51bGw7XHJcbiAgICBfbGVmdEVuZC5lZGdlTGlzdFJpZ2h0TmVpZ2hib3IgPSBfcmlnaHRFbmQ7XHJcbiAgICBfcmlnaHRFbmQuZWRnZUxpc3RMZWZ0TmVpZ2hib3IgPSBfbGVmdEVuZDtcclxuICAgIF9yaWdodEVuZC5lZGdlTGlzdFJpZ2h0TmVpZ2hib3IgPSBudWxsO1xyXG4gICAgX2hhc2hbMF0gPSBfbGVmdEVuZDtcclxuICAgIF9oYXNoW19oYXNoc2l6ZSAtIDFdID0gX3JpZ2h0RW5kO1xyXG5cclxuICAgIHJldHVybiBwdWI7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNyaXRlcmlvbk1vZHVsZSA9IHJlcXVpcmUoJy4vY3JpdGVyaW9uJyk7XHJcbnZhciBsciA9IHJlcXVpcmUoJy4vbHInKTtcclxudmFyIHZlcnRleCA9IHJlcXVpcmUoJy4vdmVydGV4Jyk7XHJcblxyXG52YXIgRWRnZVJlb3JkZXJlciA9IGZ1bmN0aW9uIChvcmlnRWRnZXMsIGNyaXRlcmlvbikge1xyXG4gICAgaWYgKGNyaXRlcmlvbiAhPT0gY3JpdGVyaW9uTW9kdWxlLnZlcnRleCAmJiBjcml0ZXJpb24gIT09IGNyaXRlcmlvbk1vZHVsZS5zaXRlKSB7XHJcbiAgICAgICAgdGhyb3cgJ0VkZ2VzOiBjcml0ZXJpb24gbXVzdCBiZSBWZXJ0ZXggb3IgU2l0ZSc7XHJcbiAgICB9XHJcbiAgICB0aGlzLmVkZ2VzID0gW107XHJcbiAgICB0aGlzLmVkZ2VPcmllbnRhdGlvbnMgPSBbXTtcclxuICAgIGlmIChvcmlnRWRnZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMuZWRnZXMgPSB0aGlzLl9yZW9yZGVyRWRnZXMob3JpZ0VkZ2VzLCBjcml0ZXJpb24pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRWRnZVJlb3JkZXJlci5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgZWRnZXM6IG51bGwsIC8vIFZlY3RvcjxFZGdlPlxyXG4gICAgZWRnZU9yaWVudGF0aW9uczogbnVsbCwgLy8gVmVjdG9yPExSPlxyXG5cclxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVkZ2VzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmVkZ2VPcmllbnRhdGlvbnMgPSBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICBfcmVvcmRlckVkZ2VzOiBmdW5jdGlvbiAob3JpZ0VkZ2VzLCBjcml0ZXJpb24pIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbiA9IG9yaWdFZGdlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGVkZ2U7XHJcbiAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gcmVvcmRlciB0aGUgZWRnZXMgaW4gb3JkZXIgb2YgdHJhdmVyc2FsXHJcbiAgICAgICAgdmFyIGRvbmUgPSBbXTsgLy8gVmVjdG9yPEJvb2xlYW4+XHJcbiAgICAgICAgdmFyIG5Eb25lID0gMDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbmV3RWRnZXMgPSBbXTsgLy8gVmVjdG9yPEVkZ2U+XHJcbiAgICAgICAgXHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgZWRnZSA9IG9yaWdFZGdlc1tpXTtcclxuICAgICAgICBuZXdFZGdlcy5wdXNoKGVkZ2UpO1xyXG4gICAgICAgIHRoaXMuZWRnZU9yaWVudGF0aW9ucy5wdXNoKGxyLkxFRlQpO1xyXG4gICAgICAgIHZhciBmaXJzdFBvaW50O1xyXG4gICAgICAgIHZhciBsYXN0UG9pbnQ7XHJcbiAgICAgICAgaWYgKGNyaXRlcmlvbiA9PT0gY3JpdGVyaW9uTW9kdWxlLnZlcnRleCkge1xyXG4gICAgICAgICAgICBmaXJzdFBvaW50ID0gZWRnZS5sZWZ0VmVydGV4O1xyXG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBlZGdlLnJpZ2h0VmVydGV4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZpcnN0UG9pbnQgPSBlZGdlLmxlZnRTaXRlO1xyXG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBlZGdlLnJpZ2h0U2l0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGZpcnN0UG9pbnQgPT09IHZlcnRleC5WRVJURVhfQVRfSU5GSU5JVFkgfHwgbGFzdFBvaW50ID09PSB2ZXJ0ZXguVkVSVEVYX0FUX0lORklOSVRZKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTsgLy8gVmVjdG9yPEVkZ2U+O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBkb25lW2ldID0gdHJ1ZTtcclxuICAgICAgICArK25Eb25lO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlIChuRG9uZSA8IG4pIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvbmVbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVkZ2UgPSBvcmlnRWRnZXNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFBvaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0UG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3JpdGVyaW9uID09PSBjcml0ZXJpb25Nb2R1bGUudmVydGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFBvaW50ID0gZWRnZS5sZWZ0VmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQgPSBlZGdlLnJpZ2h0VmVydGV4O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0UG9pbnQgPSBlZGdlLmxlZnRTaXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQgPSBlZGdlLnJpZ2h0U2l0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQb2ludCA9PT0gdmVydGV4LlZFUlRFWF9BVF9JTkZJTklUWSB8fCByaWdodFBvaW50ID09PSB2ZXJ0ZXguVkVSVEVYX0FUX0lORklOSVRZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvL1ZlY3RvcjxFZGdlPigpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdFBvaW50ID09PSBsYXN0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnQgPSByaWdodFBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZU9yaWVudGF0aW9ucy5wdXNoKGxyLkxFRlQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VkZ2VzLnB1c2goZWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZVtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFBvaW50ID09PSBmaXJzdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludCA9IGxlZnRQb2ludDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkZ2VPcmllbnRhdGlvbnMudW5zaGlmdChsci5MRUZUKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFZGdlcy51bnNoaWZ0KGVkZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmVbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGVmdFBvaW50ID09PSBmaXJzdFBvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RQb2ludCA9IHJpZ2h0UG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGdlT3JpZW50YXRpb25zLnVuc2hpZnQobHIuUklHSFQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VkZ2VzLnVuc2hpZnQoZWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZVtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyaWdodFBvaW50ID09PSBsYXN0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0UG9pbnQgPSBsZWZ0UG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGdlT3JpZW50YXRpb25zLnB1c2gobHIuUklHSFQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0VkZ2VzLnB1c2goZWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZVtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9uZVtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICsrbkRvbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5ld0VkZ2VzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdFZGdlcywgY3JpdGVyaW9uKSB7XHJcbiAgICByZXR1cm4gbmV3IEVkZ2VSZW9yZGVyZXIob3JpZ0VkZ2VzLCBjcml0ZXJpb24pO1xyXG59OyIsIi8qIGpzaGludCBlczM6ZmFsc2UgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBsaW5lU2VnbWVudCA9IHJlcXVpcmUoJy4uL2dlb20vbGluZS1zZWdtZW50Jyk7XHJcbnZhciBsciA9IHJlcXVpcmUoJy4vbHInKTtcclxudmFyIHBvaW50Q29yZSA9IHJlcXVpcmUoJy4uLy4uL2FzMy9wb2ludC1jb3JlJyk7XHJcbnZhciByZWN0YW5nbGUgPSByZXF1aXJlKCcuLi8uLi9hczMvcmVjdGFuZ2xlJyk7XHJcblxyXG52YXIgX3Bvb2wgPSBbXTtcclxudmFyIF9uZWRnZXMgPSAwO1xyXG5cclxuZXhwb3J0cy5FZGdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5fZWRnZUluZGV4ID0gX25lZGdlcysrO1xyXG4gICAgdGhpcy5pbml0KCk7XHJcbn07XHJcblxyXG5leHBvcnRzLkVkZ2UucHJvdG90eXBlID0ge1xyXG4gICAgX2RlbGF1bmF5TGluZUJtcDogbnVsbCxcclxuICAgIGdldERlbGF1bmF5TGluZUJtcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWxhdW5heUxpbmVCbXAgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVsYXVuYXlMaW5lQm1wID0gdGhpcy5tYWtlRGVsYXVuYXlMaW5lQm1wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxhdW5heUxpbmVCbXA7XHJcbiAgICB9LFxyXG4gICAgZ2V0IGRlbGF1bmF5TGluZUJtcCgpIHsgcmV0dXJuIHRoaXMuZ2V0RGVsYXVuYXlMaW5lQm1wKCk7IH0sXHJcblxyXG4gICAgLy8gbWFraW5nIHRoaXMgYXZhaWxhYmxlIHRvIFZvcm9ub2k7IHJ1bm5pbmcgb3V0IG9mIG1lbW9yeSBpbiBBSVIgc28gSSBjYW5ub3QgY2FjaGUgdGhlIGJtcFxyXG4gICAgbWFrZURlbGF1bmF5TGluZUJtcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRocm93ICd1bmltcGxlbWVudGVkJztcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcDAgPSB0aGlzLmxlZnRTaXRlLmNvb3JkO1xyXG4gICAgICAgIHZhciBwMSA9IHRoaXMucmlnaHRTaXRlLmNvb3JkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB3ID0gTWF0aC5jZWlsKE1hdGgubWF4KHAwLngsIHAxLngpKTtcclxuICAgICAgICBpZiAodyA8IDEpIHtcclxuICAgICAgICAgICAgdyA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoID0gTWF0aC5jZWlsKE1hdGgubWF4KHAwLnksIHAxLnkpKTtcclxuICAgICAgICBpZiAoaCA8IDEpIHtcclxuICAgICAgICAgICAgaCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdmFyIGJtcDpCaXRtYXBEYXRhID0gbmV3IEJpdG1hcERhdGEodywgaCwgdHJ1ZSwgMCk7XHJcbiAgICAgICAgdmFyIGJtcCA9IG5ldyBCaXRtYXBEYXRhKCk7XHJcblxyXG4gICAgICAgIC8vR1JBUEhJQ1MuY2xlYXIoKTtcclxuICAgICAgICAvLyBjbGVhcigpIHJlc2V0cyBsaW5lIHN0eWxlIGJhY2sgdG8gdW5kZWZpbmVkIVxyXG4gICAgICAgIC8vR1JBUEhJQ1MubGluZVN0eWxlKDAsIDAsIDEuMCwgZmFsc2UsIExpbmVTY2FsZU1vZGUuTk9ORSwgQ2Fwc1N0eWxlLk5PTkUpO1xyXG4gICAgICAgIC8vR1JBUEhJQ1MubW92ZVRvKHAwLngsIHAwLnkpO1xyXG4gICAgICAgIC8vR1JBUEhJQ1MubGluZVRvKHAxLngsIHAxLnkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGJtcC5kcmF3TGluZShwMCwgcDEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vYm1wLmRyYXcoTElORVNQUklURSk7XHJcbiAgICAgICAgcmV0dXJuIGJtcDtcclxuICAgIH0sXHJcblxyXG4gICAgZGVsYXVuYXlMaW5lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZHJhdyBhIGxpbmUgY29ubmVjdGluZyB0aGUgaW5wdXQgU2l0ZXMgZm9yIHdoaWNoIHRoZSBlZGdlIGlzIGEgYmlzZWN0b3I6XHJcbiAgICAgICAgcmV0dXJuIGxpbmVTZWdtZW50Lm1ha2UodGhpcy5sZWZ0U2l0ZS5jb29yZCwgdGhpcy5yaWdodFNpdGUuY29vcmQpO1xyXG4gICAgfSxcclxuXHJcbiAgICB2b3Jvbm9pRWRnZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lU2VnbWVudC5tYWtlKG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGluZVNlZ21lbnQubWFrZSh0aGlzLmNsaXBwZWRFbmRzW2xyLkxFRlRdLCB0aGlzLmNsaXBwZWRFbmRzW2xyLlJJR0hUXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHRoZSBlcXVhdGlvbiBvZiB0aGUgZWRnZTogYXggKyBieSA9IGNcclxuICAgIGE6IG51bGwsXHJcbiAgICBiOiBudWxsLFxyXG4gICAgYzogbnVsbCxcclxuXHJcbiAgICAvLyB0aGUgdHdvIFZvcm9ub2kgdmVydGljZXMgdGhhdCB0aGUgZWRnZSBjb25uZWN0c1xyXG4gICAgLy8gICAgICAoaWYgb25lIG9mIHRoZW0gaXMgbnVsbCwgdGhlIGVkZ2UgZXh0ZW5kcyB0byBpbmZpbml0eSlcclxuICAgIGxlZnRWZXJ0ZXg6IG51bGwsXHJcbiAgICByaWdodFZlcnRleDogbnVsbCxcclxuXHJcbiAgICB2ZXJ0ZXg6IGZ1bmN0aW9uIChsZWZ0UmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKGxlZnRSaWdodCA9PT0gbHIuTEVGVCkgPyB0aGlzLmxlZnRWZXJ0ZXggOiB0aGlzLnJpZ2h0VmVydGV4O1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRWZXJ0ZXg6IGZ1bmN0aW9uIChsZWZ0UmlnaHQsIHYpIHtcclxuICAgICAgICBpZiAobGVmdFJpZ2h0ID09PSBsci5MRUZUKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdFZlcnRleCA9IHY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodFZlcnRleCA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBpc1BhcnRPZkNvbnZleEh1bGw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGVmdFZlcnRleCA9PT0gbnVsbCB8fCB0aGlzLnJpZ2h0VmVydGV4ID09PSBudWxsKTtcclxuICAgIH0sXHJcblxyXG4gICAgc2l0ZXNEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBwb2ludENvcmUuZGlzdGFuY2UodGhpcy5sZWZ0U2l0ZS5jb29yZCwgdGhpcy5yaWdodFNpdGUuY29vcmQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBPbmNlIGNsaXBWZXJ0aWNlcygpIGlzIGNhbGxlZCwgdGhpcyBEaWN0aW9uYXJ5IHdpbGwgaG9sZCB0d28gUG9pbnRzXHJcbiAgICAvLyByZXByZXNlbnRpbmcgdGhlIGNsaXBwZWQgY29vcmRpbmF0ZXMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IGVuZHMuLi5cclxuICAgIC8vcHJpdmF0ZSB2YXIgX2NsaXBwZWRWZXJ0aWNlczpEaWN0aW9uYXJ5O1xyXG4gICAgY2xpcHBlZEVuZHM6IG51bGwsIC8vIERpY3Rpb25hcnk8UG9pbnQ+XHJcblxyXG4gICAgLy8gdW5sZXNzIHRoZSBlbnRpcmUgRWRnZSBpcyBvdXRzaWRlIHRoZSBib3VuZHMuXHJcbiAgICAvLyBJbiB0aGF0IGNhc2UgdmlzaWJsZSB3aWxsIGJlIGZhbHNlOlxyXG4gICAgZ2V0IHZpc2libGUoKSB7IHJldHVybiB0aGlzLmNsaXBwZWRFbmRzICE9PSBudWxsOyB9LFxyXG5cclxuICAgIC8vIHRoZSB0d28gaW5wdXQgU2l0ZXMgZm9yIHdoaWNoIHRoaXMgRWRnZSBpcyBhIGJpc2VjdG9yOlxyXG4gICAgLy9wcml2YXRlIHZhciBfc2l0ZXM6RGljdGlvbmFyeTxTaXRlPjtcclxuICAgIC8vIHRoZSB0d28gaW5wdXQgU2l0ZXMgZm9yIHdoaWNoIHRoaXMgRWRnZSBpcyBhIGJpc2VjdG9yOiAgICAgICAgICAgICAgIFxyXG4gICAgbGVmdFNpdGU6IG51bGwsXHJcbiAgICByaWdodFNpdGU6IG51bGwsXHJcblxyXG4gICAgc2l0ZTogZnVuY3Rpb24gKGxlZnRSaWdodCkge1xyXG4gICAgICAgIHJldHVybiAobGVmdFJpZ2h0ID09PSBsci5MRUZUKSA/IHRoaXMubGVmdFNpdGUgOiB0aGlzLnJpZ2h0U2l0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgX2VkZ2VJbmRleDogMCxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlbGF1bmF5TGluZUJtcCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxhdW5heUxpbmVCbXAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxhdW5heUxpbmVCbXAgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlZnRWZXJ0ZXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHRWZXJ0ZXggPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLmNsaXBwZWRFbmRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEVuZHNbbHIuTEVGVF0gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNsaXBwZWRFbmRzW2xyLlJJR0hUXSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEVuZHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5sZWZ0U2l0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodFNpdGUgPSBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIF9wb29sLnB1c2godGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdFZGdlICcgKyB0aGlzLl9lZGdlSW5kZXggKyAnOyBzaXRlcyAnICsgdGhpcy5sZWZ0U2l0ZSArICcsICcgKyB0aGlzLnJpZ2h0U2l0ZSArXHJcbiAgICAgICAgICAgICc7IGVuZFZlcnRpY2VzICcgKyAodGhpcy5sZWZ0VmVydGV4ICE9PSBudWxsID8gU3RyaW5nKHRoaXMubGVmdFZlcnRleC52ZXJ0ZXhJbmRleCkgOiAnbnVsbCcpICsgJywgJyArXHJcbiAgICAgICAgICAgICh0aGlzLnJpZ2h0VmVydGV4ICE9PSBudWxsID8gU3RyaW5nKHRoaXMucmlnaHRWZXJ0ZXgudmVydGV4SW5kZXgpIDogJ251bGwnKSArICc6Oic7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IF9jbGlwcGVkVmVydGljZXMgdG8gY29udGFpbiB0aGUgdHdvIGVuZHMgb2YgdGhlIHBvcnRpb24gb2YgdGhlIFZvcm9ub2kgZWRnZSB0aGF0IGlzIHZpc2libGVcclxuICAgICAqIHdpdGhpbiB0aGUgYm91bmRzLiAgSWYgbm8gcGFydCBvZiB0aGUgRWRnZSBmYWxscyB3aXRoaW4gdGhlIGJvdW5kcywgbGVhdmUgX2NsaXBwZWRWZXJ0aWNlcyBudWxsLiBcclxuICAgICAqIEBwYXJhbSBib3VuZHNcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBjbGlwVmVydGljZXM6IGZ1bmN0aW9uIChib3VuZHMpIHtcclxuICAgICAgICB2YXIgYm91bmRzQ29yZSA9IHJlY3RhbmdsZS5jb3JlKGJvdW5kcyk7XHJcbiAgICAgICAgdmFyIHhtaW4gPSBib3VuZHMueDtcclxuICAgICAgICB2YXIgeW1pbiA9IGJvdW5kcy55O1xyXG4gICAgICAgIHZhciB4bWF4ID0gYm91bmRzQ29yZS5yaWdodCgpO1xyXG4gICAgICAgIHZhciB5bWF4ID0gYm91bmRzQ29yZS5ib3R0b20oKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdmVydGV4MCwgdmVydGV4MTtcclxuICAgICAgICB2YXIgeDAsIHgxLCB5MCwgeTE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuYSA9PT0gMS4wICYmIHRoaXMuYiA+PSAwLjApIHtcclxuICAgICAgICAgICAgdmVydGV4MCA9IHRoaXMucmlnaHRWZXJ0ZXg7XHJcbiAgICAgICAgICAgIHZlcnRleDEgPSB0aGlzLmxlZnRWZXJ0ZXg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmVydGV4MCA9IHRoaXMubGVmdFZlcnRleDtcclxuICAgICAgICAgICAgdmVydGV4MSA9IHRoaXMucmlnaHRWZXJ0ZXg7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgaWYgKHRoaXMuYSA9PT0gMS4wKSB7XHJcbiAgICAgICAgICAgIHkwID0geW1pbjtcclxuICAgICAgICAgICAgaWYgKHZlcnRleDAgIT09IG51bGwgJiYgdmVydGV4MC55ID4geW1pbikge1xyXG4gICAgICAgICAgICAgICAgeTAgPSB2ZXJ0ZXgwLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHkwID4geW1heCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHgwID0gdGhpcy5jIC0gdGhpcy5iICogeTA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB5MSA9IHltYXg7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgxICE9PSBudWxsICYmIHZlcnRleDEueSA8IHltYXgpIHtcclxuICAgICAgICAgICAgICAgIHkxID0gdmVydGV4MS55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5MSA8IHltaW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4MSA9IHRoaXMuYyAtIHRoaXMuYiAqIHkxO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCh4MCA+IHhtYXggJiYgeDEgPiB4bWF4KSB8fCAoeDAgPCB4bWluICYmIHgxIDwgeG1pbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHgwID4geG1heCkge1xyXG4gICAgICAgICAgICAgICAgeDAgPSB4bWF4O1xyXG4gICAgICAgICAgICAgICAgeTAgPSAodGhpcy5jIC0geDApIC8gdGhpcy5iO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHgwIDwgeG1pbikge1xyXG4gICAgICAgICAgICAgICAgeDAgPSB4bWluO1xyXG4gICAgICAgICAgICAgICAgeTAgPSAodGhpcy5jIC0geDApIC8gdGhpcy5iO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoeDEgPiB4bWF4KSB7XHJcbiAgICAgICAgICAgICAgICB4MSA9IHhtYXg7XHJcbiAgICAgICAgICAgICAgICB5MSA9ICh0aGlzLmMgLSB4MSkgLyB0aGlzLmI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoeDEgPCB4bWluKSB7XHJcbiAgICAgICAgICAgICAgICB4MSA9IHhtaW47XHJcbiAgICAgICAgICAgICAgICB5MSA9ICh0aGlzLmMgLSB4MSkgLyB0aGlzLmI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4MCA9IHhtaW47XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXgwICE9PSBudWxsICYmIHZlcnRleDAueCA+IHhtaW4pIHtcclxuICAgICAgICAgICAgICAgIHgwID0gdmVydGV4MC54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh4MCA+IHhtYXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5MCA9IHRoaXMuYyAtIHRoaXMuYSAqIHgwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgeDEgPSB4bWF4O1xyXG4gICAgICAgICAgICBpZiAodmVydGV4MSAhPT0gbnVsbCAmJiB2ZXJ0ZXgxLnggPCB4bWF4KSB7XHJcbiAgICAgICAgICAgICAgICB4MSA9IHZlcnRleDEueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeDEgPCB4bWluKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeTEgPSB0aGlzLmMgLSB0aGlzLmEgKiB4MTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICgoeTAgPiB5bWF4ICYmIHkxID4geW1heCkgfHwgKHkwIDwgeW1pbiAmJiB5MSA8IHltaW4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh5MCA+IHltYXgpIHtcclxuICAgICAgICAgICAgICAgIHkwID0geW1heDtcclxuICAgICAgICAgICAgICAgIHgwID0gKHRoaXMuYyAtIHkwKSAvIHRoaXMuYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh5MCA8IHltaW4pIHtcclxuICAgICAgICAgICAgICAgIHkwID0geW1pbjtcclxuICAgICAgICAgICAgICAgIHgwID0gKHRoaXMuYyAtIHkwKSAvIHRoaXMuYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHkxID4geW1heCkge1xyXG4gICAgICAgICAgICAgICAgeTEgPSB5bWF4O1xyXG4gICAgICAgICAgICAgICAgeDEgPSAodGhpcy5jIC0geTEpIC8gdGhpcy5hO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHkxIDwgeW1pbikge1xyXG4gICAgICAgICAgICAgICAgeTEgPSB5bWluO1xyXG4gICAgICAgICAgICAgICAgeDEgPSAodGhpcy5jIC0geTEpIC8gdGhpcy5hO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNsaXBwZWRFbmRzID0ge307XHJcbiAgICAgICAgaWYgKHZlcnRleDAgPT09IHRoaXMubGVmdFZlcnRleCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsaXBwZWRFbmRzW2xyLkxFRlRdID0ge3g6IHgwLCB5OiB5MH07XHJcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEVuZHNbbHIuUklHSFRdID0ge3g6IHgxLCB5OiB5MX07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jbGlwcGVkRW5kc1tsci5SSUdIVF0gPSB7eDogeDAsIHk6IHkwfTtcclxuICAgICAgICAgICAgdGhpcy5jbGlwcGVkRW5kc1tsci5MRUZUXSA9IHt4OiB4MSwgeTogeTF9O1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGVmdFNpdGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHRTaXRlID0gbnVsbDtcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjcmVhdGUoKSB7XHJcbiAgICB2YXIgZWRnZTtcclxuICAgIGlmIChfcG9vbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgZWRnZSA9IF9wb29sLnBvcCgpO1xyXG4gICAgICAgIGVkZ2UuaW5pdCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBlZGdlID0gbmV3IGV4cG9ydHMuRWRnZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVkZ2U7XHJcbn1cclxuXHJcbmV4cG9ydHMuREVMRVRFRCA9IG5ldyBleHBvcnRzLkVkZ2UoKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byBjcmVhdGUgYSBuZXcgRWRnZSBcclxuICogQHBhcmFtIHNpdGUwXHJcbiAqIEBwYXJhbSBzaXRlMVxyXG4gKiBAcmV0dXJuIFxyXG4gKiBcclxuICovXHJcbmV4cG9ydHMuY3JlYXRlQmlzZWN0aW5nRWRnZSA9IGZ1bmN0aW9uIChzaXRlMCwgc2l0ZTEpIHtcclxuICAgIHZhciBkeCwgZHksIGFic2R4LCBhYnNkeTtcclxuICAgIHZhciBhLCBiLCBjO1xyXG5cclxuICAgIGR4ID0gc2l0ZTEueCAtIHNpdGUwLng7XHJcbiAgICBkeSA9IHNpdGUxLnkgLSBzaXRlMC55O1xyXG4gICAgYWJzZHggPSBkeCA+IDAgPyBkeCA6IC1keDtcclxuICAgIGFic2R5ID0gZHkgPiAwID8gZHkgOiAtZHk7XHJcbiAgICBjID0gc2l0ZTAueCAqIGR4ICsgc2l0ZTAueSAqIGR5ICsgKGR4ICogZHggKyBkeSAqIGR5KSAqIDAuNTtcclxuICAgIGlmIChhYnNkeCA+IGFic2R5KSB7XHJcbiAgICAgICAgYSA9IDEuMDtcclxuICAgICAgICBiID0gZHkgLyBkeDtcclxuICAgICAgICBjIC89IGR4O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBiID0gMS4wO1xyXG4gICAgICAgIGEgPSBkeCAvIGR5O1xyXG4gICAgICAgIGMgLz0gZHk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBlZGdlID0gY3JlYXRlKCk7XHJcblxyXG4gICAgZWRnZS5sZWZ0U2l0ZSA9IHNpdGUwO1xyXG4gICAgZWRnZS5yaWdodFNpdGUgPSBzaXRlMTtcclxuICAgIHNpdGUwLmFkZEVkZ2UoZWRnZSk7XHJcbiAgICBzaXRlMS5hZGRFZGdlKGVkZ2UpO1xyXG4gICAgXHJcbiAgICBlZGdlLmxlZnRWZXJ0ZXggPSBudWxsO1xyXG4gICAgZWRnZS5yaWdodFZlcnRleCA9IG51bGw7XHJcbiAgICBcclxuICAgIGVkZ2UuYSA9IGE7XHJcbiAgICBlZGdlLmIgPSBiO1xyXG4gICAgZWRnZS5jID0gYztcclxuICAgIC8vdHJhY2UoXCJjcmVhdGVCaXNlY3RpbmdFZGdlOiBhIFwiLCBlZGdlLmEsIFwiYlwiLCBlZGdlLmIsIFwiY1wiLCBlZGdlLmMpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZWRnZTtcclxufTtcclxuXHJcbmV4cG9ydHMuY29tcGFyZVNpdGVzRGlzdGFuY2VzTWF4ID0gZnVuY3Rpb24gKGVkZ2UwLCBlZGdlMSkge1xyXG4gICAgdmFyIGxlbmd0aDAgPSBlZGdlMC5zaXRlc0Rpc3RhbmNlKCk7XHJcbiAgICB2YXIgbGVuZ3RoMSA9IGVkZ2UxLnNpdGVzRGlzdGFuY2UoKTtcclxuICAgIGlmIChsZW5ndGgwIDwgbGVuZ3RoMSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlbmd0aDAgPiBsZW5ndGgxKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn07XHJcblxyXG5leHBvcnRzLmNvbXBhcmVTaXRlc0Rpc3RhbmNlcyA9IGZ1bmN0aW9uIChlZGdlMCwgZWRnZTEpIHtcclxuICAgIHJldHVybiAtIGV4cG9ydHMuY29tcGFyZVNpdGVzRGlzdGFuY2VzTWF4KGVkZ2UwLCBlZGdlMSk7XHJcbn07IiwiLyoganNoaW50IGJpdHdpc2U6ZmFsc2UgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBoYWxmZWRnZU1vZHVsZSA9IHJlcXVpcmUoJy4vaGFsZmVkZ2UnKTtcclxudmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9qYW5pY2VrL2NvcmUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHltaW4sIGRlbHRheSwgc3FydE5zaXRlcykge1xyXG4gICAgdmFyIHB1YiA9IHt9O1xyXG5cclxuICAgIHZhciBfaGFzaCA9IG51bGw7IC8vVmVjdG9yPEhhbGZlZGdlPlxyXG4gICAgdmFyIF9jb3VudCA9IDA7XHJcbiAgICB2YXIgX21pbkJ1Y2tldCA9IDA7XHJcbiAgICB2YXIgX2hhc2hzaXplID0gMDtcclxuICAgIFxyXG4gICAgdmFyIF95bWluID0gMC4wO1xyXG4gICAgdmFyIF9kZWx0YXkgPSAwLjA7XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICB2YXIgaTtcclxuXHJcbiAgICAgICAgX2NvdW50ID0gMDtcclxuICAgICAgICBfbWluQnVja2V0ID0gMDtcclxuICAgICAgICBfaGFzaCA9IFtdO1xyXG4gICAgICAgIC8vIGR1bW15IEhhbGZlZGdlIGF0IHRoZSB0b3Agb2YgZWFjaCBoYXNoXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9oYXNoc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9oYXNoW2ldID0gaGFsZmVkZ2VNb2R1bGUuY3JlYXRlRHVtbXkoKTtcclxuICAgICAgICAgICAgX2hhc2hbaV0ubmV4dEluUHJpb3JpdHlRdWV1ZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1Y2tldChoYWxmRWRnZSkge1xyXG4gICAgICAgIHZhciB0aGVCdWNrZXQgPSBjb3JlLnRvSW50KChoYWxmRWRnZS55c3RhciAtIF95bWluKSAvIF9kZWx0YXkgKiBfaGFzaHNpemUpO1xyXG4gICAgICAgIGlmICh0aGVCdWNrZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRoZUJ1Y2tldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGVCdWNrZXQgPj0gX2hhc2hzaXplKSB7XHJcbiAgICAgICAgICAgIHRoZUJ1Y2tldCA9IF9oYXNoc2l6ZSAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGVCdWNrZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHViLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZ2V0IHJpZCBvZiBkdW1taWVzXHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9oYXNoc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIF9oYXNoW2ldLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgX2hhc2hbaV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfaGFzaCA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5pbnNlcnQgPSBmdW5jdGlvbiAoaGFsZkVkZ2UpIHtcclxuICAgICAgICB2YXIgcHJldmlvdXMsIG5leHQ7XHJcbiAgICAgICAgdmFyIGluc2VydGlvbkJ1Y2tldCA9IGJ1Y2tldChoYWxmRWRnZSk7XHJcblxyXG4gICAgICAgIGlmIChpbnNlcnRpb25CdWNrZXQgPCBfbWluQnVja2V0KSB7XHJcbiAgICAgICAgICAgIF9taW5CdWNrZXQgPSBpbnNlcnRpb25CdWNrZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZpb3VzID0gX2hhc2hbaW5zZXJ0aW9uQnVja2V0XTtcclxuICAgICAgICB3aGlsZSAoKG5leHQgPSBwcmV2aW91cy5uZXh0SW5Qcmlvcml0eVF1ZXVlKSAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAoaGFsZkVkZ2UueXN0YXIgID4gbmV4dC55c3RhciB8fCAoaGFsZkVkZ2UueXN0YXIgPT09IG5leHQueXN0YXIgJiYgaGFsZkVkZ2UudmVydGV4LnggPiBuZXh0LnZlcnRleC54KSkpIHtcclxuICAgICAgICAgICAgcHJldmlvdXMgPSBuZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYWxmRWRnZS5uZXh0SW5Qcmlvcml0eVF1ZXVlID0gcHJldmlvdXMubmV4dEluUHJpb3JpdHlRdWV1ZTtcclxuICAgICAgICBwcmV2aW91cy5uZXh0SW5Qcmlvcml0eVF1ZXVlID0gaGFsZkVkZ2U7XHJcbiAgICAgICAgKytfY291bnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5yZW1vdmUgPSBmdW5jdGlvbiAoaGFsZkVkZ2UpIHtcclxuICAgICAgICB2YXIgcHJldmlvdXM7XHJcbiAgICAgICAgdmFyIHJlbW92YWxCdWNrZXQgPSBidWNrZXQoaGFsZkVkZ2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChoYWxmRWRnZS52ZXJ0ZXggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJldmlvdXMgPSBfaGFzaFtyZW1vdmFsQnVja2V0XTtcclxuICAgICAgICAgICAgd2hpbGUgKHByZXZpb3VzLm5leHRJblByaW9yaXR5UXVldWUgIT09IGhhbGZFZGdlKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzLm5leHRJblByaW9yaXR5UXVldWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldmlvdXMubmV4dEluUHJpb3JpdHlRdWV1ZSA9IGhhbGZFZGdlLm5leHRJblByaW9yaXR5UXVldWU7XHJcbiAgICAgICAgICAgIF9jb3VudC0tO1xyXG4gICAgICAgICAgICBoYWxmRWRnZS52ZXJ0ZXggPSBudWxsO1xyXG4gICAgICAgICAgICBoYWxmRWRnZS5uZXh0SW5Qcmlvcml0eVF1ZXVlID0gbnVsbDtcclxuICAgICAgICAgICAgaGFsZkVkZ2UuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gaXNFbXB0eShidWNrZXQpIHtcclxuICAgICAgICByZXR1cm4gKF9oYXNoW2J1Y2tldF0ubmV4dEluUHJpb3JpdHlRdWV1ZSA9PT0gbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogbW92ZSBfbWluQnVja2V0IHVudGlsIGl0IGNvbnRhaW5zIGFuIGFjdHVhbCBIYWxmZWRnZSAobm90IGp1c3QgdGhlIGR1bW15IGF0IHRoZSB0b3ApOyBcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhZGp1c3RNaW5CdWNrZXQoKSB7XHJcbiAgICAgICAgd2hpbGUgKF9taW5CdWNrZXQgPCBfaGFzaHNpemUgLSAxICYmIGlzRW1wdHkoX21pbkJ1Y2tldCkpIHtcclxuICAgICAgICAgICAgKytfbWluQnVja2V0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWIuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9jb3VudCA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGNvb3JkaW5hdGVzIG9mIHRoZSBIYWxmZWRnZSdzIHZlcnRleCBpbiBWKiwgdGhlIHRyYW5zZm9ybWVkIFZvcm9ub2kgZGlhZ3JhbVxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHB1Yi5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYWRqdXN0TWluQnVja2V0KCk7XHJcbiAgICAgICAgdmFyIGFuc3dlciA9IF9oYXNoW19taW5CdWNrZXRdLm5leHRJblByaW9yaXR5UXVldWU7XHJcbiAgICAgICAgcmV0dXJuIHt4OiBhbnN3ZXIudmVydGV4LngsIHk6IGFuc3dlci55c3Rhcn07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmVtb3ZlIGFuZCByZXR1cm4gdGhlIG1pbiBIYWxmZWRnZVxyXG4gICAgICogQHJldHVybiBcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBwdWIuZXh0cmFjdE1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYW5zd2VyO1xyXG4gICAgXHJcbiAgICAgICAgLy8gZ2V0IHRoZSBmaXJzdCByZWFsIEhhbGZlZGdlIGluIF9taW5CdWNrZXRcclxuICAgICAgICBhbnN3ZXIgPSBfaGFzaFtfbWluQnVja2V0XS5uZXh0SW5Qcmlvcml0eVF1ZXVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIF9oYXNoW19taW5CdWNrZXRdLm5leHRJblByaW9yaXR5UXVldWUgPSBhbnN3ZXIubmV4dEluUHJpb3JpdHlRdWV1ZTtcclxuICAgICAgICBfY291bnQtLTtcclxuICAgICAgICBhbnN3ZXIubmV4dEluUHJpb3JpdHlRdWV1ZSA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGFuc3dlcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIF95bWluID0geW1pbjtcclxuICAgIF9kZWx0YXkgPSBkZWx0YXk7XHJcbiAgICBfaGFzaHNpemUgPSA0ICogc3FydE5zaXRlcztcclxuICAgIGluaXRpYWxpemUoKTtcclxuXHJcbiAgICByZXR1cm4gcHViO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBkZWYgPSByZXF1aXJlKCcuLi8uLi9qYW5pY2VrL2NvcmUnKS5kZWY7XHJcbnZhciBsck1vZHVsZSA9IHJlcXVpcmUoJy4vbHInKTtcclxuXHJcbnZhciBfcG9vbCA9IFtdOyAvLyBWZWN0b3I8SGFsZmVkZ2U+XHJcblxyXG52YXIgSGFsZmVkZ2UgPSBmdW5jdGlvbiAoZWRnZSwgbHIpIHtcclxuICAgIGVkZ2UgPSBkZWYoZWRnZSwgbnVsbCk7XHJcbiAgICBsciA9IGRlZihsciwgbnVsbCk7XHJcbiAgICB0aGlzLmluaXQoZWRnZSwgbHIpO1xyXG59O1xyXG5cclxuSGFsZmVkZ2UucHJvdG90eXBlID0ge1xyXG4gICAgZWRnZUxpc3RMZWZ0TmVpZ2hib3I6IG51bGwsXHJcbiAgICBlZGdlTGlzdFJpZ2h0TmVpZ2hib3I6IG51bGwsXHJcbiAgICBuZXh0SW5Qcmlvcml0eVF1ZXVlOiBudWxsLFxyXG4gICAgXHJcbiAgICBlZGdlOiBudWxsLFxyXG4gICAgbGVmdFJpZ2h0OiBudWxsLFxyXG4gICAgdmVydGV4OiBudWxsLFxyXG5cclxuICAgIC8vIHRoZSB2ZXJ0ZXgncyB5LWNvb3JkaW5hdGUgaW4gdGhlIHRyYW5zZm9ybWVkIFZvcm9ub2kgc3BhY2UgVipcclxuICAgIHlzdGFyOiAwLjAsXHJcblxyXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ0hhbGZlZGdlIChsZWZ0UmlnaHQ6ICcgKyB0aGlzLmxlZnRSaWdodCArICc7IHZlcnRleDogJyArIHRoaXMudmVydGV4ICsgJyknO1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWRnZUxpc3RMZWZ0TmVpZ2hib3IgIT09IG51bGwgfHwgdGhpcy5lZGdlTGlzdFJpZ2h0TmVpZ2hib3IgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gc3RpbGwgaW4gRWRnZUxpc3RcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5uZXh0SW5Qcmlvcml0eVF1ZXVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIHN0aWxsIGluIFByaW9yaXR5UXVldWVcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVkZ2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVmdFJpZ2h0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZlcnRleCA9IG51bGw7XHJcbiAgICAgICAgX3Bvb2wucHVzaCh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVhbGx5RGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWRnZUxpc3RMZWZ0TmVpZ2hib3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZWRnZUxpc3RSaWdodE5laWdoYm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLm5leHRJblByaW9yaXR5UXVldWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZWRnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sZWZ0UmlnaHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4ID0gbnVsbDtcclxuICAgICAgICBfcG9vbC5wdXNoKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBpc0xlZnRPZjogZnVuY3Rpb24gKHApIHtcclxuICAgICAgICB2YXIgdG9wU2l0ZTtcclxuICAgICAgICB2YXIgcmlnaHRPZlNpdGUsIGFib3ZlLCBmYXN0O1xyXG4gICAgICAgIHZhciBkeHAsIGR5cCwgZHhzLCB0MSwgdDIsIHQzLCB5bDtcclxuICAgICAgICBcclxuICAgICAgICB0b3BTaXRlID0gdGhpcy5lZGdlLnJpZ2h0U2l0ZTtcclxuICAgICAgICByaWdodE9mU2l0ZSA9IHAueCA+IHRvcFNpdGUueDtcclxuICAgICAgICBpZiAocmlnaHRPZlNpdGUgJiYgdGhpcy5sZWZ0UmlnaHQgPT09IGxyTW9kdWxlLkxFRlQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmlnaHRPZlNpdGUgJiYgdGhpcy5sZWZ0UmlnaHQgPT09IGxyTW9kdWxlLlJJR0hUKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRoaXMuZWRnZS5hID09PSAxLjApIHtcclxuICAgICAgICAgICAgZHlwID0gcC55IC0gdG9wU2l0ZS55O1xyXG4gICAgICAgICAgICBkeHAgPSBwLnggLSB0b3BTaXRlLng7XHJcbiAgICAgICAgICAgIGZhc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCghcmlnaHRPZlNpdGUgJiYgdGhpcy5lZGdlLmIgPCAwLjApIHx8IChyaWdodE9mU2l0ZSAmJiB0aGlzLmVkZ2UuYiA+PSAwLjApKSB7XHJcbiAgICAgICAgICAgICAgICBhYm92ZSA9IGR5cCA+PSAodGhpcy5lZGdlLmIgKiBkeHApO1xyXG4gICAgICAgICAgICAgICAgZmFzdCA9IGFib3ZlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWJvdmUgPSBwLnggKyBwLnkgKiB0aGlzLmVkZ2UuYiA+IHRoaXMuZWRnZS5jO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWRnZS5iIDwgMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSAhYWJvdmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFib3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFzdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFmYXN0KSB7XHJcbiAgICAgICAgICAgICAgICBkeHMgPSB0b3BTaXRlLnggLSB0aGlzLmVkZ2UubGVmdFNpdGUueDtcclxuICAgICAgICAgICAgICAgIGFib3ZlID0gdGhpcy5lZGdlLmIgKiAoZHhwICogZHhwIC0gZHlwICogZHlwKSA8IChkeHMgKiBkeXAgKiAoMS4wICsgMi4wICogZHhwIC8gZHhzICsgdGhpcy5lZGdlLmIgKiB0aGlzLmVkZ2UuYikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZWRnZS5iIDwgMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSAhYWJvdmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSAgeyAvKiB0aGlzLmVkZ2UuYiA9PSAxLjAgKi9cclxuICAgICAgICAgICAgeWwgPSB0aGlzLmVkZ2UuYyAtIHRoaXMuZWRnZS5hICogcC54O1xyXG4gICAgICAgICAgICB0MSA9IHAueSAtIHlsO1xyXG4gICAgICAgICAgICB0MiA9IHAueCAtIHRvcFNpdGUueDtcclxuICAgICAgICAgICAgdDMgPSB5bCAtIHRvcFNpdGUueTtcclxuICAgICAgICAgICAgYWJvdmUgPSAodDEgKiB0MSkgPiAodDIgKiB0MiArIHQzICogdDMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0UmlnaHQgPT09IGxyTW9kdWxlLkxFRlQgPyBhYm92ZSA6ICFhYm92ZTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKGVkZ2UsIGxyKSB7XHJcbiAgICAgICAgdGhpcy5lZGdlID0gZWRnZTtcclxuICAgICAgICB0aGlzLmxlZnRSaWdodCA9IGxyO1xyXG4gICAgICAgIHRoaXMubmV4dEluUHJpb3JpdHlRdWV1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXggPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKGVkZ2UsIGxyKSB7XHJcbiAgICBpZiAoX3Bvb2wubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBfcG9vbC5wb3AoKS5pbml0KGVkZ2UsIGxyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgSGFsZmVkZ2UoZWRnZSwgbHIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5jcmVhdGVEdW1teSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShudWxsLCBudWxsKTtcclxufTsiLCIvKiBqc2hpbnQgY2FtZWxjYXNlOmZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgZGVmID0gcmVxdWlyZSgnLi4vLi4vamFuaWNlay9jb3JlJykuZGVmO1xyXG52YXIgbGluZVNlZ21lbnRDb3JlID0gcmVxdWlyZSgnLi4vZ2VvbS9saW5lLXNlZ21lbnQnKS5jb3JlO1xyXG52YXIgbm9kZU1vZHVsZSA9IHJlcXVpcmUoJy4vbm9kZScpO1xyXG52YXIgcG9pbnRDb3JlID0gcmVxdWlyZSgnLi4vLi4vYXMzL3BvaW50LWNvcmUnKTtcclxuXHJcbmV4cG9ydHMuZmluZCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICBpZiAobm9kZS5wYXJlbnQgPT09IG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIHJvb3QgPSBleHBvcnRzLmZpbmQobm9kZS5wYXJlbnQpO1xyXG4gICAgICAgIC8vIHRoaXMgbGluZSBpcyBqdXN0IHRvIHNwZWVkIHVwIHN1YnNlcXVlbnQgZmluZHMgYnkga2VlcGluZyB0aGUgdHJlZSBkZXB0aCBsb3c6XHJcbiAgICAgICAgbm9kZS5wYXJlbnQgPSByb290O1xyXG4gICAgICAgIHJldHVybiByb290O1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiogIEtydXNrYWwncyBzcGFubmluZyB0cmVlIGFsZ29yaXRobSB3aXRoIHVuaW9uLWZpbmRcclxuICogU2tpZW5hOiBUaGUgQWxnb3JpdGhtIERlc2lnbiBNYW51YWwsIHAuIDE5NmZmXHJcbiAqIE5vdGU6IHRoZSBzaXRlcyBhcmUgaW1wbGllZDogdGhleSBjb25zaXN0IG9mIHRoZSBlbmQgcG9pbnRzIG9mIHRoZSBsaW5lIHNlZ21lbnRzXHJcbiovXHJcbmV4cG9ydHMua3J1c2thbCA9IGZ1bmN0aW9uIChsaW5lU2VnbWVudHMsIHR5cGUpIHtcclxuICAgIHR5cGUgPSBkZWYodHlwZSwgJ21pbmltdW0nKTtcclxuXHJcbiAgICB2YXIgbm9kZXMgPSB7fTsgLy8gRGljdGlvbmFyeTxOb2RlPlxyXG4gICAgdmFyIG1zdCA9IFtdOyAvLyBWZWN0b3I8TGluZVNlZ21lbnQ+XHJcbiAgICB2YXIgbm9kZVBvb2wgPSBbXTsgLy8gVmVjdG9yPE5vZGU+XHJcbiAgICBcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIC8vIG5vdGUgdGhhdCB0aGUgY29tcGFyZSBmdW5jdGlvbnMgYXJlIHRoZSByZXZlcnNlIG9mIHdoYXQgeW91J2QgZXhwZWN0XHJcbiAgICAgICAgLy8gYmVjYXVzZSAoc2VlIGJlbG93KSB3ZSB0cmF2ZXJzZSB0aGUgbGluZVNlZ21lbnRzIGluIHJldmVyc2Ugb3JkZXIgZm9yIHNwZWVkXHJcbiAgICBjYXNlICdtYXhpbXVtJzpcclxuICAgICAgICBsaW5lU2VnbWVudHMuc29ydChsaW5lU2VnbWVudENvcmUuY29tcGFyZUxlbmd0aHMpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgICBsaW5lU2VnbWVudHMuc29ydChsaW5lU2VnbWVudENvcmUuY29tcGFyZUxlbmd0aHNNYXgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpID0gbGluZVNlZ21lbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAvL2ZvciAodmFyIGk6aW50ID0gbGluZVNlZ21lbnRzLmxlbmd0aDsgLS1pID4gLTE7KVxyXG4gICAgd2hpbGUgKGkgPj0gMCkge1xyXG4gICAgICAgIHZhciBsaW5lU2VnbWVudCA9IGxpbmVTZWdtZW50c1tpXTtcclxuICAgICAgICBpLS07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG5vZGUwID0gbm9kZXNbcG9pbnRDb3JlLmhhc2gobGluZVNlZ21lbnQucDApXTtcclxuICAgICAgICB2YXIgcm9vdE9mU2V0MDtcclxuICAgICAgICBpZiAobm9kZTAgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgbm9kZTAgPSBub2RlUG9vbC5sZW5ndGggPiAwID8gbm9kZVBvb2wucG9wKCkgOiBub2RlTW9kdWxlLm1ha2UoKTtcclxuICAgICAgICAgICAgLy8gaW50aWFsaXplIHRoZSBub2RlOlxyXG4gICAgICAgICAgICByb290T2ZTZXQwID0gbm9kZTAucGFyZW50ID0gbm9kZTA7XHJcbiAgICAgICAgICAgIG5vZGUwLnRyZWVTaXplID0gMTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgbm9kZXNbcG9pbnRDb3JlLmhhc2gobGluZVNlZ21lbnQucDApXSA9IG5vZGUwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJvb3RPZlNldDAgPSBleHBvcnRzLmZpbmQobm9kZTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbm9kZTEgPSBub2Rlc1twb2ludENvcmUuaGFzaChsaW5lU2VnbWVudC5wMSldO1xyXG4gICAgICAgIHZhciByb290T2ZTZXQxO1xyXG4gICAgICAgIGlmIChub2RlMSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlMSA9IG5vZGVQb29sLmxlbmd0aCA+IDAgPyBub2RlUG9vbC5wb3AoKSA6IG5vZGVNb2R1bGUubWFrZSgpO1xyXG4gICAgICAgICAgICAvLyBpbnRpYWxpemUgdGhlIG5vZGU6XHJcbiAgICAgICAgICAgIHJvb3RPZlNldDEgPSBub2RlMS5wYXJlbnQgPSBub2RlMTtcclxuICAgICAgICAgICAgbm9kZTEudHJlZVNpemUgPSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBub2Rlc1twb2ludENvcmUuaGFzaChsaW5lU2VnbWVudC5wMSldID0gbm9kZTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcm9vdE9mU2V0MSA9IGV4cG9ydHMuZmluZChub2RlMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChyb290T2ZTZXQwICE9PSByb290T2ZTZXQxKSB7ICAgLy8gbm9kZXMgbm90IGluIHNhbWUgc2V0XHJcbiAgICAgICAgICAgIG1zdC5wdXNoKGxpbmVTZWdtZW50KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIG1lcmdlIHRoZSB0d28gc2V0czpcclxuICAgICAgICAgICAgdmFyIHRyZWVTaXplMCA9IHJvb3RPZlNldDAudHJlZVNpemU7XHJcbiAgICAgICAgICAgIHZhciB0cmVlU2l6ZTEgPSByb290T2ZTZXQxLnRyZWVTaXplO1xyXG4gICAgICAgICAgICBpZiAodHJlZVNpemUwID49IHRyZWVTaXplMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0MCBhYnNvcmJzIHNldDE6XHJcbiAgICAgICAgICAgICAgICByb290T2ZTZXQxLnBhcmVudCA9IHJvb3RPZlNldDA7XHJcbiAgICAgICAgICAgICAgICByb290T2ZTZXQwLnRyZWVTaXplICs9IHRyZWVTaXplMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNldDEgYWJzb3JicyBzZXQwOlxyXG4gICAgICAgICAgICAgICAgcm9vdE9mU2V0MC5wYXJlbnQgPSByb290T2ZTZXQxO1xyXG4gICAgICAgICAgICAgICAgcm9vdE9mU2V0MS50cmVlU2l6ZSArPSB0cmVlU2l6ZTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIF8obm9kZXMpLmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICBub2RlUG9vbC5wdXNoKG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiBtc3Q7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBMRUZUOiAnbGVmdCcsXHJcbiAgICBSSUdIVDogJ3JpZ2h0JyxcclxuXHJcbiAgICBvdGhlcjogZnVuY3Rpb24gKGxlZnRSaWdodCkge1xyXG4gICAgICAgIHJldHVybiBsZWZ0UmlnaHQgPT09IHRoaXMuTEVGVCA/IHRoaXMuUklHSFQgOiB0aGlzLkxFRlQ7XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0cy5tYWtlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYXJlbnQ6IG51bGwsXHJcbiAgICAgICAgdHJlZVNpemU6IDBcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLnBvb2wgPSBbXTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgY2lyY2xlID0gcmVxdWlyZSgnLi4vZ2VvbS9jaXJjbGUnKTtcclxudmFyIGRlZiA9IHJlcXVpcmUoJy4uLy4uL2phbmljZWsvY29yZScpLmRlZjtcclxudmFyIHJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uLy4uL2FzMy9yZWN0YW5nbGUnKTtcclxudmFyIHNpdGVNb2R1bGUgPSByZXF1aXJlKCcuL3NpdGUnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIF9zaXRlcyA9IFtdOyAvLyBWZWN0b3I8U2l0ZT5cclxuICAgIHZhciBfY3VycmVudEluZGV4ID0gMDtcclxuICAgIHZhciBfc29ydGVkID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIHB1YiA9IHt9O1xyXG5cclxuICAgIHB1Yi5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc2l0ZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgXyhfc2l0ZXMpLmVhY2goZnVuY3Rpb24gKHNpdGUpIHtcclxuICAgICAgICAgICAgICAgIHNpdGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgX3NpdGVzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5wdXNoID0gZnVuY3Rpb24gKHNpdGUpIHtcclxuICAgICAgICBfc29ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF9zaXRlcy5wdXNoKHNpdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwdWIsIHtcclxuICAgICAgICAnbGVuZ3RoJzoge2dldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3NpdGVzLmxlbmd0aDsgfX1cclxuICAgIH0pO1xyXG5cclxuICAgIHB1Yi5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfc29ydGVkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aHJvdyAnU2l0ZUxpc3Q6Om5leHQoKTogIHNpdGVzIGhhdmUgbm90IGJlZW4gc29ydGVkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9jdXJyZW50SW5kZXggPCBfc2l0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfc2l0ZXNbX2N1cnJlbnRJbmRleCsrXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5nZXRTaXRlc0JvdW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoX3NvcnRlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgc2l0ZU1vZHVsZS5zb3J0U2l0ZXMoX3NpdGVzKTtcclxuICAgICAgICAgICAgX2N1cnJlbnRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIF9zb3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgeG1pbiwgeG1heCwgeW1pbiwgeW1heDtcclxuICAgICAgICBpZiAoX3NpdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB4bWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgIHhtYXggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgXyhfc2l0ZXMpLmVhY2goZnVuY3Rpb24gKHNpdGUpIHtcclxuICAgICAgICAgICAgaWYgKHNpdGUueCA8IHhtaW4pIHtcclxuICAgICAgICAgICAgICAgIHhtaW4gPSBzaXRlLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNpdGUueCA+IHhtYXgpIHtcclxuICAgICAgICAgICAgICAgIHhtYXggPSBzaXRlLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBoZXJlJ3Mgd2hlcmUgd2UgYXNzdW1lIHRoYXQgdGhlIHNpdGVzIGhhdmUgYmVlbiBzb3J0ZWQgb24geTpcclxuICAgICAgICB5bWluID0gX3NpdGVzWzBdLnk7XHJcbiAgICAgICAgeW1heCA9IF9zaXRlc1tfc2l0ZXMubGVuZ3RoIC0gMV0ueTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVjdGFuZ2xlKHhtaW4sIHltaW4sIHhtYXggLSB4bWluLCB5bWF4IC0geW1pbik7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5zaXRlQ29sb3JzID0gZnVuY3Rpb24gKHJlZmVyZW5jZUltYWdlKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlSW1hZ2UgPSBkZWYocmVmZXJlbmNlSW1hZ2UsIG51bGwpO1xyXG5cclxuICAgICAgICB2YXIgY29sb3JzID0gW107IC8vIFZlY3RvcjxJbnQ+XHJcbiAgICAgICAgXyhfc2l0ZXMpLmVhY2goZnVuY3Rpb24gKHNpdGUpIHtcclxuICAgICAgICAgICAgY29sb3JzLnB1c2gocmVmZXJlbmNlSW1hZ2UgIT09IG51bGwgPyByZWZlcmVuY2VJbWFnZS5nZXRQaXhlbChzaXRlLngsIHNpdGUueSkgOiBzaXRlLmNvbG9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29sb3JzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWIuc2l0ZUNvb3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29vcmRzID0gW107IC8vIFZlY3RvcjxQb2ludD5cclxuICAgICAgICBfKF9zaXRlcykuZWFjaChmdW5jdGlvbiAoc2l0ZSkge1xyXG4gICAgICAgICAgICBjb29yZHMucHVzaChzaXRlLmNvb3JkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29vcmRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHJldHVybiB0aGUgbGFyZ2VzdCBjaXJjbGUgY2VudGVyZWQgYXQgZWFjaCBzaXRlIHRoYXQgZml0cyBpbiBpdHMgcmVnaW9uO1xyXG4gICAgICogaWYgdGhlIHJlZ2lvbiBpcyBpbmZpbml0ZSwgcmV0dXJuIGEgY2lyY2xlIG9mIHJhZGl1cyAwLlxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHB1Yi5jaXJjbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaXJjbGVzID0gW107IC8vIFZlY3RvcjxDaXJjbGU+XHJcbiAgICAgICAgXyhfc2l0ZXMpLmVhY2goZnVuY3Rpb24gKHNpdGUpIHtcclxuICAgICAgICAgICAgLy92YXIgcmFkaXVzOk51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIHZhciBuZWFyZXN0RWRnZSA9IHNpdGUubmVhcmVzdEVkZ2UoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSAoIW5lYXJlc3RFZGdlLmlzUGFydE9mQ29udmV4SHVsbCgpKSA/IChuZWFyZXN0RWRnZS5zaXRlc0Rpc3RhbmNlKCkgKiAwLjUpOiAwO1xyXG4gICAgICAgICAgICAvLyFuZWFyZXN0RWRnZS5pc1BhcnRPZkNvbnZleEh1bGwoKSAmJiAocmFkaXVzID0gbmVhcmVzdEVkZ2Uuc2l0ZXNEaXN0YW5jZSgpICogMC41KTtcclxuICAgICAgICAgICAgY2lyY2xlcy5wdXNoKGNpcmNsZShzaXRlLngsIHNpdGUueSwgcmFkaXVzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNpcmNsZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5yZWdpb25zID0gZnVuY3Rpb24gKHBsb3RCb3VuZHMpIHtcclxuICAgICAgICB2YXIgcmVnaW9ucyA9IFtdOyAvLyBWZWN0b3I8VmVjdG9yPFBvaW50Pj5cclxuICAgICAgICBfKF9zaXRlcykuZWFjaChmdW5jdGlvbiAoc2l0ZSkge1xyXG4gICAgICAgICAgICByZWdpb25zLnB1c2goc2l0ZS5yZWdpb24ocGxvdEJvdW5kcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZWdpb25zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHByb3hpbWl0eU1hcCBhIEJpdG1hcERhdGEgd2hvc2UgcmVnaW9ucyBhcmUgZmlsbGVkIHdpdGggdGhlIHNpdGUgaW5kZXggdmFsdWVzOyBzZWUgUGxhbmVQb2ludHNDYW52YXM6OmZpbGxSZWdpb25zKClcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICogQHJldHVybiBjb29yZGluYXRlcyBvZiBuZWFyZXN0IFNpdGUgdG8gKHgsIHkpXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgcHViLm5lYXJlc3RTaXRlUG9pbnQgPSBmdW5jdGlvbiAocHJveGltaXR5TWFwLCB4LCB5KSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gcHJveGltaXR5TWFwLmdldFBpeGVsKHgsIHkpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IF9zaXRlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3NpdGVzW2luZGV4XS5jb29yZDtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHB1YjtcclxufTsiLCIvKiBqc2hpbnQgYml0d2lzZTpmYWxzZSwgZXMzOmZhbHNlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgYm91bmRzQ2hlY2sgPSByZXF1aXJlKCcuL2JvdW5kcy1jaGVjaycpO1xyXG52YXIgY3JpdGVyaW9uID0gcmVxdWlyZSgnLi9jcml0ZXJpb24nKTtcclxudmFyIGRlZiA9IHJlcXVpcmUoJy4uLy4uL2phbmljZWsvY29yZScpLmRlZjtcclxudmFyIGVkZ2VNb2R1bGUgPSByZXF1aXJlKCcuL2VkZ2UnKTtcclxudmFyIGVkZ2VSZW9yZGVyZXJNb2R1bGUgPSByZXF1aXJlKCcuL2VkZ2UtcmVvcmRlcmVyJyk7XHJcbnZhciBsciA9IHJlcXVpcmUoJy4vbHInKTtcclxudmFyIHBvaW50Q29yZSA9IHJlcXVpcmUoJy4uLy4uL2FzMy9wb2ludC1jb3JlJyk7XHJcbnZhciBwb2x5Z29uID0gcmVxdWlyZSgnLi4vZ2VvbS9wb2x5Z29uJyk7XHJcbnZhciByZWN0ID0gcmVxdWlyZSgnLi4vLi4vYXMzL3JlY3RhbmdsZScpLmNvcmU7XHJcbnZhciB2b3Jvbm9pTW9kdWxlID0gcmVxdWlyZSgnLi92b3Jvbm9pJyk7XHJcbnZhciB3aW5kaW5nID0gcmVxdWlyZSgnLi4vZ2VvbS93aW5kaW5nJyk7XHJcblxyXG52YXIgX3Bvb2wgPSBbXTsgLy8gVmVjdG9yPFNpdGU+XHJcblxyXG5cclxudmFyIEVQU0lMT04gPSAwLjAwNTtcclxuZnVuY3Rpb24gY2xvc2VFbm91Z2gocDAsIHAxKSB7XHJcbiAgICByZXR1cm4gcG9pbnRDb3JlLmRpc3RhbmNlKHAwLCBwMSkgPCBFUFNJTE9OO1xyXG59XHJcblxyXG52YXIgU2l0ZSA9IGZ1bmN0aW9uIChwLCBpbmRleCwgd2VpZ2h0LCBjb2xvcikge1xyXG4gICAgdGhpcy5pbml0KHAsIGluZGV4LCB3ZWlnaHQsIGNvbG9yKTtcclxufTtcclxuXHJcblNpdGUucHJvdG90eXBlID0ge1xyXG4gICAgX2Nvb3JkOiBudWxsLFxyXG4gICAgZ2V0IGNvb3JkKCkgeyByZXR1cm4gdGhpcy5fY29vcmQ7IH0sXHJcbiAgICBjb2xvcjogMCxcclxuICAgIHdlaWdodDogMC4wLFxyXG4gICAgX3NpdGVJbmRleDogMCxcclxuXHJcbiAgICAvLyB0aGUgZWRnZXMgdGhhdCBkZWZpbmUgdGhpcyBTaXRlJ3MgVm9yb25vaSByZWdpb246XHJcbiAgICBfZWRnZXM6IG51bGwsIC8vIFZlY3RvcjxFZGdlPlxyXG4gICAgZ2V0IGVkZ2VzKCkgeyByZXR1cm4gdGhpcy5fZWRnZXM7IH0sXHJcblxyXG4gICAgLy8gd2hpY2ggZW5kIG9mIGVhY2ggZWRnZSBob29rcyB1cCB3aXRoIHRoZSBwcmV2aW91cyBlZGdlIGluIF9lZGdlczpcclxuICAgIF9lZGdlT3JpZW50YXRpb25zOiBudWxsLCAvLyBWZWN0b3I8TFI+O1xyXG4gICAgLy8gb3JkZXJlZCBsaXN0IG9mIHBvaW50cyB0aGF0IGRlZmluZSB0aGUgcmVnaW9uIGNsaXBwZWQgdG8gYm91bmRzOlxyXG4gICAgX3JlZ2lvbjogbnVsbCwgLy8gVmVjdG9yPFBvaW50PlxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uIChwLCBpbmRleCwgd2VpZ2h0LCBjb2xvcikge1xyXG4gICAgICAgIHRoaXMuX2Nvb3JkID0gcDtcclxuICAgICAgICB0aGlzLl9zaXRlSW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLndlaWdodCA9IHdlaWdodDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5fZWRnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yZWdpb24gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnU2l0ZSAnICsgdGhpcy5fc2l0ZUluZGV4ICsgJzogJyArIFN0cmluZyh0aGlzLmNvb3JkKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Nvb3JkID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jbGVhcigpO1xyXG4gICAgICAgIF9wb29sLnB1c2godGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lZGdlcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lZGdlcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9lZGdlT3JpZW50YXRpb25zICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VkZ2VPcmllbnRhdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcmVnaW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBhZGRFZGdlOiBmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgIHRoaXMuX2VkZ2VzLnB1c2goZWRnZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIG5lYXJlc3RFZGdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZWRnZXMuc29ydChlZGdlTW9kdWxlLmNvbXBhcmVTaXRlc0Rpc3RhbmNlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkZ2VzWzBdO1xyXG4gICAgfSxcclxuXHJcbiAgICBuZWlnaGJvclNpdGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VkZ2VzID09PSBudWxsIHx8IHRoaXMuX2VkZ2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9lZGdlT3JpZW50YXRpb25zID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlb3JkZXJFZGdlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGlzdCA9IFtdOyAvLyBWZWN0b3I8U2l0ZT5cclxuXHJcbiAgICAgICAgXy5lYWNoKHRoaXMuX2VkZ2VzLCBmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgICAgICBsaXN0LnB1c2godGhpcy5fbmVpZ2hib3JTaXRlKGVkZ2UpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxpc3Q7XHJcbiAgICB9LFxyXG5cclxuICAgIF9uZWlnaGJvclNpdGU6IGZ1bmN0aW9uIChlZGdlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgPT09IGVkZ2UubGVmdFNpdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVkZ2UucmlnaHRTaXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcyA9PT0gZWRnZS5yaWdodFNpdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVkZ2UubGVmdFNpdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWdpb246IGZ1bmN0aW9uIChjbGlwcGluZ0JvdW5kcykge1xyXG4gICAgICAgIGlmICh0aGlzLl9lZGdlcyA9PT0gbnVsbCB8fCB0aGlzLl9lZGdlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZWRnZU9yaWVudGF0aW9ucyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW9yZGVyRWRnZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVnaW9uID0gdGhpcy5fY2xpcFRvQm91bmRzKGNsaXBwaW5nQm91bmRzKTtcclxuICAgICAgICAgICAgaWYgKChwb2x5Z29uKHRoaXMuX3JlZ2lvbikpLndpbmRpbmcoKSA9PT0gd2luZGluZy5DTE9DS1dJU0UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lvbi5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lvbjtcclxuICAgIH0sXHJcblxyXG4gICAgX3Jlb3JkZXJFZGdlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZW9yZGVyZXIgPSBlZGdlUmVvcmRlcmVyTW9kdWxlKHRoaXMuX2VkZ2VzLCBjcml0ZXJpb24udmVydGV4KTtcclxuICAgICAgICB0aGlzLl9lZGdlcyA9IHJlb3JkZXJlci5lZGdlcztcclxuICAgICAgICB0aGlzLl9lZGdlT3JpZW50YXRpb25zID0gcmVvcmRlcmVyLmVkZ2VPcmllbnRhdGlvbnM7XHJcbiAgICAgICAgcmVvcmRlcmVyLmRpc3Bvc2UoKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NsaXBUb0JvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTsgLy8gVmVjdG9yPFBvaW50PlxyXG4gICAgICAgIHZhciBuID0gdGhpcy5fZWRnZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgZWRnZSA9IG51bGw7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBuICYmICh0aGlzLl9lZGdlc1tpXS52aXNpYmxlID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoaSA9PT0gbikge1xyXG4gICAgICAgICAgICAvLyBubyBlZGdlcyB2aXNpYmxlXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWRnZSA9IHRoaXMuX2VkZ2VzW2ldO1xyXG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMuX2VkZ2VPcmllbnRhdGlvbnNbaV07XHJcbiAgICAgICAgcG9pbnRzLnB1c2goZWRnZS5jbGlwcGVkRW5kc1tvcmllbnRhdGlvbl0pO1xyXG4gICAgICAgIHBvaW50cy5wdXNoKGVkZ2UuY2xpcHBlZEVuZHNbbHIub3RoZXIob3JpZW50YXRpb24pXSk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGogPSAoaSArIDEpOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgIGVkZ2UgPSB0aGlzLl9lZGdlc1tqXTtcclxuICAgICAgICAgICAgaWYgKGVkZ2UudmlzaWJsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3QocG9pbnRzLCBqLCBib3VuZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbG9zZSB1cCB0aGUgcG9seWdvbiBieSBhZGRpbmcgYW5vdGhlciBjb3JuZXIgcG9pbnQgb2YgdGhlIGJvdW5kcyBpZiBuZWVkZWQ6XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdChwb2ludHMsIGksIGJvdW5kcywgdHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgIH0sXHJcblxyXG4gICAgX2Nvbm5lY3Q6IGZ1bmN0aW9uIChwb2ludHMsIGosIGJvdW5kcywgY2xvc2luZ1VwKSB7XHJcbiAgICAgICAgY2xvc2luZ1VwID0gZGVmKGNsb3NpbmdVcCwgZmFsc2UpO1xyXG5cclxuICAgICAgICB2YXIgcmlnaHRQb2ludCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIG5ld0VkZ2UgPSB0aGlzLl9lZGdlc1tqXTtcclxuICAgICAgICB2YXIgbmV3T3JpZW50YXRpb24gPSB0aGlzLl9lZGdlT3JpZW50YXRpb25zW2pdO1xyXG4gICAgICAgIC8vIHRoZSBwb2ludCB0aGF0ICBtdXN0IGJlIGNvbm5lY3RlZCB0byByaWdodFBvaW50OlxyXG4gICAgICAgIHZhciBuZXdQb2ludCA9IG5ld0VkZ2UuY2xpcHBlZEVuZHNbbmV3T3JpZW50YXRpb25dO1xyXG4gICAgICAgIGlmICghY2xvc2VFbm91Z2gocmlnaHRQb2ludCwgbmV3UG9pbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBwb2ludHMgZG8gbm90IGNvaW5jaWRlLCBzbyB0aGV5IG11c3QgaGF2ZSBiZWVuIGNsaXBwZWQgYXQgdGhlIGJvdW5kcztcclxuICAgICAgICAgICAgLy8gc2VlIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIGJvcmRlciBvZiB0aGUgYm91bmRzOlxyXG4gICAgICAgICAgICBpZiAocmlnaHRQb2ludC54ICE9PSBuZXdQb2ludC54ICYmIHJpZ2h0UG9pbnQueSAhPT0gbmV3UG9pbnQueSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhleSBhcmUgb24gZGlmZmVyZW50IGJvcmRlcnMgb2YgdGhlIGJvdW5kcztcclxuICAgICAgICAgICAgICAgIC8vIGluc2VydCBvbmUgb3IgdHdvIGNvcm5lcnMgb2YgYm91bmRzIGFzIG5lZWRlZCB0byBob29rIHRoZW0gdXA6XHJcbiAgICAgICAgICAgICAgICAvLyAoTk9URSB0aGlzIHdpbGwgbm90IGJlIGNvcnJlY3QgaWYgdGhlIHJlZ2lvbiBzaG91bGQgdGFrZSB1cCBtb3JlIHRoYW5cclxuICAgICAgICAgICAgICAgIC8vIGhhbGYgb2YgdGhlIGJvdW5kcyByZWN0LCBmb3IgdGhlbiB3ZSB3aWxsIGhhdmUgZ29uZSB0aGUgd3Jvbmcgd2F5XHJcbiAgICAgICAgICAgICAgICAvLyBhcm91bmQgdGhlIGJvdW5kcyBhbmQgaW5jbHVkZWQgdGhlIHNtYWxsZXIgcGFydCByYXRoZXIgdGhhbiB0aGUgbGFyZ2VyKVxyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q2hlY2sgPSBib3VuZHNDaGVjay5jaGVjayhyaWdodFBvaW50LCBib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoZWNrID0gYm91bmRzQ2hlY2suY2hlY2sobmV3UG9pbnQsIGJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHgsIHB5O1xyXG4gICAgICAgICAgICAgICAgaWYgKChyaWdodENoZWNrICYgYm91bmRzQ2hlY2suUklHSFQpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHggPSByZWN0KGJvdW5kcykucmlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG5ld0NoZWNrICYgYm91bmRzQ2hlY2suQk9UVE9NKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBweSA9IHJlY3QoYm91bmRzKS5ib3R0b20oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe3g6IHB4LCB5OiBweX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgobmV3Q2hlY2sgJiBib3VuZHNDaGVjay5UT1ApICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB5ID0gcmVjdChib3VuZHMpLnRvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7eDogcHgsIHk6IHB5fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChuZXdDaGVjayAmIGJvdW5kc0NoZWNrLkxFRlQpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFBvaW50LnkgLSBib3VuZHMueSArIG5ld1BvaW50LnkgLSBib3VuZHMueSA8IGJvdW5kcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5ID0gcmVjdChib3VuZHMpLnRvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHkgPSByZWN0KGJvdW5kcykuYm90dG9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe3g6IHB4LCB5OiBweX0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7eDogcmVjdChib3VuZHMpLmxlZnQoKSwgeTogcHl9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChyaWdodENoZWNrICYgYm91bmRzQ2hlY2suTEVGVCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBweCA9IHJlY3QoYm91bmRzKS5sZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuZXdDaGVjayAmIGJvdW5kc0NoZWNrLkJPVFRPTSkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHkgPSByZWN0KGJvdW5kcykuYm90dG9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHt4OiBweCwgeTogcHl9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChuZXdDaGVjayAmIGJvdW5kc0NoZWNrLlRPUCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHkgPSByZWN0KGJvdW5kcykudG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHt4OiBweCwgeTogcHl9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChuZXdDaGVjayAmIGJvdW5kc0NoZWNrLlJJR0hUKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRQb2ludC55IC0gYm91bmRzLnkgKyBuZXdQb2ludC55IC0gYm91bmRzLnkgPCBib3VuZHMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweSA9IHJlY3QoYm91bmRzKS50b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5ID0gcmVjdChib3VuZHMpLmJvdHRvbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHt4OiBweCwgeTogcHl9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe3g6IHJlY3QoYm91bmRzKS5yaWdodCgpLCB5OiBweX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJpZ2h0Q2hlY2sgJiBib3VuZHNDaGVjay5UT1ApICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHkgPSByZWN0KGJvdW5kcykudG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChuZXdDaGVjayAmIGJvdW5kc0NoZWNrLlJJR0hUKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBweCA9IHJlY3QoYm91bmRzKS5yaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7eDogcHgsIHk6IHB5fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgobmV3Q2hlY2sgJiBib3VuZHNDaGVjay5MRUZUKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBweCA9IHJlY3QoYm91bmRzKS5sZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHt4OiBweCwgeTogcHl9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChuZXdDaGVjayAmIGJvdW5kc0NoZWNrLkJPVFRPTSkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0UG9pbnQueCAtIGJvdW5kcy54ICsgbmV3UG9pbnQueCAtIGJvdW5kcy54IDwgYm91bmRzLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweCA9IHJlY3QoYm91bmRzKS5sZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweCA9IHJlY3QoYm91bmRzKS5yaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHt4OiBweCwgeTogcHl9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe3g6IHB4LCB5OiByZWN0KGJvdW5kcykuYm90dG9tKCl9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChyaWdodENoZWNrICYgYm91bmRzQ2hlY2suQk9UVE9NKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB5ID0gcmVjdChib3VuZHMpLmJvdHRvbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobmV3Q2hlY2sgJiBib3VuZHNDaGVjay5SSUdIVCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHggPSByZWN0KGJvdW5kcykucmlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goe3g6IHB4LCB5OiBweX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG5ld0NoZWNrICYgYm91bmRzQ2hlY2suTEVGVCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHggPSByZWN0KGJvdW5kcykubGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7eDogcHgsIHk6IHB5fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgobmV3Q2hlY2sgJiBib3VuZHNDaGVjay5UT1ApICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodFBvaW50LnggLSBib3VuZHMueCArIG5ld1BvaW50LnggLSBib3VuZHMueCA8IGJvdW5kcy53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHggPSByZWN0KGJvdW5kcykubGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHggPSByZWN0KGJvdW5kcykucmlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh7eDogcHgsIHk6IHB5fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHt4OiBweCwgeTogcmVjdChib3VuZHMpLnRvcCgpfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjbG9zaW5nVXApIHtcclxuICAgICAgICAgICAgICAgIC8vIG5ld0VkZ2UncyBlbmRzIGhhdmUgYWxyZWFkeSBiZWVuIGFkZGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gobmV3UG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3UmlnaHRQb2ludCA9IG5ld0VkZ2UuY2xpcHBlZEVuZHNbbHIub3RoZXIobmV3T3JpZW50YXRpb24pXTtcclxuICAgICAgICBpZiAoIWNsb3NlRW5vdWdoKHBvaW50c1swXSwgbmV3UmlnaHRQb2ludCkpIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gobmV3UmlnaHRQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgeCgpIHsgcmV0dXJuIHRoaXMuX2Nvb3JkLng7IH0sXHJcblxyXG4gICAgZ2V0IHkoKSB7IHJldHVybiB0aGlzLl9jb29yZC55OyB9LFxyXG5cclxuICAgIGRpc3Q6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50Q29yZS5kaXN0YW5jZShwLmNvb3JkLCB0aGlzLmNvb3JkKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHAsIGluZGV4LCB3ZWlnaHQsIGNvbG9yKSB7XHJcbiAgICBpZiAoX3Bvb2wubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiBfcG9vbC5wb3AoKS5pbml0KHAsIGluZGV4LCB3ZWlnaHQsIGNvbG9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaXRlKHAsIGluZGV4LCB3ZWlnaHQsIGNvbG9yKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBzb3J0IHNpdGVzIG9uIHksIHRoZW4geCwgY29vcmRcclxuICogYWxzbyBjaGFuZ2UgZWFjaCBzaXRlJ3MgX3NpdGVJbmRleCB0byBtYXRjaCBpdHMgbmV3IHBvc2l0aW9uIGluIHRoZSBsaXN0XHJcbiAqIHNvIHRoZSBfc2l0ZUluZGV4IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBzaXRlIGZvciBuZWFyZXN0LW5laWdoYm9yIHF1ZXJpZXNcclxuICogXHJcbiAqIGhhaGEgXCJhbHNvXCIgLSBtZWFucyBtb3JlIHRoYW4gb25lIHJlc3BvbnNpYmlsaXR5Li4uXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0cy5zb3J0U2l0ZXMgPSBmdW5jdGlvbiAoc2l0ZXMpIHtcclxuICAgIHNpdGVzLnNvcnQodm9yb25vaU1vZHVsZS5jb21wYXJlU2l0ZUJ5WVRoZW5YKTtcclxuICAgIF8oc2l0ZXMpLmVhY2goZnVuY3Rpb24gKHNpdGUsIGkpIHtcclxuICAgICAgICBzaXRlc1tpXS5fc2l0ZUluZGV4ID0gaTtcclxuICAgIH0pO1xyXG59OyIsIi8qIGpzaGludCBlczM6ZmFsc2UgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfcG9vbCA9IFtdO1xyXG52YXIgX252ZXJ0aWNlcyA9IDA7XHJcblxyXG52YXIgVmVydGV4ID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgIHRoaXMuaW5pdCh4LCB5KTtcclxufTtcclxuXHJcblZlcnRleC5wcm90b3R5cGUgPSB7XHJcbiAgICBfY29vcmQ6IG51bGwsXHJcblxyXG4gICAgZ2V0IGNvb3JkKCkgeyByZXR1cm4gdGhpcy5fY29vcmQ7IH0sXHJcblxyXG4gICAgdmVydGV4SW5kZXg6IDAsXHJcblxyXG4gICAgaW5pdDogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICB0aGlzLl9jb29yZCA9IHt4OiB4LCB5OiB5fTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2Nvb3JkID0gbnVsbDtcclxuICAgICAgICBfcG9vbC5wdXNoKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRJbmRleDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4SW5kZXggPSBfbnZlcnRpY2VzKys7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdWZXJ0ZXggKCcgKyB0aGlzLnZlcnRleEluZGV4ICsgJyknO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29vcmQueDtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkLnk7XHJcbiAgICB9XHJcblxyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlKHgsIHkpIHtcclxuICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLlZFUlRFWF9BVF9JTkZJTklUWTtcclxuICAgIH1cclxuICAgIGlmIChfcG9vbC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcmV0dXJuIF9wb29sLnBvcCgpLmluaXQoeCwgeSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4KHgsIHkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnRzLlZFUlRFWF9BVF9JTkZJTklUWSA9IG5ldyBWZXJ0ZXgoTmFOLCBOYU4pO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIG1ha2UgYSBWZXJ0ZXhcclxuICogXHJcbiAqIEBwYXJhbSBoYWxmZWRnZTBcclxuICogQHBhcmFtIGhhbGZlZGdlMVxyXG4gKiBAcmV0dXJuIFxyXG4gKiBcclxuICovXHJcbmV4cG9ydHMuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKGhhbGZlZGdlMCwgaGFsZmVkZ2UxKSB7XHJcbiAgICB2YXIgdm9yb25vaSA9IHJlcXVpcmUoJy4vdm9yb25vaScpO1xyXG4gICAgdmFyIGxyID0gcmVxdWlyZSgnLi9scicpO1xyXG5cclxuICAgIHZhciBlZGdlMCwgZWRnZTEsIGVkZ2U7XHJcbiAgICB2YXIgaGFsZmVkZ2U7XHJcbiAgICB2YXIgZGV0ZXJtaW5hbnQsIGludGVyc2VjdGlvblgsIGludGVyc2VjdGlvblk7XHJcbiAgICB2YXIgcmlnaHRPZlNpdGU7XHJcblxyXG4gICAgZWRnZTAgPSBoYWxmZWRnZTAuZWRnZTtcclxuICAgIGVkZ2UxID0gaGFsZmVkZ2UxLmVkZ2U7XHJcbiAgICBpZiAoZWRnZTAgPT09IG51bGwgfHwgZWRnZTEgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlmIChlZGdlMC5yaWdodFNpdGUgPT09IGVkZ2UxLnJpZ2h0U2l0ZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGRldGVybWluYW50ID0gZWRnZTAuYSAqIGVkZ2UxLmIgLSBlZGdlMC5iICogZWRnZTEuYTtcclxuICAgIGlmICgtMS4wZS0xMCA8IGRldGVybWluYW50ICYmIGRldGVybWluYW50IDwgMS4wZS0xMCkge1xyXG4gICAgICAgIC8vIHRoZSBlZGdlcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcnNlY3Rpb25YID0gKGVkZ2UwLmMgKiBlZGdlMS5iIC0gZWRnZTEuYyAqIGVkZ2UwLmIpIC8gZGV0ZXJtaW5hbnQ7XHJcbiAgICBpbnRlcnNlY3Rpb25ZID0gKGVkZ2UxLmMgKiBlZGdlMC5hIC0gZWRnZTAuYyAqIGVkZ2UxLmEpIC8gZGV0ZXJtaW5hbnQ7XHJcblxyXG4gICAgLy9pZiAoVm9yb25vaS5pc0luZlNpdGUoZWRnZTAucmlnaHRTaXRlLCBlZGdlMS5yaWdodFNpdGUpKSAgLy9IeERlbGF1bmF5XHJcbiAgICBpZiAodm9yb25vaS5jb21wYXJlU2l0ZUJ5WVRoZW5YKGVkZ2UwLnJpZ2h0U2l0ZSwgZWRnZTEucmlnaHRTaXRlKSA8IDApIHtcclxuICAgICAgICBoYWxmZWRnZSA9IGhhbGZlZGdlMDtcclxuICAgICAgICBlZGdlID0gZWRnZTA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhhbGZlZGdlID0gaGFsZmVkZ2UxO1xyXG4gICAgICAgIGVkZ2UgPSBlZGdlMTtcclxuICAgIH1cclxuICAgIHJpZ2h0T2ZTaXRlID0gaW50ZXJzZWN0aW9uWCA+PSBlZGdlLnJpZ2h0U2l0ZS54O1xyXG4gICAgaWYgKChyaWdodE9mU2l0ZSAmJiBoYWxmZWRnZS5sZWZ0UmlnaHQgPT09IGxyLkxFRlQpIHx8XHJcbiAgICAgICAgKCFyaWdodE9mU2l0ZSAmJiBoYWxmZWRnZS5sZWZ0UmlnaHQgPT09IGxyLlJJR0hUKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZShpbnRlcnNlY3Rpb25YLCBpbnRlcnNlY3Rpb25ZKTtcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgY3JpdGVyaW9uID0gcmVxdWlyZSgnLi9jcml0ZXJpb24nKTtcclxudmFyIGNvcmUgPSByZXF1aXJlKCcuLi8uLi9qYW5pY2VrL2NvcmUnKTtcclxudmFyIGRlZiA9IHJlcXVpcmUoJy4uLy4uL2phbmljZWsvY29yZScpLmRlZjtcclxudmFyIGRlbGF1bmF5TW9kdWxlID0gcmVxdWlyZSgnLi9kZWxhdW5heScpO1xyXG52YXIgZWRnZUxpc3RNb2R1bGUgPSByZXF1aXJlKCcuL2VkZ2UtbGlzdCcpO1xyXG52YXIgZWRnZU1vZHVsZSA9IHJlcXVpcmUoJy4vZWRnZScpO1xyXG52YXIgZWRnZVJlb3JkZXJlck1vZHVsZSA9IHJlcXVpcmUoJy4vZWRnZS1yZW9yZGVyZXInKTtcclxudmFyIGhhbGZFZGdlTW9kdWxlID0gcmVxdWlyZSgnLi9oYWxmZWRnZScpO1xyXG52YXIgaGFsZmVkZ2VQcmlvcml0eVF1ZXVlID0gcmVxdWlyZSgnLi9oYWxmZWRnZS1wcmlvcml0eS1xdWV1ZScpO1xyXG52YXIga3J1c2thbE1vZHVsZSA9IHJlcXVpcmUoJy4va3J1c2thbCcpO1xyXG52YXIgbHIgPSByZXF1aXJlKCcuL2xyJyk7XHJcbnZhciBwb2ludENvcmUgPSByZXF1aXJlKCcuLi8uLi9hczMvcG9pbnQtY29yZScpO1xyXG52YXIgcHJuZ01vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL3BvbHlnb25hbC9wbS1wcm5nJyk7XHJcbnZhciBzaXRlTGlzdE1vZHVsZSA9IHJlcXVpcmUoJy4vc2l0ZS1saXN0Jyk7XHJcbnZhciBzaXRlTW9kdWxlID0gcmVxdWlyZSgnLi9zaXRlJyk7XHJcbnZhciB2ZXJ0ZXhNb2R1bGUgPSByZXF1aXJlKCcuL3ZlcnRleCcpO1xyXG5cclxuZXhwb3J0cy5tYWtlID0gZnVuY3Rpb24gKHBvaW50cywgY29sb3JzLCBwbG90Qm91bmRzQXJnKSB7XHJcblxyXG4gICAgdmFyIF9wcm5nID0gcHJuZ01vZHVsZSgpO1xyXG4gICAgdmFyIF9zaXRlcyA9IHNpdGVMaXN0TW9kdWxlKCk7XHJcbiAgICB2YXIgX3NpdGVzSW5kZXhlZEJ5TG9jYXRpb24gPSB7fTsgLy8gRGljdGlvbmFyeTxTaXRlPlxyXG4gICAgdmFyIF90cmlhbmdsZXMgPSBbXTsgLy8gVmVjdG9yPFRyaWFuZ2xlPlxyXG4gICAgdmFyIF9lZGdlcyA9IFtdOyAvLyBWZWN0b3I8RWRnZT5cclxuXHJcbiAgICB2YXIgcHViID0ge307XHJcblxyXG4gICAgLy8gVE9ETyBnZW5lcmFsaXplIHRoaXMgc28gaXQgZG9lc24ndCBoYXZlIHRvIGJlIGEgcmVjdGFuZ2xlO1xyXG4gICAgLy8gdGhlbiB3ZSBjYW4gbWFrZSB0aGUgZnJhY3RhbCB2b3Jvbm9pcy13aXRoaW4tdm9yb25vaXNcclxuICAgIHB1Yi5wbG90Qm91bmRzID0gcGxvdEJvdW5kc0FyZztcclxuXHJcbiAgICBwdWIuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSwgbjtcclxuICAgICAgICBpZiAoX3NpdGVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF9zaXRlcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIF9zaXRlcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdHJpYW5nbGVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG4gPSBfdHJpYW5nbGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgX3RyaWFuZ2xlc1tpXS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9fdHJpYW5nbGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIF90cmlhbmdsZXMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2VkZ2VzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG4gPSBfZWRnZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBfZWRnZXNbaV0uZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vX2VkZ2VzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIF9lZGdlcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1Yi5wbG90Qm91bmRzID0gbnVsbDtcclxuICAgICAgICBfc2l0ZXNJbmRleGVkQnlMb2NhdGlvbiA9IG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQVMzIERpY3Rpb25hcnkgc3RvcmVzIG9iamVjdCBrZXlzIGJ5IG9iamVjdCBpZGVudGl0eS5cclxuICAgICAqIEhheGUgSGFzaCBvbmx5IHN1cHBvcnRzIHN0cmluZyBrZXlzLlxyXG4gICAgICogVGhpcyBtZWFucyBkdXBsaWNhdGUgY29vcmRpbmF0ZXMgY2FuJ3QgYmUgc3RvcmVkIGluIGhhc2guXHJcbiAgICAgKiBQcmV2ZW50IHRoaXMgY2FzZSB1bnRpbCBpdCdzIHBvc3NpYmxlIHRvIHN0b3JlIGR1cGxpY2F0ZSBwb2ludHMgY29vcmRzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBtYWtlU3VyZU5vRHVwbGljYXRlUG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIHZhciBoID0ge307XHJcbiAgICAgICAgXyhwb2ludHMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgaWYgKF8oaCkuaGFzKHBvaW50Q29yZS5oYXNoKHApKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ0R1cGxpY2F0ZSBwb2ludHMgbm90IHN1cHBvcnRlZCB5ZXQhJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoW3BvaW50Q29yZS5oYXNoKHApXSA9IHA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkU2l0ZXMocG9pbnRzLCBjb2xvcnMpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFkZFNpdGUocG9pbnRzW2ldLCAoY29sb3JzICE9PSBudWxsKSA/IGNvbG9yc1tpXSA6IDAsIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRTaXRlKHAsIGNvbG9yLCBpbmRleCkge1xyXG4gICAgICAgIHZhciB3ZWlnaHQgPSBfcHJuZy5uZXh0RG91YmxlKCkgKiAxMDA7XHJcbiAgICAgICAgdmFyIHNpdGUgPSBzaXRlTW9kdWxlLmNyZWF0ZShwLCBpbmRleCwgd2VpZ2h0LCBjb2xvcik7XHJcbiAgICAgICAgX3NpdGVzLnB1c2goc2l0ZSk7XHJcbiAgICAgICAgX3NpdGVzSW5kZXhlZEJ5TG9jYXRpb25bcG9pbnRDb3JlLmhhc2gocCldID0gc2l0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWIuZWRnZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9lZGdlcztcclxuICAgIH07XHJcblxyXG4gICAgcHViLnJlZ2lvbiA9IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgdmFyIHNpdGUgPSBfc2l0ZXNJbmRleGVkQnlMb2NhdGlvbltwb2ludENvcmUuaGFzaChwKV07XHJcbiAgICAgICAgaWYgKHNpdGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2l0ZS5yZWdpb24ocHViLnBsb3RCb3VuZHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPOiBidWc6IGlmIHlvdSBjYWxsIHRoaXMgYmVmb3JlIHlvdSBjYWxsIHJlZ2lvbigpLCBzb21ldGhpbmcgZ29lcyB3cm9uZyA6KFxyXG4gICAgcHViLm5laWdoYm9yU2l0ZXNGb3JTaXRlID0gZnVuY3Rpb24gKGNvb3JkKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdOyAvLyBWZWN0b3I8UG9pbnQ+XHJcbiAgICAgICAgdmFyIHNpdGUgPSBfc2l0ZXNJbmRleGVkQnlMb2NhdGlvbltwb2ludENvcmUuaGFzaChjb29yZCldO1xyXG4gICAgICAgIGlmIChzaXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaXRlcyA9IHNpdGUubmVpZ2hib3JTaXRlcygpO1xyXG4gICAgICAgIF8oc2l0ZXMpLmVhY2goZnVuY3Rpb24gKG5laWdoYm9yKSB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKG5laWdoYm9yLmNvb3JkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWIuY2lyY2xlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NpdGVzLmNpcmNsZXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHViLnZvcm9ub2lCb3VuZGFyeUZvclNpdGUgPSBmdW5jdGlvbiAoY29vcmQpIHtcclxuICAgICAgICByZXR1cm4gZGVsYXVuYXlNb2R1bGUudmlzaWJsZUxpbmVTZWdtZW50cyhkZWxhdW5heU1vZHVsZS5zZWxlY3RFZGdlc0ZvclNpdGVQb2ludChjb29yZCwgX2VkZ2VzKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5kZWxhdW5heUxpbmVzRm9yU2l0ZSA9IGZ1bmN0aW9uIChjb29yZCkge1xyXG4gICAgICAgIHJldHVybiBkZWxhdW5heU1vZHVsZS5kZWxhdW5heUxpbmVzRm9yRWRnZXMoZGVsYXVuYXlNb2R1bGUuc2VsZWN0RWRnZXNGb3JTaXRlUG9pbnQoY29vcmQsIF9lZGdlcykpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWIudm9yb25vaURpYWdyYW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlbGF1bmF5TW9kdWxlLnZpc2libGVMaW5lU2VnbWVudHMoX2VkZ2VzKTtcclxuICAgIH07XHJcblxyXG4gICAgcHViLmRlbGF1bmF5VHJpYW5ndWxhdGlvbiA9IGZ1bmN0aW9uIChrZWVwT3V0TWFzaykge1xyXG4gICAgICAgIGtlZXBPdXRNYXNrID0gZGVmKGtlZXBPdXRNYXNrLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gZGVsYXVuYXlNb2R1bGUuZGVsYXVuYXlMaW5lc0ZvckVkZ2VzKGRlbGF1bmF5TW9kdWxlLnNlbGVjdE5vbkludGVyc2VjdGluZ0VkZ2VzKGtlZXBPdXRNYXNrLCBfZWRnZXMpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHViLmh1bGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlbGF1bmF5TW9kdWxlLmRlbGF1bmF5TGluZXNGb3JFZGdlcyhodWxsRWRnZXMoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGh1bGxFZGdlcygpIHtcclxuICAgICAgICByZXR1cm4gXyhfZWRnZXMpLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGVkZ2UuaXNQYXJ0T2ZDb252ZXhIdWxsKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1Yi5odWxsUG9pbnRzSW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaHVsbEVkZ2VzID0gaHVsbEVkZ2VzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChodWxsRWRnZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZW9yZGVyZXIgPSBlZGdlUmVvcmRlcmVyTW9kdWxlKGh1bGxFZGdlcywgY3JpdGVyaW9uLnNpdGUpO1xyXG4gICAgICAgIGh1bGxFZGdlcyA9IHJlb3JkZXJlci5lZGdlcztcclxuICAgICAgICB2YXIgb3JpZW50YXRpb25zID0gcmVvcmRlcmVyLmVkZ2VPcmllbnRhdGlvbnM7XHJcbiAgICAgICAgcmVvcmRlcmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgb3JpZW50YXRpb247XHJcblxyXG4gICAgICAgIHZhciBuID0gaHVsbEVkZ2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlZGdlID0gaHVsbEVkZ2VzW2ldO1xyXG4gICAgICAgICAgICBvcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uc1tpXTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goZWRnZS5zaXRlKG9yaWVudGF0aW9uKS5jb29yZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5zcGFubmluZ1RyZWUgPSBmdW5jdGlvbiAodHlwZSwga2VlcE91dE1hc2spIHtcclxuICAgICAgICB0eXBlID0gZGVmKHR5cGUsICdtaW5pbXVtJyk7XHJcbiAgICAgICAga2VlcE91dE1hc2sgPSBkZWYoa2VlcE91dE1hc2ssIG51bGwpO1xyXG5cclxuICAgICAgICB2YXIgZWRnZXMgPSBkZWxhdW5heU1vZHVsZS5zZWxlY3ROb25JbnRlcnNlY3RpbmdFZGdlcyhrZWVwT3V0TWFzaywgX2VkZ2VzKTtcclxuICAgICAgICB2YXIgc2VnbWVudHMgPSBkZWxhdW5heU1vZHVsZS5kZWxhdW5heUxpbmVzRm9yRWRnZXMoZWRnZXMpO1xyXG4gICAgICAgIHJldHVybiBrcnVza2FsTW9kdWxlLmtydXNrYWwoc2VnbWVudHMsIHR5cGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWIucmVnaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3NpdGVzLnJlZ2lvbnMocHViLnBsb3RCb3VuZHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWIuc2l0ZUNvbG9ycyA9IGZ1bmN0aW9uIChyZWZlcmVuY2VJbWFnZSkge1xyXG4gICAgICAgIHJlZmVyZW5jZUltYWdlID0gZGVmKHJlZmVyZW5jZUltYWdlLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gX3NpdGVzLnNpdGVDb2xvcnMocmVmZXJlbmNlSW1hZ2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHByb3hpbWl0eU1hcCBhIEJpdG1hcERhdGEgd2hvc2UgcmVnaW9ucyBhcmUgZmlsbGVkIHdpdGggdGhlIHNpdGUgaW5kZXggdmFsdWVzOyBzZWUgUGxhbmVQb2ludHNDYW52YXM6OmZpbGxSZWdpb25zKClcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICogQHJldHVybiBjb29yZGluYXRlcyBvZiBuZWFyZXN0IFNpdGUgdG8gKHgsIHkpXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgcHViLm5lYXJlc3RTaXRlUG9pbnQgPSBmdW5jdGlvbiAocHJveGltaXR5TWFwLCB4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIF9zaXRlcy5uZWFyZXN0U2l0ZVBvaW50KHByb3hpbWl0eU1hcCwgeCwgeSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5zaXRlQ29vcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfc2l0ZXMuc2l0ZUNvb3JkcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBmb3J0dW5lc0FsZ29yaXRobSgpIHtcclxuICAgICAgICB2YXIgbmV3U2l0ZSwgYm90dG9tU2l0ZSwgdG9wU2l0ZSwgdGVtcFNpdGU7XHJcbiAgICAgICAgdmFyIHYsIHZlcnRleDtcclxuICAgICAgICB2YXIgbmV3aW50c3RhcjtcclxuICAgICAgICB2YXIgbGVmdFJpZ2h0O1xyXG4gICAgICAgIHZhciBsYm5kLCByYm5kLCBsbGJuZCwgcnJibmQsIGJpc2VjdG9yO1xyXG4gICAgICAgIHZhciBlZGdlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXRhQm91bmRzID0gX3NpdGVzLmdldFNpdGVzQm91bmRzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNxcnROc2l0ZXMgPSBjb3JlLnRvSW50KE1hdGguc3FydChfc2l0ZXMubGVuZ3RoICsgNCkpO1xyXG4gICAgICAgIHZhciBoZWFwID0gaGFsZmVkZ2VQcmlvcml0eVF1ZXVlKGRhdGFCb3VuZHMueSwgZGF0YUJvdW5kcy5oZWlnaHQsIHNxcnROc2l0ZXMpO1xyXG4gICAgICAgIHZhciBlZGdlTGlzdCA9IGVkZ2VMaXN0TW9kdWxlKGRhdGFCb3VuZHMueCwgZGF0YUJvdW5kcy53aWR0aCwgc3FydE5zaXRlcyk7XHJcbiAgICAgICAgdmFyIGhhbGZFZGdlcyA9IFtdO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBib3R0b21Nb3N0U2l0ZSA9IF9zaXRlcy5uZXh0KCk7XHJcbiAgICAgICAgbmV3U2l0ZSA9IF9zaXRlcy5uZXh0KCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGxlZnRSZWdpb24oaGUpIHtcclxuICAgICAgICAgICAgdmFyIGVkZ2UgPSBoZS5lZGdlO1xyXG4gICAgICAgICAgICBpZiAoZWRnZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdHRvbU1vc3RTaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlZGdlLnNpdGUoaGUubGVmdFJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gcmlnaHRSZWdpb24oaGUpIHtcclxuICAgICAgICAgICAgdmFyIGVkZ2UgPSBoZS5lZGdlO1xyXG4gICAgICAgICAgICBpZiAoZWRnZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvdHRvbU1vc3RTaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlZGdlLnNpdGUobHIub3RoZXIoaGUubGVmdFJpZ2h0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChoZWFwLmVtcHR5KCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdpbnRzdGFyID0gaGVhcC5taW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobmV3U2l0ZSAhPT0gbnVsbCAmJiAgKGhlYXAuZW1wdHkoKSB8fCBleHBvcnRzLmNvbXBhcmVQb2ludEJ5WVRoZW5YKG5ld1NpdGUsIG5ld2ludHN0YXIpIDwgMCkpIHtcclxuICAgICAgICAgICAgICAgIC8qIG5ldyBzaXRlIGlzIHNtYWxsZXN0ICovXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFN0ZXAgODpcclxuICAgICAgICAgICAgICAgIGxibmQgPSBlZGdlTGlzdC5lZGdlTGlzdExlZnROZWlnaGJvcihuZXdTaXRlLmNvb3JkKTsgICAgLy8gdGhlIEhhbGZlZGdlIGp1c3QgdG8gdGhlIGxlZnQgb2YgbmV3U2l0ZVxyXG4gICAgICAgICAgICAgICAgcmJuZCA9IGxibmQuZWRnZUxpc3RSaWdodE5laWdoYm9yOyAgICAgIC8vIHRoZSBIYWxmZWRnZSBqdXN0IHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgICAgICAgYm90dG9tU2l0ZSA9IHJpZ2h0UmVnaW9uKGxibmQpOyAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBsZWZ0UmVnaW9uKHJibmQpXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIFNpdGUgZGV0ZXJtaW5lcyB0aGUgcmVnaW9uIGNvbnRhaW5pbmcgdGhlIG5ldyBzaXRlXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFN0ZXAgOTpcclxuICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlTW9kdWxlLmNyZWF0ZUJpc2VjdGluZ0VkZ2UoYm90dG9tU2l0ZSwgbmV3U2l0ZSk7XHJcbiAgICAgICAgICAgICAgICBfZWRnZXMucHVzaChlZGdlKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgYmlzZWN0b3IgPSBoYWxmRWRnZU1vZHVsZS5jcmVhdGUoZWRnZSwgbHIuTEVGVCk7XHJcbiAgICAgICAgICAgICAgICBoYWxmRWRnZXMucHVzaChiaXNlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpbmcgdHdvIEhhbGZlZGdlcyBpbnRvIGVkZ2VMaXN0IGNvbnN0aXR1dGVzIFN0ZXAgMTA6XHJcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmlzZWN0b3IgdG8gdGhlIHJpZ2h0IG9mIGxibmQ6XHJcbiAgICAgICAgICAgICAgICBlZGdlTGlzdC5pbnNlcnQobGJuZCwgYmlzZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBoYWxmIG9mIFN0ZXAgMTE6XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZlcnRleCA9IHZlcnRleE1vZHVsZS5pbnRlcnNlY3QobGJuZCwgYmlzZWN0b3IpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFwLnJlbW92ZShsYm5kKTtcclxuICAgICAgICAgICAgICAgICAgICBsYm5kLnZlcnRleCA9IHZlcnRleDtcclxuICAgICAgICAgICAgICAgICAgICBsYm5kLnlzdGFyID0gdmVydGV4LnkgKyBuZXdTaXRlLmRpc3QodmVydGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFwLmluc2VydChsYm5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbGJuZCA9IGJpc2VjdG9yO1xyXG4gICAgICAgICAgICAgICAgYmlzZWN0b3IgPSBoYWxmRWRnZU1vZHVsZS5jcmVhdGUoZWRnZSwgbHIuUklHSFQpO1xyXG4gICAgICAgICAgICAgICAgaGFsZkVkZ2VzLnB1c2goYmlzZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kIEhhbGZlZGdlIGZvciBTdGVwIDEwOlxyXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGJpc2VjdG9yIHRvIHRoZSByaWdodCBvZiBsYm5kOlxyXG4gICAgICAgICAgICAgICAgZWRnZUxpc3QuaW5zZXJ0KGxibmQsIGJpc2VjdG9yKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kIGhhbGYgb2YgU3RlcCAxMTpcclxuICAgICAgICAgICAgICAgIGlmICgodmVydGV4ID0gdmVydGV4TW9kdWxlLmludGVyc2VjdChiaXNlY3RvciwgcmJuZCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJpc2VjdG9yLnZlcnRleCA9IHZlcnRleDtcclxuICAgICAgICAgICAgICAgICAgICBiaXNlY3Rvci55c3RhciA9IHZlcnRleC55ICsgbmV3U2l0ZS5kaXN0KHZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhcC5pbnNlcnQoYmlzZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBuZXdTaXRlID0gX3NpdGVzLm5leHQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWFwLmVtcHR5KCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBpbnRlcnNlY3Rpb24gaXMgc21hbGxlc3QgKi9cclxuICAgICAgICAgICAgICAgIGxibmQgPSBoZWFwLmV4dHJhY3RNaW4oKTtcclxuICAgICAgICAgICAgICAgIGxsYm5kID0gbGJuZC5lZGdlTGlzdExlZnROZWlnaGJvcjtcclxuICAgICAgICAgICAgICAgIHJibmQgPSBsYm5kLmVkZ2VMaXN0UmlnaHROZWlnaGJvcjtcclxuICAgICAgICAgICAgICAgIHJyYm5kID0gcmJuZC5lZGdlTGlzdFJpZ2h0TmVpZ2hib3I7XHJcbiAgICAgICAgICAgICAgICBib3R0b21TaXRlID0gbGVmdFJlZ2lvbihsYm5kKTtcclxuICAgICAgICAgICAgICAgIHRvcFNpdGUgPSByaWdodFJlZ2lvbihyYm5kKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZXNlIHRocmVlIHNpdGVzIGRlZmluZSBhIERlbGF1bmF5IHRyaWFuZ2xlXHJcbiAgICAgICAgICAgICAgICAvLyAobm90IGFjdHVhbGx5IHVzaW5nIHRoZXNlIGZvciBhbnl0aGluZy4uLilcclxuICAgICAgICAgICAgICAgIC8vX3RyaWFuZ2xlcy5wdXNoKG5ldyBUcmlhbmdsZShib3R0b21TaXRlLCB0b3BTaXRlLCByaWdodFJlZ2lvbihsYm5kKSkpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2ID0gbGJuZC52ZXJ0ZXg7XHJcbiAgICAgICAgICAgICAgICB2LnNldEluZGV4KCk7XHJcbiAgICAgICAgICAgICAgICBsYm5kLmVkZ2Uuc2V0VmVydGV4KGxibmQubGVmdFJpZ2h0LCB2KTtcclxuICAgICAgICAgICAgICAgIHJibmQuZWRnZS5zZXRWZXJ0ZXgocmJuZC5sZWZ0UmlnaHQsIHYpO1xyXG4gICAgICAgICAgICAgICAgZWRnZUxpc3QucmVtb3ZlKGxibmQpO1xyXG4gICAgICAgICAgICAgICAgaGVhcC5yZW1vdmUocmJuZCk7XHJcbiAgICAgICAgICAgICAgICBlZGdlTGlzdC5yZW1vdmUocmJuZCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0UmlnaHQgPSBsci5MRUZUO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdHRvbVNpdGUueSA+IHRvcFNpdGUueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBTaXRlID0gYm90dG9tU2l0ZTtcclxuICAgICAgICAgICAgICAgICAgICBib3R0b21TaXRlID0gdG9wU2l0ZTtcclxuICAgICAgICAgICAgICAgICAgICB0b3BTaXRlID0gdGVtcFNpdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdFJpZ2h0ID0gbHIuUklHSFQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlZGdlID0gZWRnZU1vZHVsZS5jcmVhdGVCaXNlY3RpbmdFZGdlKGJvdHRvbVNpdGUsIHRvcFNpdGUpO1xyXG4gICAgICAgICAgICAgICAgX2VkZ2VzLnB1c2goZWRnZSk7XHJcbiAgICAgICAgICAgICAgICBiaXNlY3RvciA9IGhhbGZFZGdlTW9kdWxlLmNyZWF0ZShlZGdlLCBsZWZ0UmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgaGFsZkVkZ2VzLnB1c2goYmlzZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgZWRnZUxpc3QuaW5zZXJ0KGxsYm5kLCBiaXNlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICBlZGdlLnNldFZlcnRleChsci5vdGhlcihsZWZ0UmlnaHQpLCB2KTtcclxuICAgICAgICAgICAgICAgIGlmICgodmVydGV4ID0gdmVydGV4TW9kdWxlLmludGVyc2VjdChsbGJuZCwgYmlzZWN0b3IpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFwLnJlbW92ZShsbGJuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGxibmQudmVydGV4ID0gdmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGxsYm5kLnlzdGFyID0gdmVydGV4LnkgKyBib3R0b21TaXRlLmRpc3QodmVydGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFwLmluc2VydChsbGJuZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHZlcnRleCA9IHZlcnRleE1vZHVsZS5pbnRlcnNlY3QoYmlzZWN0b3IsIHJyYm5kKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmlzZWN0b3IudmVydGV4ID0gdmVydGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGJpc2VjdG9yLnlzdGFyID0gdmVydGV4LnkgKyBib3R0b21TaXRlLmRpc3QodmVydGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFwLmluc2VydChiaXNlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBoZWFwIHNob3VsZCBiZSBlbXB0eSBub3dcclxuICAgICAgICBoZWFwLmRpc3Bvc2UoKTtcclxuICAgICAgICBlZGdlTGlzdC5kaXNwb3NlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgXyhoYWxmRWRnZXMpLmVhY2goZnVuY3Rpb24gKGhhbGZFZGdlKSB7XHJcbiAgICAgICAgICAgIGhhbGZFZGdlLnJlYWxseURpc3Bvc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL2hhbGZFZGdlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHdlIG5lZWQgdGhlIHZlcnRpY2VzIHRvIGNsaXAgdGhlIGVkZ2VzXHJcbiAgICAgICAgXyhfZWRnZXMpLmVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcclxuICAgICAgICAgICAgZWRnZS5jbGlwVmVydGljZXMocHViLnBsb3RCb3VuZHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGJ1dCB3ZSBkb24ndCBhY3R1YWxseSBldmVyIHVzZSB0aGVtIGFnYWluIVxyXG4gICAgICAgIF8odmVydGljZXMpLmVhY2goZnVuY3Rpb24gKHZlcnRleCkge1xyXG4gICAgICAgICAgICB2ZXJ0ZXguZGlzcG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vdmVydGljZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBtYWtlU3VyZU5vRHVwbGljYXRlUG9pbnRzKHBvaW50cyk7XHJcbiAgICBfcHJuZy5zZWVkID0gMTtcclxuICAgIGFkZFNpdGVzKHBvaW50cywgY29sb3JzKTtcclxuICAgIGZvcnR1bmVzQWxnb3JpdGhtKCk7XHJcblxyXG4gICAgcmV0dXJuIHB1YjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIeERlbGF1bmF5XHJcbiAqL1xyXG5leHBvcnRzLmlzSW5mU2l0ZSA9IGZ1bmN0aW9uIChzMSwgczIpIHtcclxuICAgIHJldHVybiAoczEueSA8IHMyLnkpIHx8IChzMS55ID09PSBzMi55ICYmIHMxLnggPCBzMi54KTtcclxufTtcclxuXHJcbmV4cG9ydHMuY29tcGFyZVBvaW50QnlZVGhlblggPSBmdW5jdGlvbiAoczEsIHMyKSB7XHJcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlQnlZVGhlblgoczEueCwgczEueSwgczIueCwgczIueSk7XHJcbn07XHJcblxyXG5leHBvcnRzLmNvbXBhcmVTaXRlQnlZVGhlblggPSBmdW5jdGlvbiAoczEsIHMyKSB7XHJcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlQnlZVGhlblgoczEueCwgczEueSwgczIueCwgczIueSk7XHJcbn07XHJcblxyXG5leHBvcnRzLmNvbXBhcmVCeVlUaGVuWCA9IGZ1bmN0aW9uIChzMXgsIHMxeSwgczJ4LCBzMnkpIHtcclxuICAgIGlmIChzMXkgPCBzMnkpIHsgcmV0dXJuIC0xOyB9XHJcbiAgICBpZiAoczF5ID4gczJ5KSB7IHJldHVybiAxOyB9XHJcbiAgICBpZiAoczF4IDwgczJ4KSB7IHJldHVybiAtMTsgfVxyXG4gICAgaWYgKHMxeCA+IHMyeCkgeyByZXR1cm4gMTsgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNlbnRlcjoge3g6IGNlbnRlclgsIHk6IGNlbnRlcll9LFxyXG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnQ2lyY2xlIChjZW50ZXI6ICcgKyB0aGlzLmNlbnRlciArICc7IHJhZGl1czogJyArIHRoaXMucmFkaXVzICsgJyknO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIHBvaW50Q29yZSA9IHJlcXVpcmUoJy4uLy4uL2FzMy9wb2ludC1jb3JlJyk7XHJcblxyXG5leHBvcnRzLm1ha2UgPSBmdW5jdGlvbiAocDAsIHAxKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHAwOiBwMCxcclxuICAgICAgICBwMTogcDFcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnRzLmNvcmUgPSB7XHJcbiAgICBjb21wYXJlTGVuZ3Roc01heDogZnVuY3Rpb24gKHNlZ21lbnQwLCBzZWdtZW50MSkge1xyXG4gICAgICAgIHZhciBsZW5ndGgwID0gcG9pbnRDb3JlLmRpc3RhbmNlKHNlZ21lbnQwLnAwLCBzZWdtZW50MC5wMSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aDEgPSBwb2ludENvcmUuZGlzdGFuY2Uoc2VnbWVudDEucDAsIHNlZ21lbnQxLnAxKTtcclxuICAgICAgICBpZiAobGVuZ3RoMCA8IGxlbmd0aDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsZW5ndGgwID4gbGVuZ3RoMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBjb21wYXJlTGVuZ3RoczogZnVuY3Rpb24gKGVkZ2UwLCBlZGdlMSkge1xyXG4gICAgICAgIHJldHVybiAtIHRoaXMuY29tcGFyZUxlbmd0aHNNYXgoZWRnZTAsIGVkZ2UxKTtcclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgd2luZGluZyA9IHJlcXVpcmUoJy4vd2luZGluZycpO1xyXG5cclxudmFyIFBvbHlnb24gPSBmdW5jdGlvbiAodmVydGljZXMpIHtcclxuICAgIHRoaXMuX3ZlcnRpY2VzID0gdmVydGljZXM7XHJcbn07XHJcblxyXG5Qb2x5Z29uLnByb3RvdHlwZSA9IHtcclxuICAgIGFyZWE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zaWduZWREb3VibGVBcmVhKCkgKiAwLjUpO1xyXG4gICAgfSxcclxuXHJcbiAgICB3aW5kaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNpZ25lZERvdWJsZUFyZWEgPSB0aGlzLnNpZ25lZERvdWJsZUFyZWEoKTtcclxuICAgICAgICBpZiAoc2lnbmVkRG91YmxlQXJlYSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRpbmcuQ0xPQ0tXSVNFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2lnbmVkRG91YmxlQXJlYSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRpbmcuQ09VTlRFUkNMT0NLV0lTRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdpbmRpbmcuTk9ORTtcclxuICAgIH0sXHJcblxyXG4gICAgc2lnbmVkRG91YmxlQXJlYTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbmRleCwgbmV4dEluZGV4O1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5fdmVydGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBwb2ludCwgbmV4dDtcclxuICAgICAgICB2YXIgc2lnbmVkRG91YmxlQXJlYSA9IDA7XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbjsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBuZXh0SW5kZXggPSAoaW5kZXggKyAxKSAlIG47XHJcbiAgICAgICAgICAgIHBvaW50ID0gdGhpcy5fdmVydGljZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5fdmVydGljZXNbbmV4dEluZGV4XTtcclxuICAgICAgICAgICAgc2lnbmVkRG91YmxlQXJlYSArPSBwb2ludC54ICogbmV4dC55IC0gbmV4dC54ICogcG9pbnQueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpZ25lZERvdWJsZUFyZWE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2ZXJ0aWNlcykge1xyXG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHZlcnRpY2VzKTtcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXHJcbiAgICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZScsXHJcbiAgICBOT05FOiAnbm9uZSdcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzZXQgc2VlZCB3aXRoIGEgMzEgYml0IHVuc2lnbmVkIGludGVnZXJcclxuICAgICAgICAgKiBiZXR3ZWVuIDEgYW5kIDBYN0ZGRkZGRkUgaW5jbHVzaXZlLiBkb24ndCB1c2UgMCFcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWVkOiAxLFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBwcm92aWRlcyB0aGUgbmV4dCBwc2V1ZG9yYW5kb20gbnVtYmVyXHJcbiAgICAgICAgICogYXMgYSBmbG9hdCBiZXR3ZWVuIG5lYXJseSAwIGFuZCBuZWFybHkgMS4wLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5leHREb3VibGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmdlbigpIC8gMjE0NzQ4MzY0Nyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcHJvdmlkZXMgdGhlIG5leHQgcHNldWRvcmFuZG9tIG51bWJlclxyXG4gICAgICAgICAqIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgKDMxIGJpdHMpIGJldHdlZWVuXHJcbiAgICAgICAgICogYSBnaXZlbiByYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZXh0SW50UmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgICAgICBtaW4gLT0gMC40OTk5O1xyXG4gICAgICAgICAgICBtYXggKz0gMC40OTk5O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtaW4gKyAoKG1heCAtIG1pbikgKiB0aGlzLm5leHREb3VibGUoKSkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByb3ZpZGVzIHRoZSBuZXh0IHBzZXVkb3JhbmRvbSBudW1iZXJcclxuICAgICAgICAgKiBhcyBhIGZsb2F0IGJldHdlZW4gYSBnaXZlbiByYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZXh0RG91YmxlUmFuZ2U6IGZ1bmN0aW9uIChtaW4sIG1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWluICsgKChtYXggLSBtaW4pICogdGhpcy5uZXh0RG91YmxlKCkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGdlbmVyYXRvcjpcclxuICAgICAgICAgKiBuZXctdmFsdWUgPSAob2xkLXZhbHVlICogMTY4MDcpIG1vZCAoMl4zMSAtIDEpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2VuOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vaW50ZWdlciB2ZXJzaW9uIDEsIGZvciBtYXggaW50IDJeNDYgLSAxIG9yIGxhcmdlci5cclxuICAgICAgICAgICAgdGhpcy5zZWVkID0gKHRoaXMuc2VlZCAqIDE2ODA3KSAlIDIxNDc0ODM2NDc7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlZWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogaW50ZWdlciB2ZXJzaW9uIDIsIGZvciBtYXggaW50IDJeMzEgLSAxIChzbG93ZXN0KVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLy92YXIgdGVzdDppbnQgPSAxNjgwNyAqIChzZWVkICUgMTI3NzczID4+IDApIC0gMjgzNiAqIChzZWVkIC8gMTI3NzczID4+IDApO1xyXG4gICAgICAgICAgICAvL3JldHVybiBzZWVkID0gKHRlc3QgPiAwID8gdGVzdCA6IHRlc3QgKyAyMTQ3NDgzNjQ3KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBkYXZpZCBnLiBjYXJ0YSdzIG9wdGltaXNhdGlvbiBpcyAxNSUgc2xvd2VyIHRoYW4gaW50ZWdlciB2ZXJzaW9uIDFcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vdmFyIGhpOnVpbnQgPSAxNjgwNyAqIChzZWVkID4+IDE2KTtcclxuICAgICAgICAgICAgLy92YXIgbG86dWludCA9IDE2ODA3ICogKHNlZWQgJiAweEZGRkYpICsgKChoaSAmIDB4N0ZGRikgPDwgMTYpICsgKGhpID4+IDE1KTtcclxuICAgICAgICAgICAgLy9yZXR1cm4gc2VlZCA9IChsbyA+IDB4N0ZGRkZGRkYgPyBsbyAtIDB4N0ZGRkZGRkYgOiBsbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgY29sb3JNb2R1bGUgPSByZXF1aXJlKCcuLi9qYW5pY2VrL2h0bWwtY29sb3InKTtcclxudmFyIGNvbnZlcnQgPSByZXF1aXJlKCcuLi9hczMvY29udmVyc2lvbi1jb3JlJyk7XHJcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vamFuaWNlay9jb3JlJyk7XHJcbnZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9hczMvbWF0cml4Jyk7XHJcbnZhciBwb2ludENvcmUgPSByZXF1aXJlKCcuLi9hczMvcG9pbnQtY29yZScpO1xyXG52YXIgdmVjdG9yM2QgPSByZXF1aXJlKCcuLi9hczMvdmVjdG9yLTNkJyk7XHJcblxyXG5leHBvcnRzLmdyYXBoaWNzUmVzZXQgPSBmdW5jdGlvbiAoYywgbWFwV2lkdGgsIG1hcEhlaWdodCwgZGlzcGxheUNvbG9ycykge1xyXG4gICAgYy5saW5lV2lkdGggPSAxLjA7XHJcbiAgICBjLmNsZWFyUmVjdCgwLCAwLCAyMDAwLCAyMDAwKTtcclxuICAgIGMuZmlsbFN0eWxlID0gJyNiYmJiYWEnO1xyXG4gICAgYy5maWxsUmVjdCgwLCAwLCAyMDAwLCAyMDAwKTtcclxuICAgIGMuZmlsbFN0eWxlID0gY29sb3JNb2R1bGUuaW50VG9IZXhDb2xvcihkaXNwbGF5Q29sb3JzLk9DRUFOKTtcclxuICAgIGMuZmlsbFJlY3QoMCwgMCwgY29yZS50b0ludChtYXBXaWR0aCksIGNvcmUudG9JbnQobWFwSGVpZ2h0KSk7XHJcbn07XHJcblxyXG52YXIgbGlnaHRWZWN0b3IgPSB2ZWN0b3IzZC5tYWtlKC0xLCAtMSwgMCk7XHJcblxyXG5leHBvcnRzLmNhbGN1bGF0ZUxpZ2h0aW5nID0gZnVuY3Rpb24gKHAsIHIsIHMpIHtcclxuICAgIHZhciBBID0gdmVjdG9yM2QubWFrZShwLnBvaW50LngsIHAucG9pbnQueSwgcC5lbGV2YXRpb24pO1xyXG4gICAgdmFyIEIgPSB2ZWN0b3IzZC5tYWtlKHIucG9pbnQueCwgci5wb2ludC55LCByLmVsZXZhdGlvbik7XHJcbiAgICB2YXIgQyA9IHZlY3RvcjNkLm1ha2Uocy5wb2ludC54LCBzLnBvaW50LnksIHMuZWxldmF0aW9uKTtcclxuICAgIHZhciBub3JtYWwgPSBCLnN1YnRyYWN0KEEpLmNyb3NzUHJvZHVjdChDLnN1YnRyYWN0KEEpKTtcclxuICAgIGlmIChub3JtYWwueiA8IDApIHsgbm9ybWFsLnNjYWxlQnkoLTEpOyB9XHJcbiAgICBub3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICB2YXIgbGlnaHQgPSAwLjUgKyAzNSAqIG5vcm1hbC5kb3RQcm9kdWN0KGxpZ2h0VmVjdG9yKTtcclxuICAgIGlmIChsaWdodCA8IDApIHsgbGlnaHQgPSAwOyB9XHJcbiAgICBpZiAobGlnaHQgPiAxKSB7IGxpZ2h0ID0gMTsgfVxyXG4gICAgcmV0dXJuIGxpZ2h0O1xyXG59O1xyXG5cclxuZXhwb3J0cy5jb2xvcldpdGhTbG9wZSA9IGZ1bmN0aW9uIChjb2xvciwgcCwgcSwgZWRnZSwgZGlzcGxheUNvbG9ycykge1xyXG4gICAgdmFyIHIgPSBlZGdlLnYwO1xyXG4gICAgdmFyIHMgPSBlZGdlLnYxO1xyXG4gICAgaWYgKF8uaXNOdWxsKHIpIHx8IF8uaXNOdWxsKHMpKSB7XHJcbiAgICAgICAgLy8gRWRnZSBvZiB0aGUgbWFwXHJcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlDb2xvcnMuT0NFQU47XHJcbiAgICB9IGVsc2UgaWYgKHAud2F0ZXIpIHtcclxuICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHEgIT09IG51bGwgJiYgcC53YXRlciA9PT0gcS53YXRlcikge1xyXG4gICAgICAgIGNvbG9yID0gY29sb3JNb2R1bGUuaW50ZXJwb2xhdGVDb2xvcihjb2xvciwgZGlzcGxheUNvbG9yc1txLmJpb21lXSwgMC40KTtcclxuICAgIH1cclxuICAgIHZhciBjb2xvckxvdyA9IGNvbG9yTW9kdWxlLmludGVycG9sYXRlQ29sb3IoY29sb3IsIDB4MzMzMzMzLCAwLjcpO1xyXG4gICAgdmFyIGNvbG9ySGlnaCA9IGNvbG9yTW9kdWxlLmludGVycG9sYXRlQ29sb3IoY29sb3IsIDB4ZmZmZmZmLCAwLjMpO1xyXG4gICAgdmFyIGxpZ2h0ID0gZXhwb3J0cy5jYWxjdWxhdGVMaWdodGluZyhwLCByLCBzKTtcclxuICAgIGlmIChsaWdodCA8IDAuNSkge1xyXG4gICAgICAgIHJldHVybiBjb2xvck1vZHVsZS5pbnRlcnBvbGF0ZUNvbG9yKGNvbG9yTG93LCBjb2xvciwgbGlnaHQgKiAyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yTW9kdWxlLmludGVycG9sYXRlQ29sb3IoY29sb3IsIGNvbG9ySGlnaCwgbGlnaHQgKiAyIC0gMSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnRzLmNvbG9yV2l0aFNtb290aENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvciwgcCwgcSwgZWRnZSwgZGlzcGxheUNvbG9ycykge1xyXG4gICAgaWYgKHEgIT09IG51bGwgJiYgcC53YXRlciA9PT0gcS53YXRlcikge1xyXG4gICAgICAgIGNvbG9yID0gY29sb3JNb2R1bGUuaW50ZXJwb2xhdGVDb2xvcihkaXNwbGF5Q29sb3JzW3AuYmlvbWVdLCBkaXNwbGF5Q29sb3JzW3EuYmlvbWVdLCAwLjI1KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2xvcjtcclxufTtcclxuXHJcbmV4cG9ydHMucmVuZGVyRGVidWdQb2x5Z29ucyA9IGZ1bmN0aW9uIChjb250ZXh0LCBtYXAsIGRpc3BsYXlDb2xvcnMpIHtcclxuXHJcbiAgICB2YXIgY29sb3I7XHJcblxyXG4gICAgaWYgKG1hcC5jZW50ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIC8vIFdlJ3JlIHN0aWxsIGNvbnN0cnVjdGluZyB0aGUgbWFwIHNvIHdlIG1heSBoYXZlIHNvbWUgcG9pbnRzXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2RkZGRkZCc7XHJcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjb3JlLnRvSW50KG1hcC5TSVpFLndpZHRoKSwgY29yZS50b0ludChtYXAuU0laRS5oZWlnaHQpIC8qY29udGV4dC5jYW52YXMud2lkdGgsIGNvbnRleHQuY2FudmFzLmhlaWdodCAqLyk7IC8vZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgU0laRSwgU0laRSk7XHJcbiAgICAgICAgXyhtYXAucG9pbnRzKS5lYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJyMwMDAwMDAnO1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcclxuICAgICAgICAgICAgY29udGV4dC5hcmMocG9pbnQueCwgcG9pbnQueSwgMS4zLCBNYXRoLlBJLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcclxuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgXyhtYXAuY2VudGVycykuZWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIGNvbG9yID0gIV8uaXNOdWxsKHAuYmlvbWUpID8gZGlzcGxheUNvbG9yc1twLmJpb21lXSA6IChwLm9jZWFuID8gZGlzcGxheUNvbG9ycy5PQ0VBTiA6IHAud2F0ZXIgPyBkaXNwbGF5Q29sb3JzLlJJVkVSIDogMHhmZmZmZmYpO1xyXG4gICAgICBcclxuICAgICAgICAvL0RyYXcgc2hhcGVcclxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIF8ocC5ib3JkZXJzKS5lYWNoKGZ1bmN0aW9uIChlZGdlKSB7XHJcbiAgICAgICAgICAgIGlmICghXy5pc051bGwoZWRnZS52MCkgJiYgIV8uaXNOdWxsKGVkZ2UudjEpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwLnBvaW50LngsIHAucG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhlZGdlLnYwLnBvaW50LngsIGVkZ2UudjAucG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhlZGdlLnYxLnBvaW50LngsIGVkZ2UudjEucG9pbnQueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3JNb2R1bGUuaW50VG9IZXhDb2xvcihjb2xvck1vZHVsZS5pbnRlcnBvbGF0ZUNvbG9yKGNvbG9yLCAweGRkZGRkZCwgMC4yKSk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcblxyXG4gICAgICAgIC8vRHJhdyBib3JkZXJzXHJcbiAgICAgICAgXyhwLmJvcmRlcnMpLmVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcclxuICAgICAgICAgICAgaWYgKCFfLmlzTnVsbChlZGdlLnYwKSAmJiAhXy5pc051bGwoZWRnZS52MSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhlZGdlLnYwLnBvaW50LngsIGVkZ2UudjAucG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5yaXZlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yTW9kdWxlLmludFRvSGV4Q29sb3IoZGlzcGxheUNvbG9ycy5SSVZFUik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMC4xO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAnIzAwMDAwMCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhlZGdlLnYxLnBvaW50LngsIGVkZ2UudjEucG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAocC53YXRlciA/ICcjMDAzMzMzJyA6ICcjMDAwMDAwJyk7XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDAuNztcclxuICAgICAgICBjb250ZXh0LmFyYyhwLnBvaW50LngsIHAucG9pbnQueSwgMS4zLCBNYXRoLlBJLCAyICogTWF0aC5QSSwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IDEuMDtcclxuICAgICAgICBfKHAuY29ybmVycykuZWFjaChmdW5jdGlvbiAocSkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHEud2F0ZXIgPyAnIzAwMDBmZicgOiAnIzAwOTkwMCc7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoY29yZS50b0ludChxLnBvaW50LnggLSAwLjcpLCBjb3JlLnRvSW50KHEucG9pbnQueSAtIDAuNyksIGNvcmUudG9JbnQoMS41KSwgY29yZS50b0ludCgxLjUpKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlciB0aGUgcGF0aHMgZnJvbSBlYWNoIHBvbHlnb24gdG8gdGhlIG9jZWFuLCBzaG93aW5nIHdhdGVyc2hlZHMuXHJcbiAqL1xyXG5leHBvcnRzLnJlbmRlcldhdGVyc2hlZHMgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIG1hcCwgd2F0ZXJzaGVkcykge1xyXG4gICAgdmFyIGVkZ2UsIHcwLCB3MTtcclxuXHJcbiAgICBfKG1hcC5lZGdlcykuZWFjaChmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgIGlmICghXy5pc051bGwoZWRnZS5kMCkgJiYgIV8uaXNOdWxsKGVkZ2UuZDEpICYmICFfLmlzTnVsbChlZGdlLnYwKSAmJiAhXy5pc051bGwoZWRnZS52MSkgJiYgIWVkZ2UuZDAub2NlYW4gJiYgIWVkZ2UuZDEub2NlYW4pIHtcclxuICAgICAgICAgICAgdzAgPSB3YXRlcnNoZWRzLndhdGVyc2hlZHNbZWRnZS5kMC5pbmRleF07XHJcbiAgICAgICAgICAgIHcxID0gd2F0ZXJzaGVkcy53YXRlcnNoZWRzW2VkZ2UuZDEuaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAodzAgIT09IHcxKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIC8vZ3JhcGhpY3MubGluZVN0eWxlKDMuNSwgMHgwMDAwMDAsIDAuMSAqIE1hdGguc3FydCgobWFwLmNvcm5lcnNbdzBdLndhdGVyc2hlZFNpemUgfHwgMSkgKyAobWFwLmNvcm5lcnNbdzFdLndhdGVyc2hlZC53YXRlcnNoZWRTaXplIHx8IDEpKSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5saW5lV2lkdGggPSAzLjU7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5zdHJva2VTdHlsZSA9IGNvbG9yTW9kdWxlLnJnYmEoMCwgMCwgMCwgMC4xICogTWF0aC5zcXJ0KChjb3JlLmNvYWxlc2NlKG1hcC5jb3JuZXJzW3cwXS53YXRlcnNoZWRTaXplLCAxKSkgKyAoY29yZS5jb2FsZXNjZShtYXAuY29ybmVyc1t3MV0ud2F0ZXJzaGVkLndhdGVyc2hlZFNpemUsIDEpKSkpO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MubW92ZVRvKGVkZ2UudjAucG9pbnQueCwgZWRnZS52MC5wb2ludC55KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVUbyhlZGdlLnYxLnBvaW50LngsIGVkZ2UudjEucG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5jbG9zZVBhdGgoKTsgLy9ncmFwaGljcy5saW5lU3R5bGUoKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZm9yIChlZGdlIGluIG1hcC5lZGdlcykge1xyXG4gICAgICAgIGlmIChjb252ZXJ0LmJvb2xlYW5Gcm9tSW50KGVkZ2Uucml2ZXIpKSB7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICAvL2dyYXBoaWNzLmxpbmVTdHlsZSgxLjAsIDB4NjY5OWZmKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MubGluZVdpZHRoID0gMS4wO1xyXG4gICAgICAgICAgICBncmFwaGljcy5zdHJva2VTdHlsZSA9ICcjNjY5OWZmJztcclxuICAgICAgICAgICAgZ3JhcGhpY3MubW92ZVRvKGVkZ2UudjAucG9pbnQueCwgZWRnZS52MC5wb2ludC55KTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MubGluZVRvKGVkZ2UudjEucG9pbnQueCwgZWRnZS52MS5wb2ludC55KTtcclxuICAgICAgICAgICAgLy9ncmFwaGljcy5saW5lU3R5bGUoKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGRyYXdQYXRoRm9yd2FyZHMoZ3JhcGhpY3MsIHBhdGgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbyhwYXRoW2ldLngsIHBhdGhbaV0ueSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGRyYXdpbmcgdHJpYW5nbGVzIHdpdGggZ3JhZGllbnRzLiBUaGlzXHJcbiAqIGZ1bmN0aW9uIHNldHMgdXAgdGhlIGZpbGwgb24gdGhlIGdyYXBoaWNzIG9iamVjdCwgYW5kIHRoZW5cclxuICogY2FsbHMgZmlsbEZ1bmN0aW9uIHRvIGRyYXcgdGhlIGRlc2lyZWQgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIGRyYXdHcmFkaWVudFRyaWFuZ2xlKGdyYXBoaWNzLCB2MSwgdjIsIHYzLCBjb2xvcnMsIGZpbGxGdW5jdGlvbiwgZmlsbFgsIGZpbGxZKSB7XHJcbiAgICB2YXIgbSA9IG1hdHJpeCgpO1xyXG5cclxuICAgIC8vIENlbnRlciBvZiB0cmlhbmdsZTpcclxuICAgIHZhciBWID0gdjEuYWRkKHYyKS5hZGQodjMpO1xyXG4gICAgVi5zY2FsZUJ5KDEgLyAzLjApO1xyXG5cclxuICAgIC8vIE5vcm1hbCBvZiB0aGUgcGxhbmUgY29udGFpbmluZyB0aGUgdHJpYW5nbGU6XHJcbiAgICB2YXIgTiA9IHYyLnN1YnRyYWN0KHYxKS5jcm9zc1Byb2R1Y3QodjMuc3VidHJhY3QodjEpKTtcclxuICAgIE4ubm9ybWFsaXplKCk7XHJcblxyXG4gICAgLy8gR3JhZGllbnQgdmVjdG9yIGluIHgteSBwbGFuZSBwb2ludGluZyBpbiB0aGUgZGlyZWN0aW9uIG9mIGluY3JlYXNpbmcgelxyXG4gICAgdmFyIEcgPSB2ZWN0b3IzZC5tYWtlKC1OLnggLyBOLnosIC1OLnkgLyBOLnosIDApO1xyXG5cclxuICAgIC8vIENlbnRlciBvZiB0aGUgY29sb3IgZ3JhZGllbnRcclxuICAgIHZhciBDID0gdmVjdG9yM2QubWFrZShWLnggLSBHLnggKiAoKFYueiAtIDAuNSkgLyBHLmxlbmd0aCAvIEcubGVuZ3RoKSwgVi55IC0gRy55ICogKChWLnogLSAwLjUpIC8gRy5sZW5ndGggLyBHLmxlbmd0aCkpO1xyXG5cclxuICAgIGlmIChHLmxlbmd0aCA8IDFlLTYpIHtcclxuICAgICAgICAvLyBJZiB0aGUgZ3JhZGllbnQgdmVjdG9yIGlzIHNtYWxsLCB0aGVyZSdzIG5vdCBtdWNoXHJcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBjb2xvcnMgYWNyb3NzIHRoaXMgdHJpYW5nbGUuIFVzZSBhIHBsYWluXHJcbiAgICAgICAgLy8gZmlsbCwgYmVjYXVzZSB0aGUgbnVtZXJpYyBhY2N1cmFjeSBvZiAxL0cubGVuZ3RoIGlzIG5vdCB0b1xyXG4gICAgICAgIC8vIGJlIHRydXN0ZWQuICBOT1RFOiBvbmx5IHdvcmtzIGZvciAxLCAyLCAzIGNvbG9ycyBpbiB0aGUgYXJyYXlcclxuICAgICAgICB2YXIgY29sb3IgPSBjb2xvcnNbMF07XHJcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgY29sb3IgPSBjb2xvck1vZHVsZS5pbnRlcnBvbGF0ZUNvbG9yKGNvbG9yc1swXSwgY29sb3JzWzFdLCBWLnopO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3JzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgICBpZiAoVi56IDwgMC41KSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yTW9kdWxlLmludGVycG9sYXRlQ29sb3IoY29sb3JzWzBdLCBjb2xvcnNbMV0sIFYueiAqIDIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjb2xvck1vZHVsZS5pbnRlcnBvbGF0ZUNvbG9yKGNvbG9yc1sxXSwgY29sb3JzWzJdLCBWLnogKiAyIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JhcGhpY3MuZmlsbFN0eWxlID0gY29sb3JNb2R1bGUuaW50VG9IZXhDb2xvcihjb2xvcik7IC8vZ3JhcGhpY3MuYmVnaW5GaWxsKGNvbG9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGdyYWRpZW50IGJveCBpcyB3ZWlyZCB0byBzZXQgdXAsIHNvIHdlIGxldCBGbGFzaCBzZXQgdXBcclxuICAgICAgICAvLyBhIGJhc2ljIG1hdHJpeCBhbmQgdGhlbiB3ZSBhbHRlciBpdDpcclxuICAgICAgICBtLmNyZWF0ZUdyYWRpZW50Qm94KDEsIDEsIDAsIDAsIDApO1xyXG4gICAgICAgIG0udHJhbnNsYXRlKC0wLjUsIC0wLjUpO1xyXG4gICAgICAgIG0uc2NhbGUoKDEgLyBHLmxlbmd0aCksICgxIC8gRy5sZW5ndGgpKTtcclxuICAgICAgICBtLnJvdGF0ZShNYXRoLmF0YW4yKEcueSwgRy54KSk7XHJcbiAgICAgICAgbS50cmFuc2xhdGUoQy54LCBDLnkpO1xyXG4gICAgICAgIHZhciBhbHBoYXMgPSBfKGNvbG9ycykubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiAxLjA7IH0pO1xyXG4gICAgICAgIHZhciBzcHJlYWQgPSBfKGNvbG9ycykubWFwKGZ1bmN0aW9uIChjLCBpbmRleCkgeyByZXR1cm4gMjU1ICogaW5kZXggLyAoY29sb3JzLmxlbmd0aCAtIDEpOyB9KTtcclxuICAgICAgICAvL2dyYXBoaWNzLmJlZ2luR3JhZGllbnRGaWxsKEdyYWRpZW50VHlwZS5MSU5FQVIsIGNvbG9ycywgYWxwaGFzLCBzcHJlYWQsIG0sIFNwcmVhZE1ldGhvZC5QQUQpO1xyXG4gICAgfVxyXG4gICAgZmlsbEZ1bmN0aW9uKGdyYXBoaWNzLCBmaWxsWCwgZmlsbFkpO1xyXG4gICAgZ3JhcGhpY3MuZmlsbCgpOyAvL2dyYXBoaWNzLmVuZEZpbGwoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlciB0aGUgaW50ZXJpb3Igb2YgcG9seWdvbnNcclxuICovXHJcbmV4cG9ydHMucmVuZGVyUG9seWdvbnMgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIGNvbG9ycywgZ3JhZGllbnRGaWxsUHJvcGVydHksIGNvbG9yT3ZlcnJpZGVGdW5jdGlvbiwgbWFwLCBub2lzeUVkZ2VzKSAge1xyXG4gICAgLy8gTXkgVm9yb25vaSBwb2x5Z29uIHJlbmRlcmluZyBkb2Vzbid0IGhhbmRsZSB0aGUgYm91bmRhcnlcclxuICAgIC8vIHBvbHlnb25zLCBzbyBJIGp1c3QgZmlsbCBldmVyeXRoaW5nIHdpdGggb2NlYW4gZmlyc3QuXHJcbiAgICBncmFwaGljcy5maWxsU3R5bGUgPSBjb2xvck1vZHVsZS5pbnRUb0hleENvbG9yKGNvbG9ycy5PQ0VBTik7XHJcbiAgICBncmFwaGljcy5maWxsUmVjdCgwLCAwLCBjb3JlLnRvSW50KG1hcC5TSVpFLndpZHRoKSwgY29yZS50b0ludChtYXAuU0laRS5oZWlnaHQpKTtcclxuIFxyXG4gICAgdmFyIGRyYXdQYXRoMCA9IGZ1bmN0aW9uIChncmFwaGljcywgeCwgeSkge1xyXG4gICAgICAgIHZhciBwYXRoID0gbm9pc3lFZGdlcy5wYXRoMFtlZGdlLmluZGV4XTtcclxuICAgICAgICBncmFwaGljcy5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgZ3JhcGhpY3MubGluZVRvKHBhdGhbMF0ueCwgcGF0aFswXS55KTtcclxuICAgICAgICBkcmF3UGF0aEZvcndhcmRzKGdyYXBoaWNzLCBwYXRoKTtcclxuICAgICAgICBncmFwaGljcy5saW5lVG8oeCwgeSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBkcmF3UGF0aDEgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIHgsIHkpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IG5vaXN5RWRnZXMucGF0aDFbZWRnZS5pbmRleF07XHJcbiAgICAgICAgZ3JhcGhpY3MubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbyhwYXRoWzBdLngsIHBhdGhbMF0ueSk7XHJcbiAgICAgICAgZHJhd1BhdGhGb3J3YXJkcyhncmFwaGljcywgcGF0aCk7XHJcbiAgICAgICAgZ3JhcGhpY3MubGluZVRvKHgsIHkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmb3IgKHZhciBjZW50ZXJJbmRleCA9IDA7IGNlbnRlckluZGV4IDwgbWFwLmNlbnRlcnMubGVuZ3RoOyBjZW50ZXJJbmRleCsrKSB7XHJcbiAgICAgICAgdmFyIHAgPSBtYXAuY2VudGVyc1tjZW50ZXJJbmRleF07XHJcbiAgICAgICAgZm9yICh2YXIgbmVpZ2hib3JJbmRleCA9IDA7IG5laWdoYm9ySW5kZXggPCBwLm5laWdoYm9ycy5sZW5ndGg7IG5laWdoYm9ySW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgciA9IHAubmVpZ2hib3JzW25laWdoYm9ySW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgZWRnZSA9IG1hcC5sb29rdXBFZGdlRnJvbUNlbnRlcihwLCByKTtcclxuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29yZS5jb2FsZXNjZShjb2xvcnNbcC5iaW9tZV0sIDApO1xyXG4gICAgICAgICAgICBpZiAoY29sb3JPdmVycmlkZUZ1bmN0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yT3ZlcnJpZGVGdW5jdGlvbihjb2xvciwgcCwgciwgZWRnZSwgY29sb3JzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGNvcmUuaXNVbmRlZmluZWRPck51bGwobm9pc3lFZGdlcy5wYXRoMFtlZGdlLmluZGV4XSkgfHwgY29yZS5pc1VuZGVmaW5lZE9yTnVsbChub2lzeUVkZ2VzLnBhdGgxW2VkZ2UuaW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBhdCB0aGUgZWRnZSBvZiB0aGUgbWFwLCB3aGVyZSB3ZSBkb24ndCBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbm9pc3kgZWRnZXMgY29tcHV0ZWQuIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRvXHJcbiAgICAgICAgICAgICAgICAvLyBmaWxsIGluIHRoZXNlIGVkZ2VzIGZyb20gdGhlIHZvcm9ub2kgbGlicmFyeS5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWNvcmUuaXNVbmRlZmluZWRPck51bGwoZ3JhZGllbnRGaWxsUHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSdsbCBkcmF3IHR3byB0cmlhbmdsZXM6IGNlbnRlciAtIGNvcm5lcjAgLVxyXG4gICAgICAgICAgICAgICAgLy8gbWlkcG9pbnQgYW5kIGNlbnRlciAtIG1pZHBvaW50IC0gY29ybmVyMS5cclxuICAgICAgICAgICAgICAgIHZhciBjb3JuZXIwID0gZWRnZS52MDtcclxuICAgICAgICAgICAgICAgIHZhciBjb3JuZXIxID0gZWRnZS52MTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBwaWNrIHRoZSBtaWRwb2ludCBlbGV2YXRpb24vbW9pc3R1cmUgYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgLy8gY29ybmVycyBpbnN0ZWFkIG9mIGJldHdlZW4gcG9seWdvbiBjZW50ZXJzIGJlY2F1c2VcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXN1bHRpbmcgZ3JhZGllbnRzIHRlbmQgdG8gYmUgc21vb3RoZXIuXHJcbiAgICAgICAgICAgICAgICB2YXIgbWlkcG9pbnQgPSBlZGdlLm1pZHBvaW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pZHBvaW50QXR0ciA9IDAuNSAqIChjb3JuZXIwW2dyYWRpZW50RmlsbFByb3BlcnR5XSArIGNvcm5lcjFbZ3JhZGllbnRGaWxsUHJvcGVydHldKTtcclxuICAgICAgICAgICAgICAgIGRyYXdHcmFkaWVudFRyaWFuZ2xlKFxyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlY3RvcjNkLm1ha2UocC5wb2ludC54LCBwLnBvaW50LnksIHBbZ3JhZGllbnRGaWxsUHJvcGVydHldKSxcclxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IzZC5tYWtlKGNvcm5lcjAucG9pbnQueCwgY29ybmVyMC5wb2ludC55LCBjb3JuZXIwW2dyYWRpZW50RmlsbFByb3BlcnR5XSksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yM2QubWFrZShtaWRwb2ludC54LCBtaWRwb2ludC55LCBtaWRwb2ludEF0dHIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFtjb2xvcnMuR1JBRElFTlRfTE9XLCBjb2xvcnMuR1JBRElFTlRfSElHSF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd1BhdGgwLCBwLnBvaW50LngsIHAucG9pbnQueVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGRyYXdHcmFkaWVudFRyaWFuZ2xlKFxyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlY3RvcjNkLm1ha2UocC5wb2ludC54LCBwLnBvaW50LnksIHBbZ3JhZGllbnRGaWxsUHJvcGVydHldKSxcclxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IzZC5tYWtlKG1pZHBvaW50LngsIG1pZHBvaW50LnksIG1pZHBvaW50QXR0ciksXHJcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yM2QubWFrZShjb3JuZXIxLnBvaW50LngsIGNvcm5lcjEucG9pbnQueSwgY29ybmVyMVtncmFkaWVudEZpbGxQcm9wZXJ0eV0pLFxyXG4gICAgICAgICAgICAgICAgICAgIFtjb2xvcnMuR1JBRElFTlRfTE9XLCBjb2xvcnMuR1JBRElFTlRfSElHSF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd1BhdGgxLCBwLnBvaW50LngsIHAucG9pbnQueVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmZpbGxTdHlsZSA9IGNvbG9yTW9kdWxlLmludFRvSGV4Q29sb3IoY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3Muc3Ryb2tlU3R5bGUgPSBncmFwaGljcy5maWxsU3R5bGU7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGRyYXdQYXRoMChncmFwaGljcywgcC5wb2ludC54LCBwLnBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgZHJhd1BhdGgxKGdyYXBoaWNzLCBwLnBvaW50LngsIHAucG9pbnQueSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmZpbGwoKTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlciBicmlkZ2VzIGFjcm9zcyBldmVyeSBuYXJyb3cgcml2ZXIgZWRnZS4gQnJpZGdlcyBhcmVcclxuICogc3RyYWlnaHQgbGluZSBzZWdtZW50cyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBlZGdlLiBCcmlkZ2VzIGFyZVxyXG4gKiBkcmF3biBhZnRlciByaXZlcnMuIFRPRE86IHNvbWV0aW1lcyB0aGUgYnJpZGdlcyBhcmVuJ3QgbG9uZ1xyXG4gKiBlbm91Z2ggdG8gY3Jvc3MgdGhlIGVudGlyZSBub2lzeSBsaW5lIHJpdmVyLiBUT0RPOiBicmlkZ2VzXHJcbiAqIGRvbid0IGxpbmUgdXAgd2l0aCBjdXJ2ZWQgcm9hZCBzZWdtZW50cyB3aGVuIHRoZXJlIGFyZVxyXG4gKiByb2Fkcy4gSXQgbWlnaHQgYmUgd29ydGggbWFraW5nIGEgc2hhZGVyIHRoYXQgZHJhd3MgdGhlIGJyaWRnZVxyXG4gKiBvbmx5IHdoZW4gdGhlcmUncyB3YXRlciB1bmRlcm5lYXRoLlxyXG4gKi9cclxuZXhwb3J0cy5yZW5kZXJCcmlkZ2VzID0gZnVuY3Rpb24gKGdyYXBoaWNzLCBtYXAsIHJvYWRzLCBjb2xvcnMpIHtcclxuICAgIF8obWFwLmVkZ2VzKS5lYWNoKGZ1bmN0aW9uIChlZGdlKSB7XHJcbiAgICAgICAgaWYgKGVkZ2Uucml2ZXIgPiAwICYmIGVkZ2Uucml2ZXIgPCA0ICYmXHJcbiAgICAgICAgICAgICFlZGdlLmQwLndhdGVyICYmICFlZGdlLmQxLndhdGVyICYmXHJcbiAgICAgICAgICAgIChlZGdlLmQwLmVsZXZhdGlvbiA+IDAuMDUgfHwgZWRnZS5kMS5lbGV2YXRpb24gPiAwLjA1KSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG4gPSB7IHg6IC0oZWRnZS52MS5wb2ludC55IC0gZWRnZS52MC5wb2ludC55KSwgeTogZWRnZS52MS5wb2ludC54IC0gZWRnZS52MC5wb2ludC54IH07XHJcbiAgICAgICAgICAgIHBvaW50Q29yZS5ub3JtYWxpemUobiwgMC4yNSArICghXy5pc051bGwocm9hZHMucm9hZFtlZGdlLmluZGV4XSkgPyAwLjUgOiAwKSArIDAuNzUgKiBNYXRoLnNxcnQoZWRnZS5yaXZlcikpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MubGluZVdpZHRoID0gMS4xO1xyXG4gICAgICAgICAgICBncmFwaGljcy5zdHJva2VTdHlsZSA9IGNvbG9yTW9kdWxlLmludFRvSGV4Q29sb3IoY29sb3JzLkJSSURHRSk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVDYXAgPSAnc3F1YXJlJztcclxuICAgICAgICAgICAgZ3JhcGhpY3MubW92ZVRvKGVkZ2UubWlkcG9pbnQueCAtIG4ueCwgZWRnZS5taWRwb2ludC55IC0gbi55KTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MubGluZVRvKGVkZ2UubWlkcG9pbnQueCArIG4ueCwgZWRnZS5taWRwb2ludC55ICsgbi55KTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlciByb2Fkcy4gV2UgZHJhdyB0aGVzZSBiZWZvcmUgcG9seWdvbiBlZGdlcywgc28gdGhhdCByaXZlcnMgb3ZlcndyaXRlIHJvYWRzLlxyXG4gKi9cclxuZXhwb3J0cy5yZW5kZXJSb2FkcyA9IGZ1bmN0aW9uIChncmFwaGljcywgbWFwLCByb2FkcywgY29sb3JzKSB7XHJcbiAgICAvLyBGaXJzdCBkcmF3IHRoZSByb2FkcywgYmVjYXVzZSBhbnkgb3RoZXIgZmVhdHVyZSBzaG91bGQgZHJhd1xyXG4gICAgLy8gb3ZlciB0aGVtLiBBbHNvLCByb2FkcyBkb24ndCB1c2UgdGhlIG5vaXN5IGxpbmVzLlxyXG4gICAgdmFyIEEsIEIsIEM7XHJcbiAgICB2YXIgaSwgaiwgZCwgZWRnZTEsIGVkZ2UyLCBlZGdlcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbjogZmluZCB0aGUgbm9ybWFsIHZlY3RvciBhY3Jvc3MgZWRnZSAnZScgYW5kXHJcbiAgICAgKiBtYWtlIHN1cmUgdG8gcG9pbnQgaXQgaW4gYSBkaXJlY3Rpb24gdG93YXJkcyAnYycuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbFRvd2FyZHMoZSwgYywgbGVuKSB7XHJcbiAgICAgICAgLy8gUm90YXRlIHRoZSB2MC0tPnYxIHZlY3RvciBieSA5MCBkZWdyZWVzOlxyXG4gICAgICAgIHZhciBuID0geyB4OiAtKGUudjEucG9pbnQueSAtIGUudjAucG9pbnQueSksIHk6IGUudjEucG9pbnQueCAtIGUudjAucG9pbnQueCB9O1xyXG4gICAgICAgIC8vIEZsaXAgaXQgYXJvdW5kIGl0IGlmIGRvZXNuJ3QgcG9pbnQgdG93YXJkcyBjXHJcbiAgICAgICAgdmFyIGQgPSBwb2ludENvcmUuc3VidHJhY3QoYywgZS5taWRwb2ludCk7XHJcbiAgICAgICAgaWYgKG4ueCAqIGQueCArIG4ueSAqIGQueSA8IDApIHtcclxuICAgICAgICAgICAgbi54ID0gLW4ueDtcclxuICAgICAgICAgICAgbi55ID0gLW4ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9pbnRDb3JlLm5vcm1hbGl6ZShuLCBsZW4pO1xyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgXyhtYXAuY2VudGVycykuZWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgIGlmICghY29yZS5pc1VuZGVmaW5lZE9yTnVsbChyb2Fkcy5yb2FkQ29ubmVjdGlvbnNbcC5pbmRleF0pKSB7XHJcbiAgICAgICAgICAgIGlmIChyb2Fkcy5yb2FkQ29ubmVjdGlvbnNbcC5pbmRleF0ubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIHJvYWQ6IGRyYXcgYSBzcGxpbmUgZnJvbSBvbmUgZWRnZSB0byB0aGUgb3RoZXIuXHJcbiAgICAgICAgICAgICAgICBlZGdlcyA9IHAuYm9yZGVycztcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UxID0gZWRnZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvYWRzLnJvYWRbZWRnZTEuaW5kZXhdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlMiA9IGVkZ2VzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvYWRzLnJvYWRbZWRnZTIuaW5kZXhdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzcGxpbmUgY29ubmVjdHMgdGhlIG1pZHBvaW50cyBvZiB0aGUgZWRnZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYXQgcmlnaHQgYW5nbGVzIHRvIHRoZW0uIEluIGJldHdlZW4gd2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSB0d28gY29udHJvbCBwb2ludHMgQSBhbmQgQiBhbmQgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCB2ZXJ0ZXggQy4gIFRoaXMgdXN1YWxseSB3b3JrcyBidXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYWx3YXlzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAwLjUgKiBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRDb3JlLmRpc3RhbmNlRnJvbU9yaWdpbihwb2ludENvcmUuc3VidHJhY3QoZWRnZTEubWlkcG9pbnQsIHAucG9pbnQpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRDb3JlLmRpc3RhbmNlRnJvbU9yaWdpbihwb2ludENvcmUuc3VidHJhY3QoZWRnZTIubWlkcG9pbnQsIHAucG9pbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSA9IHBvaW50Q29yZS5hZGQobm9ybWFsVG93YXJkcyhlZGdlMSwgcC5wb2ludCwgZCksIGVkZ2UxLm1pZHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCID0gcG9pbnRDb3JlLmFkZChub3JtYWxUb3dhcmRzKGVkZ2UyLCBwLnBvaW50LCBkKSwgZWRnZTIubWlkcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEMgPSBwb2ludENvcmUuaW50ZXJwb2xhdGUoQSwgQiwgMC41KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5saW5lV2lkdGggPSAxLjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3Muc3Ryb2tlU3R5bGUgPSBjb2xvck1vZHVsZS5pbnRUb0hleENvbG9yKGNvbG9yc1snUk9BRCcgKyByb2Fkcy5yb2FkW2VkZ2UxLmluZGV4XV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLm1vdmVUbyhlZGdlMS5taWRwb2ludC54LCBlZGdlMS5taWRwb2ludC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5xdWFkcmF0aWNDdXJ2ZVRvKEEueCwgQS55LCBDLngsIEMueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MubW92ZVRvKEMueCwgQy55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5saW5lV2lkdGggPSAxLjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3Muc3Ryb2tlU3R5bGUgPSBjb2xvck1vZHVsZS5pbnRUb0hleENvbG9yKGNvbG9yc1snUk9BRCcgKyByb2Fkcy5yb2FkW2VkZ2UyLmluZGV4XV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLnF1YWRyYXRpY0N1cnZlVG8oQi54LCBCLnksIGVkZ2UyLm1pZHBvaW50LngsIGVkZ2UyLm1pZHBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJzZWN0aW9uIG9yIGRlYWQgZW5kOiBkcmF3IGEgcm9hZCBzcGxpbmUgZnJvbVxyXG4gICAgICAgICAgICAgICAgLy8gZWFjaCBlZGdlIHRvIHRoZSBjZW50ZXJcclxuICAgICAgICAgICAgICAgIF8ocC5ib3JkZXJzKS5lYWNoKGZ1bmN0aW9uIChlZGdlMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb2Fkcy5yb2FkW2VkZ2UxLmluZGV4XSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IDAuMjUgKiBwb2ludENvcmUuZGlzdGFuY2VGcm9tT3JpZ2luKHBvaW50Q29yZS5zdWJ0cmFjdChlZGdlMS5taWRwb2ludCwgcC5wb2ludCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBBID0gcG9pbnRDb3JlLmFkZChub3JtYWxUb3dhcmRzKGVkZ2UxLCBwLnBvaW50LCBkKSwgZWRnZTEubWlkcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MubGluZVdpZHRoID0gMS40O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5zdHJva2VTdHlsZSA9IGNvbG9yTW9kdWxlLmludFRvSGV4Q29sb3IoY29sb3JzWydST0FEJyArIHJvYWRzLnJvYWRbZWRnZTEuaW5kZXhdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWNzLm1vdmVUbyhlZGdlMS5taWRwb2ludC54LCBlZGdlMS5taWRwb2ludC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MucXVhZHJhdGljQ3VydmVUbyhBLngsIEEueSwgcC5wb2ludC54LCBwLnBvaW50LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljcy5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY3MuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGRyYXdQYXRoQmFja3dhcmRzKGdyYXBoaWNzLCBwYXRoKSB7XHJcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlIChpID49IDApIHtcclxuICAgICAgICBncmFwaGljcy5saW5lVG8ocGF0aFtpXS54LCBwYXRoW2ldLnkpO1xyXG4gICAgICAgIGktLTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlciB0aGUgZXh0ZXJpb3Igb2YgcG9seWdvbnM6IGNvYXN0bGluZXMsIGxha2Ugc2hvcmVzLFxyXG4gKiByaXZlcnMsIGxhdmEgZmlzc3VyZXMuIFdlIGRyYXcgYWxsIG9mIHRoZXNlIGFmdGVyIHRoZSBwb2x5Z29uc1xyXG4gKiBzbyB0aGF0IHBvbHlnb25zIGRvbid0IG92ZXJ3cml0ZSBhbnkgZWRnZXMuXHJcbiAqL1xyXG5leHBvcnRzLnJlbmRlckVkZ2VzID0gZnVuY3Rpb24gKGdyYXBoaWNzLCBjb2xvcnMsIG1hcCwgbm9pc3lFZGdlcywgbGF2YSwgcmVuZGVyUml2ZXJzKSB7XHJcbiAgICByZW5kZXJSaXZlcnMgPSBjb3JlLmRlZihyZW5kZXJSaXZlcnMsIHRydWUpO1xyXG4gICAgdmFyIGVkZ2U7XHJcbiAgICBcclxuICAgIGZvciAodmFyIGNlbnRlckluZGV4ID0gMDsgY2VudGVySW5kZXggPCBtYXAuY2VudGVycy5sZW5ndGg7IGNlbnRlckluZGV4KyspIHtcclxuICAgICAgICB2YXIgcCA9IG1hcC5jZW50ZXJzW2NlbnRlckluZGV4XTtcclxuICAgICAgICBmb3IgKHZhciBuZWlnaGJvckluZGV4ID0gMDsgbmVpZ2hib3JJbmRleCA8IHAubmVpZ2hib3JzLmxlbmd0aDsgbmVpZ2hib3JJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gcC5uZWlnaGJvcnNbbmVpZ2hib3JJbmRleF07XHJcbiAgICAgICAgICAgIGVkZ2UgPSBtYXAubG9va3VwRWRnZUZyb21DZW50ZXIocCwgcik7XHJcbiAgICAgICAgICAgIGlmIChjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKG5vaXN5RWRnZXMucGF0aDBbZWRnZS5pbmRleF0pIHx8IGNvcmUuaXNVbmRlZmluZWRPck51bGwobm9pc3lFZGdlcy5wYXRoMVtlZGdlLmluZGV4XSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0J3MgYXQgdGhlIGVkZ2Ugb2YgdGhlIG1hcFxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHAub2NlYW4gIT09IHIub2NlYW4pIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBzaWRlIGlzIG9jZWFuIGFuZCB0aGUgb3RoZXIgc2lkZSBpcyBsYW5kIC0tIGNvYXN0bGluZVxyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MubGluZVdpZHRoID0gMjtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZVN0eWxlID0gY29sb3JNb2R1bGUuaW50VG9IZXhDb2xvcihjb2xvcnMuQ09BU1QpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjb252ZXJ0LmludEZyb21Cb29sZWFuKHAud2F0ZXIpID4gMCkgIT09IChjb252ZXJ0LmludEZyb21Cb29sZWFuKHIud2F0ZXIpID4gMCkgJiYgcC5iaW9tZSAhPT0gJ0lDRScgJiYgci5iaW9tZSAhPT0gJ0lDRScpIHtcclxuICAgICAgICAgICAgICAgIC8vIExha2UgYm91bmRhcnlcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5zdHJva2VTdHlsZSA9IGNvbG9yTW9kdWxlLmludFRvSGV4Q29sb3IoY29sb3JzLkxBS0VTSE9SRSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocC53YXRlciB8fCByLndhdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMYWtlIGludGVyaW9yIOKAkyB3ZSBkb24ndCB3YW50IHRvIGRyYXcgdGhlIHJpdmVycyBoZXJlXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXZhLmxhdmFbZWRnZS5pbmRleF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIExhdmEgZmxvd1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3MubGluZVdpZHRoID0gMTtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzLnN0cm9rZVN0eWxlID0gY29sb3JNb2R1bGUuaW50VG9IZXhDb2xvcihjb2xvcnMuTEFWQSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWRnZS5yaXZlciA+IDAgJiYgcmVuZGVyUml2ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaXZlciBlZGdlXHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5saW5lV2lkdGggPSBNYXRoLnNxcnQoZWRnZS5yaXZlcik7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5zdHJva2VTdHlsZSA9IGNvbG9yTW9kdWxlLmludFRvSGV4Q29sb3IoY29sb3JzLlJJVkVSKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBncmFwaGljcy5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MubW92ZVRvKG5vaXN5RWRnZXMucGF0aDBbZWRnZS5pbmRleF1bMF0ueCwgbm9pc3lFZGdlcy5wYXRoMFtlZGdlLmluZGV4XVswXS55KTtcclxuICAgICAgICAgICAgZHJhd1BhdGhGb3J3YXJkcyhncmFwaGljcywgbm9pc3lFZGdlcy5wYXRoMFtlZGdlLmluZGV4XSk7XHJcbiAgICAgICAgICAgIGRyYXdQYXRoQmFja3dhcmRzKGdyYXBoaWNzLCBub2lzeUVkZ2VzLnBhdGgxW2VkZ2UuaW5kZXhdKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3Muc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydHMucmVuZGVyQWxsRWRnZXMgPSBmdW5jdGlvbiAoZ3JhcGhpY3MsIHN0cm9rZVN0eWxlLCBtYXAsIG5vaXN5RWRnZXMpIHtcclxuICAgIHZhciBlZGdlO1xyXG5cclxuICAgIGdyYXBoaWNzLmxpbmVXaWR0aCA9IDU7XHJcbiAgICBncmFwaGljcy5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xyXG5cclxuICAgIGZvciAodmFyIGNlbnRlckluZGV4ID0gMDsgY2VudGVySW5kZXggPCBtYXAuY2VudGVycy5sZW5ndGg7IGNlbnRlckluZGV4KyspIHtcclxuICAgICAgICB2YXIgcCA9IG1hcC5jZW50ZXJzW2NlbnRlckluZGV4XTtcclxuICAgICAgICBmb3IgKHZhciBuZWlnaGJvckluZGV4ID0gMDsgbmVpZ2hib3JJbmRleCA8IHAubmVpZ2hib3JzLmxlbmd0aDsgbmVpZ2hib3JJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gcC5uZWlnaGJvcnNbbmVpZ2hib3JJbmRleF07XHJcbiAgICAgICAgICAgIGVkZ2UgPSBtYXAubG9va3VwRWRnZUZyb21DZW50ZXIocCwgcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29yZS5pc1VuZGVmaW5lZE9yTnVsbChub2lzeUVkZ2VzLnBhdGgwW2VkZ2UuaW5kZXhdKSB8fCBjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKG5vaXN5RWRnZXMucGF0aDFbZWRnZS5pbmRleF0pIHx8IHAud2F0ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIEl0J3MgYXQgdGhlIGVkZ2Ugb2YgdGhlIG1hcCBvciB3YXRlclxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGVkZ2VcclxuXHJcbiAgICAgICAgICAgIGdyYXBoaWNzLmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5tb3ZlVG8obm9pc3lFZGdlcy5wYXRoMFtlZGdlLmluZGV4XVswXS54LCBub2lzeUVkZ2VzLnBhdGgwW2VkZ2UuaW5kZXhdWzBdLnkpO1xyXG4gICAgICAgICAgICBkcmF3UGF0aEZvcndhcmRzKGdyYXBoaWNzLCBub2lzeUVkZ2VzLnBhdGgwW2VkZ2UuaW5kZXhdKTtcclxuICAgICAgICAgICAgZHJhd1BhdGhCYWNrd2FyZHMoZ3JhcGhpY3MsIG5vaXN5RWRnZXMucGF0aDFbZWRnZS5pbmRleF0pO1xyXG4gICAgICAgICAgICBncmFwaGljcy5zdHJva2UoKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MuY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5kZXg6IG51bGwsXHJcbiAgICAgIFxyXG4gICAgICAgIHBvaW50OiBudWxsLCAgICAgICAgLy8gUG9pbnQgbG9jYXRpb25cclxuICAgICAgICB3YXRlcjogbnVsbCwgICAgICAgIC8vIGxha2Ugb3Igb2NlYW5cclxuICAgICAgICBvY2VhbjogbnVsbCwgICAgICAgIC8vIG9jZWFuXHJcbiAgICAgICAgY29hc3Q6IG51bGwsICAgICAgICAvLyBsYW5kIHBvbHlnb24gdG91Y2hpbmcgYW4gb2NlYW5cclxuICAgICAgICBib3JkZXI6IG51bGwsICAgICAgIC8vIGF0IHRoZSBlZGdlIG9mIHRoZSBtYXBcclxuICAgICAgICBiaW9tZTogbnVsbCwgICAgICAgICAgLy8gYmlvbWUgdHlwZSAoc2VlIGFydGljbGUpXHJcbiAgICAgICAgZWxldmF0aW9uOiBudWxsLCAgICAgLy8gMC4wLTEuMFxyXG4gICAgICAgIG1vaXN0dXJlOiBudWxsLCAgICAgIC8vIDAuMC0xLjBcclxuXHJcbiAgICAgICAgbmVpZ2hib3JzOiBudWxsLCAgICAvLyBWZWN0b3I8Q2VudGVyPlxyXG4gICAgICAgIGJvcmRlcnM6IG51bGwsICAgICAgLy8gVmVjdG9yPEVkZ2U+XHJcbiAgICAgICAgY29ybmVyczogbnVsbCAgICAgICAvLyBWZWN0b3I8Q29ybmVyPlxyXG4gICAgfTtcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5kZXg6IG51bGwsXHJcbiAgICAgIFxyXG4gICAgICAgIHBvaW50OiBudWxsLCAgLy8gbG9jYXRpb25cclxuICAgICAgICBvY2VhbjogbnVsbCwgIC8vIG9jZWFuXHJcbiAgICAgICAgd2F0ZXI6IG51bGwsICAvLyBsYWtlIG9yIG9jZWFuXHJcbiAgICAgICAgY29hc3Q6IG51bGwsICAvLyB0b3VjaGVzIG9jZWFuIGFuZCBsYW5kIHBvbHlnb25zXHJcbiAgICAgICAgYm9yZGVyOiBudWxsLCAgLy8gYXQgdGhlIGVkZ2Ugb2YgdGhlIG1hcFxyXG4gICAgICAgIGVsZXZhdGlvbjogbnVsbCwgIC8vIDAuMC0xLjBcclxuICAgICAgICBtb2lzdHVyZTogbnVsbCwgIC8vIDAuMC0xLjBcclxuXHJcbiAgICAgICAgdG91Y2hlczogbnVsbCxcclxuICAgICAgICBwcm90cnVkZXM6IG51bGwsXHJcbiAgICAgICAgYWRqYWNlbnQ6IG51bGwsXHJcbiAgICAgIFxyXG4gICAgICAgIHJpdmVyOiBudWxsLCAgLy8gMCBpZiBubyByaXZlciwgb3Igdm9sdW1lIG9mIHdhdGVyIGluIHJpdmVyXHJcbiAgICAgICAgZG93bnNsb3BlOiBudWxsLCAgLy8gcG9pbnRlciB0byBhZGphY2VudCBjb3JuZXIgbW9zdCBkb3duaGlsbFxyXG4gICAgICAgIHdhdGVyc2hlZDogbnVsbCwgIC8vIHBvaW50ZXIgdG8gY29hc3RhbCBjb3JuZXIsIG9yIG51bGxcclxuICAgICAgICB3YXRlcnNoZWRTaXplOiBudWxsXHJcbiAgICB9O1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbmRleDogMCxcclxuICAgICAgICBkMDogbnVsbCwgIC8vIERlbGF1bmF5IGVkZ2VcclxuICAgICAgICBkMTogbnVsbCwgIC8vIERlbGF1bmF5IGVkZ2VcclxuICAgICAgICB2MDogbnVsbCwgIC8vIFZvcm9ub2kgZWRnZVxyXG4gICAgICAgIHYxOiBudWxsLCAgLy8gVm9yb25vaSBlZGdlXHJcbiAgICAgICAgbWlkcG9pbnQ6IG51bGwsICAvLyBoYWxmd2F5IGJldHdlZW4gdjAsdjFcclxuICAgICAgICByaXZlcjogMCAgLy8gdm9sdW1lIG9mIHdhdGVyLCBvciAwXHJcbiAgICB9O1xyXG59OyIsIi8qIGpzaGludCBiaXR3aXNlOmZhbHNlICovXHJcblxyXG4vKipcclxuICogRmFjdG9yeSBjbGFzcyB0byBidWlsZCB0aGUgJ2luc2lkZScgZnVuY3Rpb24gdGhhdCB0ZWxscyB1cyB3aGV0aGVyXHJcbiAqIGEgcG9pbnQgc2hvdWxkIGJlIG9uIHRoZSBpc2xhbmQgb3IgaW4gdGhlIHdhdGVyLlxyXG4gKiBcclxuICogVGhpcyBjbGFzcyBoYXMgZmFjdG9yeSBmdW5jdGlvbnMgZm9yIGdlbmVyYXRpbmcgaXNsYW5kcyBvZlxyXG4gKiBkaWZmZXJlbnQgc2hhcGVzLiBUaGUgZmFjdG9yeSByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhXHJcbiAqIG5vcm1hbGl6ZWQgcG9pbnQgKHggYW5kIHkgYXJlIC0xIHRvICsxKSBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZVxyXG4gKiBwb2ludCBzaG91bGQgYmUgb24gdGhlIGlzbGFuZCwgYW5kIGZhbHNlIGlmIGl0IHNob3VsZCBiZSB3YXRlclxyXG4gKiAobGFrZSBvciBvY2VhbikuXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGFycmF5MmQgPSByZXF1aXJlKCcuLi9qYW5pY2VrL2FycmF5MmQnKTtcclxudmFyIGNvcmUgPSByZXF1aXJlKCcuLi9qYW5pY2VrL2NvcmUnKTtcclxudmFyIGRpc3RhbmNlRnJvbU9yaWdpbiA9IHJlcXVpcmUoJy4uL2FzMy9wb2ludC1jb3JlJykuZGlzdGFuY2VGcm9tT3JpZ2luO1xyXG52YXIgcGVybGluTm9pc2UgPSByZXF1aXJlKCcuLi9qYW5pY2VrL3Blcmxpbi1ub2lzZScpO1xyXG52YXIgcHJuZ01vZHVsZSA9IHJlcXVpcmUoJy4uL3BvbHlnb25hbC9wbS1wcm5nJyk7XHJcbnZhciBwcm5nID0gcmVxdWlyZSgnLi4vamFuaWNlay9wc2V1ZG8tcmFuZG9tLW51bWJlci1nZW5lcmF0b3JzJyk7XHJcblxyXG4vKipcclxuKiBUaGUgcmFkaWFsIGlzbGFuZCByYWRpdXMgaXMgYmFzZWQgb24gb3ZlcmxhcHBpbmcgc2luZSB3YXZlcyBcclxuKiBAcGFyYW0gc2VlZFxyXG4qIEBwYXJhbSBpc2xhbmRGYWN0b3IgPSAxLjAgbWVhbnMgbm8gc21hbGwgaXNsYW5kczsgMi4wIGxlYWRzIHRvIGEgbG90XHJcbiovXHJcbmV4cG9ydHMubWFrZVJhZGlhbCA9IGZ1bmN0aW9uIChzZWVkLCBpc2xhbmRGYWN0b3IpIHtcclxuICAgIGlzbGFuZEZhY3RvciA9IGNvcmUuZGVmKGlzbGFuZEZhY3RvciwgMS4wNyk7XHJcblxyXG4gICAgdmFyIGlzbGFuZFJhbmRvbSA9IHBybmdNb2R1bGUoKTtcclxuICAgIGlzbGFuZFJhbmRvbS5zZWVkID0gc2VlZDtcclxuICAgIHZhciBidW1wcyA9IGlzbGFuZFJhbmRvbS5uZXh0SW50UmFuZ2UoMSwgNik7XHJcbiAgICB2YXIgc3RhcnRBbmdsZSA9IGlzbGFuZFJhbmRvbS5uZXh0RG91YmxlUmFuZ2UoMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgdmFyIGRpcEFuZ2xlID0gaXNsYW5kUmFuZG9tLm5leHREb3VibGVSYW5nZSgwLCAyICogTWF0aC5QSSk7XHJcbiAgICB2YXIgZGlwV2lkdGggPSBpc2xhbmRSYW5kb20ubmV4dERvdWJsZVJhbmdlKDAuMiwgMC43KTtcclxuXHJcbiAgICBmdW5jdGlvbiBpbnNpZGUocSkge1xyXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIocS55LCBxLngpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSAwLjUgKiAoTWF0aC5tYXgoTWF0aC5hYnMocS54KSwgTWF0aC5hYnMocS55KSkgKyBkaXN0YW5jZUZyb21PcmlnaW4ocSkpO1xyXG5cclxuICAgICAgICB2YXIgcjEgPSAwLjUgKyAwLjQwICogTWF0aC5zaW4oc3RhcnRBbmdsZSArIGJ1bXBzICogYW5nbGUgKyBNYXRoLmNvcygoYnVtcHMgKyAzKSAqIGFuZ2xlKSk7XHJcbiAgICAgICAgdmFyIHIyID0gMC43IC0gMC4yMCAqIE1hdGguc2luKHN0YXJ0QW5nbGUgKyBidW1wcyAqIGFuZ2xlIC0gTWF0aC5zaW4oKGJ1bXBzICsgMikgKiBhbmdsZSkpO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhhbmdsZSAtIGRpcEFuZ2xlKSA8IGRpcFdpZHRoIHx8XHJcbiAgICAgICAgICAgIE1hdGguYWJzKGFuZ2xlIC0gZGlwQW5nbGUgKyAyICogTWF0aC5QSSkgPCBkaXBXaWR0aCB8fFxyXG4gICAgICAgICAgICBNYXRoLmFicyhhbmdsZSAtIGRpcEFuZ2xlIC0gMiAqIE1hdGguUEkpIDwgZGlwV2lkdGgpIHtcclxuICAgICAgICAgICAgcjEgPSByMiA9IDAuMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICAobGVuZ3RoIDwgcjEgfHwgKGxlbmd0aCA+IHIxICogaXNsYW5kRmFjdG9yICYmIGxlbmd0aCA8IHIyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluc2lkZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgUGVybGluLWJhc2VkIGlzbGFuZCBjb21iaW5lcyBwZXJsaW4gbm9pc2Ugd2l0aCB0aGUgcmFkaXVzLlxyXG4gKiBAcGFyYW0gICBzZWVkXHJcbiAqIEBwYXJhbSAgIG9jZWFuUmF0aW8gMCA9IGxlYXN0IG9jZWFuLCAxID0gbW9zdCBvY2VhblxyXG4gKi9cclxuZXhwb3J0cy5tYWtlUGVybGluID0gZnVuY3Rpb24gKHNlZWQsIG9jZWFuUmF0aW8pIHtcclxuICAgIG9jZWFuUmF0aW8gPSBjb3JlLmRlZihvY2VhblJhdGlvLCAwLjUpO1xyXG5cclxuICAgIHZhciBsYW5kUmF0aW9NaW5pbXVtID0gMC4xO1xyXG4gICAgdmFyIGxhbmRSYXRpb01heGltdW0gPSAwLjU7XHJcbiAgICBvY2VhblJhdGlvID0gKChsYW5kUmF0aW9NYXhpbXVtIC0gbGFuZFJhdGlvTWluaW11bSkgKiBvY2VhblJhdGlvKSArIGxhbmRSYXRpb01pbmltdW07ICAvL21pbjogMC4xIG1heDogMC41XHJcbiAgICB2YXIgcGVybGluID0gYXJyYXkyZChwZXJsaW5Ob2lzZS5tYWtlUGVybGluTm9pc2UoMjU2LCAyNTYsIDEuMCwgMS4wLCAxLjAsIHNlZWQsIDgpKTtcclxuICAgIC8vcGVybGluLnBlcmxpbk5vaXNlKDY0LCA2NCwgOCwgc2VlZCwgZmFsc2UsIHRydWUpOyAvL21hcGdlbjJcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICB2YXIgYyA9IChwZXJsaW4uZ2V0KGNvcmUudG9JbnQoKHEueCArIDEpICogMTI4KSwgY29yZS50b0ludCgocS55ICsgMSkgKiAxMjgpKSAmIDB4ZmYpIC8gMjU1LjA7XHJcbiAgICAgICAgLy92YXIgYzpOdW1iZXIgPSAocGVybGluLmdldFBpeGVsKFN0ZC5pbnQoKHEueCsxKSoxMjgpLCBTdGQuaW50KChxLnkrMSkqMTI4KSkgJiAweGZmKSAvIDI1NS4wOyAvL21hcGdlbjJcclxuICAgICAgICByZXR1cm4gYyA+IChvY2VhblJhdGlvICsgb2NlYW5SYXRpbyAqIGRpc3RhbmNlRnJvbU9yaWdpbihxKSAqIGRpc3RhbmNlRnJvbU9yaWdpbihxKSk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBzcXVhcmUgc2hhcGUgZmlsbHMgdGhlIGVudGlyZSBzcGFjZSB3aXRoIGxhbmRcclxuICovXHJcbmV4cG9ydHMubWFrZVNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4qIFRoZSBibG9iIGlzbGFuZCBpcyBzaGFwZWQgbGlrZSBBbWl0J3MgYmxvYiBsb2dvXHJcbiovXHJcbmV4cG9ydHMubWFrZUJsb2IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICB2YXIgZXllMSA9IGRpc3RhbmNlRnJvbU9yaWdpbih7IHg6IHEueCAtIDAuMiwgeTogcS55IC8gMiArIDAuMiB9KSA8IDAuMDU7XHJcbiAgICAgICAgdmFyIGV5ZTIgPSBkaXN0YW5jZUZyb21PcmlnaW4oeyB4OiBxLnggKyAwLjIsIHk6IHEueSAvIDIgKyAwLjIgfSkgPCAwLjA1O1xyXG4gICAgICAgIHZhciBib2R5ID0gZGlzdGFuY2VGcm9tT3JpZ2luKHEpIDwgMC44IC0gMC4xOCAqIE1hdGguc2luKDUgKiBNYXRoLmF0YW4yKHEueSwgcS54KSk7XHJcbiAgICAgICAgcmV0dXJuIGJvZHkgJiYgIWV5ZTEgJiYgIWV5ZTI7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1ha2UgaXNsYW5kIGZyb20gYml0bWFwLlxyXG4gKiBAcGFyYW0ge1tbYm9vbGVhbl1dfSBiaXRtYXBcclxuICovXHJcbmV4cG9ydHMubWFrZUJpdG1hcCA9IGZ1bmN0aW9uIChiaXRtYXApIHtcclxuICAgIGJpdG1hcCA9IGFycmF5MmQoYml0bWFwKTtcclxuICAgIHZhciBkaW1lbnNpb25zID0gYml0bWFwLmRpbWVuc2lvbnMoKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocSkge1xyXG4gICAgICAgIHZhciB4ID0gKChxLnggKyAxKSAvIDIpICogZGltZW5zaW9ucy54O1xyXG4gICAgICAgIHZhciB5ID0gKChxLnkgKyAxKSAvIDIpICogZGltZW5zaW9ucy55O1xyXG4gICAgICAgIHJldHVybiBiaXRtYXAuZ2V0KHgsIHkpO1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlIGlzbGFuZCBmcm9tIHNpbXBsZSBub2lzZS5cclxuICovXHJcbmV4cG9ydHMubWFrZU5vaXNlID0gZnVuY3Rpb24gKHNlZWQpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAocSkge1xyXG4gICAgICAgIHNlZWQgPSBwcm5nLm5leHRQYXJrTWlsbGVyKHNlZWQpO1xyXG4gICAgICAgIHJldHVybiBwcm5nLnRvQm9vbChzZWVkKTtcclxuICAgIH07XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIGNjID0gcmVxdWlyZSgnLi4vYXMzL2NvbnZlcnNpb24tY29yZScpO1xyXG5cclxuZXhwb3J0cy5GUkFDVElPTl9MQVZBX0ZJU1NVUkVTID0gMC4yOyAgLy8gMCB0byAxLCBwcm9iYWJpbGl0eSBvZiBmaXNzdXJlXHJcblxyXG5leHBvcnRzLm1ha2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgICAgICAvLyBUaGUgbGF2YSBhcnJheSBtYXJrcyB0aGUgZWRnZXMgdGhhdCBoYXZhIGxhdmEuXHJcbiAgICAgICAgbGF2YTogW10sIC8vIEFycmF5PEJvb2xlYW4+IGVkZ2UgaW5kZXggLT4gQm9vbGVhblxyXG5cclxuICAgICAgICAvLyBMYXZhIGZpc3N1cmVzIGFyZSBhdCBoaWdoIGVsZXZhdGlvbnMgd2hlcmUgbW9pc3R1cmUgaXMgbG93XHJcbiAgICAgICAgY3JlYXRlTGF2YTogZnVuY3Rpb24gKG1hcCwgcmFuZG9tRG91YmxlKSB7XHJcbiAgICAgICAgICAgIF8obWFwLmVkZ2VzKS5lYWNoKGZ1bmN0aW9uIChlZGdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNjLmJvb2xlYW5Gcm9tSW50KGVkZ2Uucml2ZXIpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWVkZ2UuZDAud2F0ZXIgJiYgIWVkZ2UuZDEud2F0ZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmQwLmVsZXZhdGlvbiA+IDAuOCAmJiBlZGdlLmQxLmVsZXZhdGlvbiA+IDAuOCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UuZDAubW9pc3R1cmUgPCAwLjMgJiYgZWRnZS5kMS5tb2lzdHVyZSA8IDAuMyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmRvbURvdWJsZSgpIDwgZXhwb3J0cy5GUkFDVElPTl9MQVZBX0ZJU1NVUkVTKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF2YVtlZGdlLmluZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XHJcbnZhciBjZW50ZXJNb2R1bGUgPSByZXF1aXJlKCcuL2dyYXBoL2NlbnRlcicpO1xyXG52YXIgY29udmVydCA9IHJlcXVpcmUoJy4uL2FzMy9jb252ZXJzaW9uLWNvcmUnKTtcclxudmFyIGNvcm5lck1vZHVsZSA9IHJlcXVpcmUoJy4vZ3JhcGgvY29ybmVyJyk7XHJcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vamFuaWNlay9jb3JlJyk7XHJcbnZhciBlZGdlTW9kdWxlID0gcmVxdWlyZSgnLi9ncmFwaC9lZGdlJyk7XHJcbnZhciBwcm5nID0gcmVxdWlyZSgnLi4vcG9seWdvbmFsL3BtLXBybmcnKTtcclxudmFyIHBjID0gcmVxdWlyZSgnLi4vYXMzL3BvaW50LWNvcmUnKTtcclxudmFyIHJlY3RhbmdsZSA9IHJlcXVpcmUoJy4uL2FzMy9yZWN0YW5nbGUnKTtcclxudmFyIHZvcm9ub2lNb2R1bGUgPSByZXF1aXJlKCcuLi9ub2RlbmFtZS9kZWxhdW5heS92b3Jvbm9pJyk7XHJcblxyXG5leHBvcnRzLkRFRkFVTFRfTEFLRV9USFJFU0hPTEQgPSAwLjM7XHJcbmV4cG9ydHMuREVGQVVMVF9MTE9ZRF9JVEVSQVRJT05TID0gMjtcclxuZXhwb3J0cy5ERUZBVUxUX05VTUJFUl9PRl9QT0lOVFMgPSAxMDAwO1xyXG5cclxuLyoqXHJcbiAqIE1ha2UgYSBuZXcgbWFwLlxyXG4gKiBAcGFyYW0gICBzaXplIHdpZHRoIGFuZCBoZWlnaHQgb2YgbWFwXHJcbiAqIEBwYXJhbSAgIHJpdmVyQ2hhbmNlIDAgPSBubyByaXZlcnMsID4gMCA9IG1vcmUgcml2ZXJzLCBkZWZhdWx0ID0gbWFwIGFyZWEgLyA0XHJcbiAqL1xyXG5leHBvcnRzLm1ha2UgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgdmFyIHB1YiA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFzc2VkIGluIGJ5IHRoZSBjYWxsZXI6XHJcbiAgICAgKi9cclxuICAgIHB1Yi5TSVpFID0gc2l6ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElzbGFuZCBzaGFwZSBpcyBjb250cm9sbGVkIGJ5IHRoZSBpc2xhbmRSYW5kb20gc2VlZCBhbmQgdGhlXHJcbiAgICAgKiB0eXBlIG9mIGlzbGFuZCwgcGFzc2VkIGluIHdoZW4gd2Ugc2V0IHRoZSBpc2xhbmQgc2hhcGUuIFRoZVxyXG4gICAgICogaXNsYW5kU2hhcGUgZnVuY3Rpb24gdXNlcyBib3RoIG9mIHRoZW0gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW55XHJcbiAgICAgKiBwb2ludCBzaG91bGQgYmUgd2F0ZXIgb3IgbGFuZC5cclxuICAgICAqL1xyXG4gICAgcHViLmlzbGFuZFNoYXBlID0gbnVsbDtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJc2xhbmQgZGV0YWlscyBhcmUgY29udHJvbGxlZCBieSB0aGlzIHJhbmRvbSBnZW5lcmF0b3IuIFRoZVxyXG4gICAgICogaW5pdGlhbCBtYXAgdXBvbiBsb2FkaW5nIGlzIGFsd2F5cyBkZXRlcm1pbmlzdGljLCBidXRcclxuICAgICAqIHN1YnNlcXVlbnQgbWFwcyByZXNldCB0aGlzIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHdpdGggYVxyXG4gICAgICogcmFuZG9tIHNlZWQuXHJcbiAgICAgKi9cclxuICAgIHB1Yi5tYXBSYW5kb20gPSBwcm5nKCk7XHJcblxyXG4gICAgLy8gVGhlc2Ugc3RvcmUgdGhlIGdyYXBoIGRhdGFcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHVzZWZ1bCBkdXJpbmcgbWFwIGNvbnN0cnVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWIucG9pbnRzID0gW107IC8vIFZlY3RvcjxQb2ludD5cclxuICAgIHB1Yi5jZW50ZXJzID0gW107IC8vIFZlY3RvcjxDZW50ZXI+XHJcbiAgICBwdWIuY29ybmVycyA9IFtdOyAvLyBWZWN0b3I8Q29ybmVyPlxyXG4gICAgcHViLmVkZ2VzID0gW107IC8vIFZlY3RvcjxFZGdlPlxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJhbmRvbSBwYXJhbWV0ZXJzIGdvdmVybmluZyB0aGUgb3ZlcmFsbCBzaGFwZSBvZiB0aGUgaXNsYW5kXHJcbiAgICAgKi9cclxuICAgIHB1Yi5uZXdJc2xhbmQgPSBmdW5jdGlvbiAoaXNsYW5kU2hhcGUsIHZhcmlhbnQpIHtcclxuICAgICAgICBwdWIuaXNsYW5kU2hhcGUgPSBpc2xhbmRTaGFwZTtcclxuICAgICAgICBwdWIubWFwUmFuZG9tLnNlZWQgPSB2YXJpYW50O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIHRoZSBpbml0aWFsIHJhbmRvbSBzZXQgb2YgcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBwdWIuZ28wUGxhY2VQb2ludHMgPSBmdW5jdGlvbiAobnVtYmVyT2ZQb2ludHMpIHtcclxuICAgICAgICBudW1iZXJPZlBvaW50cyA9IGNvcmUuZGVmKG51bWJlck9mUG9pbnRzLCBleHBvcnRzLkRFRkFVTFRfTlVNQkVSX09GX1BPSU5UUyk7XHJcbiAgICAgICAgcHViLnJlc2V0KCk7XHJcbiAgICAgICAgcHViLnBvaW50cyA9IHB1Yi5nZW5lcmF0ZVJhbmRvbVBvaW50cyhudW1iZXJPZlBvaW50cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5nbzFJbXByb3ZlUG9pbnRzID0gZnVuY3Rpb24gKG51bUxsb3lkSXRlcmF0aW9ucykge1xyXG4gICAgICAgIG51bUxsb3lkSXRlcmF0aW9ucyA9IGNvcmUuZGVmKG51bUxsb3lkSXRlcmF0aW9ucywgZXhwb3J0cy5ERUZBVUxUX0xMT1lEX0lURVJBVElPTlMpO1xyXG4gICAgICAgIHB1Yi5pbXByb3ZlUmFuZG9tUG9pbnRzKHB1Yi5wb2ludHMsIG51bUxsb3lkSXRlcmF0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgZ3JhcGggc3RydWN0dXJlIGZyb20gdGhlIFZvcm9ub2kgZWRnZSBsaXN0LiBUaGVcclxuICAgICAqIG1ldGhvZHMgaW4gdGhlIFZvcm9ub2kgb2JqZWN0IGFyZSBzb21ld2hhdCBpbmNvbnZlbmllbnQgZm9yXHJcbiAgICAgKiBteSBuZWVkcywgc28gSSB0cmFuc2Zvcm0gdGhhdCBkYXRhIGludG8gdGhlIGRhdGEgSSBhY3R1YWxseVxyXG4gICAgICogbmVlZDogZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBEZWxhdW5heSB0cmlhbmdsZXMgYW5kIHRoZVxyXG4gICAgICogVm9yb25vaSBwb2x5Z29ucywgYSByZXZlcnNlIG1hcCBmcm9tIHRob3NlIGZvdXIgcG9pbnRzIGJhY2tcclxuICAgICAqIHRvIHRoZSBlZGdlLCBhIG1hcCBmcm9tIHRoZXNlIGZvdXIgcG9pbnRzIHRvIHRoZSBwb2ludHNcclxuICAgICAqIHRoZXkgY29ubmVjdCB0byAoYm90aCBhbG9uZyB0aGUgZWRnZSBhbmQgY3Jvc3N3aXNlKS5cclxuICAgICAqL1xyXG4gICAgcHViLmdvMkJ1aWxkR3JhcGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZvcm9ub2kgPSB2b3Jvbm9pTW9kdWxlLm1ha2UocHViLnBvaW50cywgbnVsbCwgcmVjdGFuZ2xlKDAsIDAsIHB1Yi5TSVpFLndpZHRoLCBwdWIuU0laRS5oZWlnaHQpKTtcclxuICAgICAgICBwdWIuYnVpbGRHcmFwaChwdWIucG9pbnRzLCB2b3Jvbm9pKTtcclxuICAgICAgICBwdWIuaW1wcm92ZUNvcm5lcnMoKTtcclxuICAgICAgICB2b3Jvbm9pLmRpc3Bvc2UoKTtcclxuICAgICAgICB2b3Jvbm9pID0gbnVsbDtcclxuICAgICAgICBwdWIucG9pbnRzID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSAgIGxha2VUaHJlc2hvbGQgMCB0byAxLCBmcmFjdGlvbiBvZiB3YXRlciBjb3JuZXJzIGZvciB3YXRlciBwb2x5Z29uLCBkZWZhdWx0ID0gMC4zXHJcbiAgICAgKi9cclxuICAgIHB1Yi5nbzNBc3NpZ25FbGV2YXRpb25zID0gZnVuY3Rpb24gKGxha2VUaHJlc2hvbGQpIHtcclxuICAgICAgICBsYWtlVGhyZXNob2xkID0gY29yZS5kZWYobGFrZVRocmVzaG9sZCwgZXhwb3J0cy5ERUZBVUxUX0xBS0VfVEhSRVNIT0xEKTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBlbGV2YXRpb25zIGFuZCB3YXRlciBhdCBWb3Jvbm9pIGNvcm5lcnMuXHJcbiAgICAgICAgcHViLmFzc2lnbkNvcm5lckVsZXZhdGlvbnMoKTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHBvbHlnb24gYW5kIGNvcm5lciB0eXBlOiBvY2VhbiwgY29hc3QsIGxhbmQuXHJcbiAgICAgICAgcHViLmFzc2lnbk9jZWFuQ29hc3RBbmRMYW5kKGxha2VUaHJlc2hvbGQpO1xyXG5cclxuICAgICAgICAvLyBSZXNjYWxlIGVsZXZhdGlvbnMgc28gdGhhdCB0aGUgaGlnaGVzdCBpcyAxLjAsIGFuZCB0aGV5J3JlXHJcbiAgICAgICAgLy8gZGlzdHJpYnV0ZWQgd2VsbC4gV2Ugd2FudCBsb3dlciBlbGV2YXRpb25zIHRvIGJlIG1vcmUgY29tbW9uXHJcbiAgICAgICAgLy8gdGhhbiBoaWdoZXIgZWxldmF0aW9ucywgaW4gcHJvcG9ydGlvbnMgYXBwcm94aW1hdGVseSBtYXRjaGluZ1xyXG4gICAgICAgIC8vIGNvbmNlbnRyaWMgcmluZ3MuIFRoYXQgaXMsIHRoZSBsb3dlc3QgZWxldmF0aW9uIGlzIHRoZVxyXG4gICAgICAgIC8vIGxhcmdlc3QgcmluZyBhcm91bmQgdGhlIGlzbGFuZCwgYW5kIHRoZXJlZm9yZSBzaG91bGQgbW9yZVxyXG4gICAgICAgIC8vIGxhbmQgYXJlYSB0aGFuIHRoZSBoaWdoZXN0IGVsZXZhdGlvbiwgd2hpY2ggaXMgdGhlIHZlcnlcclxuICAgICAgICAvLyBjZW50ZXIgb2YgYSBwZXJmZWN0bHkgY2lyY3VsYXIgaXNsYW5kLlxyXG4gICAgICAgIHB1Yi5yZWRpc3RyaWJ1dGVFbGV2YXRpb25zKHB1Yi5sYW5kQ29ybmVycyhwdWIuY29ybmVycykpO1xyXG5cclxuICAgICAgICAvLyBBc3NpZ24gZWxldmF0aW9ucyB0byBub24tbGFuZCBjb3JuZXJzXHJcbiAgICAgICAgXyhwdWIuY29ybmVycykuZWFjaChmdW5jdGlvbiAocSkge1xyXG4gICAgICAgICAgICBpZiAocS5vY2VhbiB8fCBxLmNvYXN0KSB7XHJcbiAgICAgICAgICAgICAgICBxLmVsZXZhdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBQb2x5Z29uIGVsZXZhdGlvbnMgYXJlIHRoZSBhdmVyYWdlIG9mIHRoZWlyIGNvcm5lcnNcclxuICAgICAgICBwdWIuYXNzaWduUG9seWdvbkVsZXZhdGlvbnMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHViLmdvNEFzc2lnbk1vaXN0dXJlID0gZnVuY3Rpb24gKHJpdmVyQ2hhbmNlKSB7XHJcbiAgICAgICAgcml2ZXJDaGFuY2UgPSBjb3JlLmRlZihyaXZlckNoYW5jZSwgbnVsbCk7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBkb3duc2xvcGUgcGF0aHMuXHJcbiAgICAgICAgcHViLmNhbGN1bGF0ZURvd25zbG9wZXMoKTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdhdGVyc2hlZHM6IGZvciBldmVyeSBjb3JuZXIsIHdoZXJlIGRvZXMgaXQgZmxvd1xyXG4gICAgICAgIC8vIG91dCBpbnRvIHRoZSBvY2Vhbj8gXHJcbiAgICAgICAgcHViLmNhbGN1bGF0ZVdhdGVyc2hlZHMoKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHJpdmVycy5cclxuICAgICAgICBwdWIuY3JlYXRlUml2ZXJzKHJpdmVyQ2hhbmNlKTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIG1vaXN0dXJlIGF0IGNvcm5lcnMsIHN0YXJ0aW5nIGF0IHJpdmVyc1xyXG4gICAgICAgIC8vIGFuZCBsYWtlcywgYnV0IG5vdCBvY2VhbnMuIFRoZW4gcmVkaXN0cmlidXRlXHJcbiAgICAgICAgLy8gbW9pc3R1cmUgdG8gY292ZXIgdGhlIGVudGlyZSByYW5nZSBldmVubHkgZnJvbSAwLjBcclxuICAgICAgICAvLyB0byAxLjAuIFRoZW4gYXNzaWduIHBvbHlnb24gbW9pc3R1cmUgYXMgdGhlIGF2ZXJhZ2VcclxuICAgICAgICAvLyBvZiB0aGUgY29ybmVyIG1vaXN0dXJlLlxyXG4gICAgICAgIHB1Yi5hc3NpZ25Db3JuZXJNb2lzdHVyZSgpO1xyXG4gICAgICAgIHB1Yi5yZWRpc3RyaWJ1dGVNb2lzdHVyZShwdWIubGFuZENvcm5lcnMocHViLmNvcm5lcnMpKTtcclxuICAgICAgICBwdWIuYXNzaWduUG9seWdvbk1vaXN0dXJlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5nbzVEZWNvcmF0ZU1hcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwdWIuYXNzaWduQmlvbWVzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBCcmVhayBjeWNsZXMgc28gdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHdpbGwgcmVsZWFzZSBkYXRhLlxyXG4gICAgICAgIGlmIChwdWIucG9pbnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHB1Yi5wb2ludHMuc3BsaWNlKDAsIHB1Yi5wb2ludHMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHB1Yi5lZGdlcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBfKHB1Yi5lZGdlcykuZWFjaChmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgICAgICAgICAgZWRnZS5kMCA9IGVkZ2UuZDEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZWRnZS52MCA9IGVkZ2UudjEgPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcHViLmVkZ2VzLnNwbGljZSgwLCBwdWIuZWRnZXMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHB1Yi5jZW50ZXJzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF8ocHViLmNlbnRlcnMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIHAubmVpZ2hib3JzLnNwbGljZSgwLCBwLm5laWdoYm9ycy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcC5jb3JuZXJzLnNwbGljZSgwLCBwLmNvcm5lcnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHAuYm9yZGVycy5zcGxpY2UoMCwgcC5ib3JkZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwdWIuY2VudGVycy5zcGxpY2UoMCwgcHViLmNlbnRlcnMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHB1Yi5jb3JuZXJzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF8ocHViLmNvcm5lcnMpLmVhY2goZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICAgICAgICAgIHEuYWRqYWNlbnQuc3BsaWNlKDAsIHEuYWRqYWNlbnQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHEudG91Y2hlcy5zcGxpY2UoMCwgcS50b3VjaGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBxLnByb3RydWRlcy5zcGxpY2UoMCwgcS5wcm90cnVkZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIHEuZG93bnNsb3BlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHEud2F0ZXJzaGVkID0gbnVsbDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHB1Yi5jb3JuZXJzLnNwbGljZSgwLCBwdWIuY29ybmVycy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDbGVhciB0aGUgcHJldmlvdXMgZ3JhcGggZGF0YS5cclxuICAgICAgICBpZiAocHViLnBvaW50cyA9PT0gbnVsbCkgeyBwdWIucG9pbnRzID0gW107IH1cclxuICAgICAgICBpZiAocHViLmVkZ2VzID09PSBudWxsKSB7IHB1Yi5lZGdlcyA9IFtdOyB9XHJcbiAgICAgICAgaWYgKHB1Yi5jZW50ZXJzID09PSBudWxsKSB7IHB1Yi5jZW50ZXJzID0gW107IH1cclxuICAgICAgICBpZiAocHViLmNvcm5lcnMgPT09IG51bGwpIHsgcHViLmNvcm5lcnMgPSBbXTsgfVxyXG4gICAgICBcclxuICAgICAgICAvLyBEaXNhYmxlZCBmb3IgSmF2YVNjcmlwdFxyXG4gICAgICAgIC8vU3lzdGVtLmdjKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgcmFuZG9tIHBvaW50cyBhbmQgYXNzaWduIHRoZW0gdG8gYmUgb24gdGhlIGlzbGFuZCBvclxyXG4gICAgICogaW4gdGhlIHdhdGVyLiBTb21lIHdhdGVyIHBvaW50cyBhcmUgaW5sYW5kIGxha2VzOyBvdGhlcnMgYXJlXHJcbiAgICAgKiBvY2Vhbi4gV2UnbGwgZGV0ZXJtaW5lIG9jZWFuIGxhdGVyIGJ5IGxvb2tpbmcgYXQgd2hhdCdzXHJcbiAgICAgKiBjb25uZWN0ZWQgdG8gb2NlYW4uXHJcbiAgICAgKi9cclxuICAgIHB1Yi5nZW5lcmF0ZVJhbmRvbVBvaW50cyA9IGZ1bmN0aW9uIChOVU1fUE9JTlRTKSB7XHJcbiAgICAgICAgdmFyIHAsIGksIHBvaW50cyA9IFtdOyAvL1ZlY3RvcjxQb2ludD5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgTlVNX1BPSU5UUzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHAgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBwdWIubWFwUmFuZG9tLm5leHREb3VibGVSYW5nZSgxMCwgcHViLlNJWkUud2lkdGggLSAxMCksXHJcbiAgICAgICAgICAgICAgICB5OiBwdWIubWFwUmFuZG9tLm5leHREb3VibGVSYW5nZSgxMCwgcHViLlNJWkUuaGVpZ2h0IC0gMTApXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEltcHJvdmUgdGhlIHJhbmRvbSBzZXQgb2YgcG9pbnRzIHdpdGggTGxveWQgUmVsYXhhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHViLmltcHJvdmVSYW5kb21Qb2ludHMgPSBmdW5jdGlvbiAocG9pbnRzLCBudW1MbG95ZEl0ZXJhdGlvbnMpIHtcclxuICAgICAgLy8gV2UnZCByZWFsbHkgbGlrZSB0byBnZW5lcmF0ZSBcImJsdWUgbm9pc2VcIi4gQWxnb3JpdGhtczpcclxuICAgICAgLy8gMS4gUG9pc3NvbiBkYXJ0IHRocm93aW5nOiBjaGVjayBlYWNoIG5ldyBwb2ludCBhZ2FpbnN0IGFsbFxyXG4gICAgICAvLyAgICAgZXhpc3RpbmcgcG9pbnRzLCBhbmQgcmVqZWN0IGl0IGlmIGl0J3MgdG9vIGNsb3NlLlxyXG4gICAgICAvLyAyLiBTdGFydCB3aXRoIGEgaGV4YWdvbmFsIGdyaWQgYW5kIHJhbmRvbWx5IHBlcnR1cmIgcG9pbnRzLlxyXG4gICAgICAvLyAzLiBMbG95ZCBSZWxheGF0aW9uOiBtb3ZlIGVhY2ggcG9pbnQgdG8gdGhlIGNlbnRyb2lkIG9mIHRoZVxyXG4gICAgICAvLyAgICAgZ2VuZXJhdGVkIFZvcm9ub2kgcG9seWdvbiwgdGhlbiBnZW5lcmF0ZSBWb3Jvbm9pIGFnYWluLlxyXG4gICAgICAvLyA0LiBVc2UgZm9yY2UtYmFzZWQgbGF5b3V0IGFsZ29yaXRobXMgdG8gcHVzaCBwb2ludHMgYXdheS5cclxuICAgICAgLy8gNS4gTW9yZSBhdCBodHRwOi8vd3d3LmNzLnZpcmdpbmlhLmVkdS9+Z2Z4L3B1YnMvYW50aW1vbnkvXHJcbiAgICAgIC8vIE9wdGlvbiAzIGlzIGltcGxlbWVudGVkIGhlcmUuIElmIGl0J3MgcnVuIGZvciB0b28gbWFueSBpdGVyYXRpb25zLFxyXG4gICAgICAvLyBpdCB3aWxsIHR1cm4gaW50byBhIGdyaWQsIGJ1dCBjb252ZXJnZW5jZSBpcyB2ZXJ5IHNsb3csIGFuZCB3ZSBvbmx5XHJcbiAgICAgIC8vIHJ1biBpdCBhIGZldyB0aW1lcy5cclxuXHJcbiAgICAgICAgdmFyIGksIHZvcm9ub2ksIHJlZ2lvbjtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTGxveWRJdGVyYXRpb25zOyBpKyspIHtcclxuICAgICAgICAgICAgdm9yb25vaSA9IHZvcm9ub2lNb2R1bGUubWFrZShwb2ludHMsIG51bGwsIHJlY3RhbmdsZSgwLCAwLCBwdWIuU0laRS53aWR0aCwgcHViLlNJWkUuaGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHBvaW50c0luZGV4ID0gMDsgcG9pbnRzSW5kZXggPCBwb2ludHMubGVuZ3RoOyBwb2ludHNJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1twb2ludHNJbmRleF07XHJcbiAgICAgICAgICAgICAgICByZWdpb24gPSB2b3Jvbm9pLnJlZ2lvbihwKTtcclxuICAgICAgICAgICAgICAgIHAueCA9IDAuMDtcclxuICAgICAgICAgICAgICAgIHAueSA9IDAuMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHJlZ2lvbkluZGV4ID0gMDsgcmVnaW9uSW5kZXggPCByZWdpb24ubGVuZ3RoOyByZWdpb25JbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSByZWdpb25bcmVnaW9uSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHAueCArPSBxLng7XHJcbiAgICAgICAgICAgICAgICAgICAgcC55ICs9IHEueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAueCAvPSByZWdpb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcC55IC89IHJlZ2lvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZWdpb24uc3BsaWNlKDAsIHJlZ2lvbi5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZvcm9ub2kuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbHRob3VnaCBMbG95ZCByZWxheGF0aW9uIGltcHJvdmVzIHRoZSB1bmlmb3JtaXR5IG9mIHBvbHlnb25cclxuICAgICAqIHNpemVzLCBpdCBkb2Vzbid0IGhlbHAgd2l0aCB0aGUgZWRnZSBsZW5ndGhzLiBTaG9ydCBlZGdlcyBjYW5cclxuICAgICAqIGJlIGJhZCBmb3Igc29tZSBnYW1lcywgYW5kIGxlYWQgdG8gd2VpcmQgYXJ0aWZhY3RzIG9uXHJcbiAgICAgKiByaXZlcnMuIFdlIGNhbiBlYXNpbHkgbGVuZ3RoZW4gc2hvcnQgZWRnZXMgYnkgbW92aW5nIHRoZVxyXG4gICAgICogY29ybmVycywgYnV0ICoqd2UgbG9zZSB0aGUgVm9yb25vaSBwcm9wZXJ0eSoqLiAgVGhlIGNvcm5lcnMgYXJlXHJcbiAgICAgKiBtb3ZlZCB0byB0aGUgYXZlcmFnZSBvZiB0aGUgcG9seWdvbiBjZW50ZXJzIGFyb3VuZCB0aGVtLiBTaG9ydFxyXG4gICAgICogZWRnZXMgYmVjb21lIGxvbmdlci4gTG9uZyBlZGdlcyB0ZW5kIHRvIGJlY29tZSBzaG9ydGVyLiBUaGVcclxuICAgICAqIHBvbHlnb25zIHRlbmQgdG8gYmUgbW9yZSB1bmlmb3JtIGFmdGVyIHRoaXMgc3RlcC5cclxuICAgICAqL1xyXG4gICAgcHViLmltcHJvdmVDb3JuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuZXdDb3JuZXJzID0gW107IC8vIFZlY3RvcjxQb2ludD5cclxuICAgICAgICB2YXIgcG9pbnQsIGk7XHJcblxyXG4gICAgICAgIC8vIEZpcnN0IHdlIGNvbXB1dGUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIGNlbnRlcnMgbmV4dCB0byBlYWNoIGNvcm5lci5cclxuICAgICAgICBfKHB1Yi5jb3JuZXJzKS5lYWNoKGZ1bmN0aW9uIChxKSB7XHJcbiAgICAgICAgICAgIGlmIChxLmJvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgbmV3Q29ybmVyc1txLmluZGV4XSA9IHEucG9pbnQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHt4OiAwLjAsIHk6IDAuMH07XHJcbiAgICAgICAgICAgICAgICBfKHEudG91Y2hlcykuZWFjaChmdW5jdGlvbiAocikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnggKz0gci5wb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnkgKz0gci5wb2ludC55O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludC54IC89IHEudG91Y2hlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBwb2ludC55IC89IHEudG91Y2hlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBuZXdDb3JuZXJzW3EuaW5kZXhdID0gcG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTW92ZSB0aGUgY29ybmVycyB0byB0aGUgbmV3IGxvY2F0aW9ucy5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHViLmNvcm5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcHViLmNvcm5lcnNbaV0ucG9pbnQgPSBuZXdDb3JuZXJzW2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGVkZ2UgbWlkcG9pbnRzIHdlcmUgY29tcHV0ZWQgZm9yIHRoZSBvbGQgY29ybmVycyBhbmQgbmVlZFxyXG4gICAgICAgIC8vIHRvIGJlIHJlY29tcHV0ZWQuXHJcbiAgICAgICAgXyhwdWIuZWRnZXMpLmVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcclxuICAgICAgICAgICAgaWYgKGVkZ2UudjAgIT09IG51bGwgJiYgZWRnZS52MSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZWRnZS5taWRwb2ludCA9IHBjLmludGVycG9sYXRlKGVkZ2UudjAucG9pbnQsIGVkZ2UudjEucG9pbnQsIDAuNSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gYXJyYXkgb2YgY29ybmVycyB0aGF0IGFyZSBvbiBsYW5kIG9ubHksIGZvciB1c2UgYnlcclxuICAgICAqIGFsZ29yaXRobXMgdGhhdCB3b3JrIG9ubHkgb24gbGFuZC4gIFdlIHJldHVybiBhbiBhcnJheSBpbnN0ZWFkXHJcbiAgICAgKiBvZiBhIHZlY3RvciBiZWNhdXNlIHRoZSByZWRpc3RyaWJ1dGlvbiBhbGdvcml0aG1zIHdhbnQgdG8gc29ydFxyXG4gICAgICogdGhpcyBhcnJheSB1c2luZyBBcnJheS5zb3J0T24uXHJcbiAgICAgKi9cclxuICAgIHB1Yi5sYW5kQ29ybmVycyA9IGZ1bmN0aW9uIChjb3JuZXJzKSB7XHJcbiAgICAgICAgdmFyIGxvY2F0aW9ucyA9IFtdO1xyXG4gICAgICAgIF8oY29ybmVycykuZWFjaChmdW5jdGlvbiAocSkge1xyXG4gICAgICAgICAgICBpZiAoIXEub2NlYW4gJiYgIXEuY29hc3QpIHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9ucy5wdXNoKHEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9ucztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBncmFwaCBkYXRhIHN0cnVjdHVyZSBpbiAnZWRnZXMnLCAnY2VudGVycycsICdjb3JuZXJzJyxcclxuICAgICAqIGJhc2VkIG9uIGluZm9ybWF0aW9uIGluIHRoZSBWb3Jvbm9pIHJlc3VsdHM6IHBvaW50Lm5laWdoYm9yc1xyXG4gICAgICogd2lsbCBiZSBhIGxpc3Qgb2YgbmVpZ2hib3JpbmcgcG9pbnRzIG9mIHRoZSBzYW1lIHR5cGUgKGNvcm5lclxyXG4gICAgICogb3IgY2VudGVyKTsgcG9pbnQuZWRnZXMgd2lsbCBiZSBhIGxpc3Qgb2YgZWRnZXMgdGhhdCBpbmNsdWRlXHJcbiAgICAgKiB0aGF0IHBvaW50LiBFYWNoIGVkZ2UgY29ubmVjdHMgdG8gZm91ciBwb2ludHM6IHRoZSBWb3Jvbm9pIGVkZ2VcclxuICAgICAqIGVkZ2Uue3YwLHYxfSBhbmQgaXRzIGR1YWwgRGVsYXVuYXkgdHJpYW5nbGUgZWRnZSBlZGdlLntkMCxkMX0uXHJcbiAgICAgKiBGb3IgYm91bmRhcnkgcG9seWdvbnMsIHRoZSBEZWxhdW5heSBlZGdlIHdpbGwgaGF2ZSBvbmUgbnVsbFxyXG4gICAgICogcG9pbnQsIGFuZCB0aGUgVm9yb25vaSBlZGdlIG1heSBiZSBudWxsLlxyXG4gICAgICovXHJcbiAgICBwdWIuYnVpbGRHcmFwaCA9IGZ1bmN0aW9uIChwb2ludHMsIHZvcm9ub2kpIHtcclxuICAgICAgICB2YXIgcDtcclxuICAgICAgICB2YXIgbGliZWRnZXMgPSB2b3Jvbm9pLmVkZ2VzKCk7XHJcbiAgICAgICAgdmFyIGNlbnRlckxvb2t1cCA9IHt9OyAvLyBEaWN0aW9uYXJ5PENlbnRlcj5cclxuXHJcbiAgICAgICAgLy8gQnVpbGQgQ2VudGVyIG9iamVjdHMgZm9yIGVhY2ggb2YgdGhlIHBvaW50cywgYW5kIGEgbG9va3VwIG1hcFxyXG4gICAgICAgIC8vIHRvIGZpbmQgdGhvc2UgQ2VudGVyIG9iamVjdHMgYWdhaW4gYXMgd2UgYnVpbGQgdGhlIGdyYXBoXHJcbiAgICAgICAgXyhwb2ludHMpLmVhY2goZnVuY3Rpb24gKHBvaW50KSB7XHJcbiAgICAgICAgICAgIHAgPSBjZW50ZXJNb2R1bGUoKTtcclxuICAgICAgICAgICAgcC5pbmRleCA9IHB1Yi5jZW50ZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgcC5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICBwLm5laWdoYm9ycyA9IFtdO1xyXG4gICAgICAgICAgICBwLmJvcmRlcnMgPSBbXTtcclxuICAgICAgICAgICAgcC5jb3JuZXJzID0gW107XHJcbiAgICAgICAgICAgIHB1Yi5jZW50ZXJzLnB1c2gocCk7XHJcbiAgICAgICAgICAgIGNlbnRlckxvb2t1cFtwYy5oYXNoKHBvaW50KV0gPSBwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBWb3Jvbm9pIGxpYiBidWc6IHdlIG5lZWQgdG8gY2FsbCByZWdpb24oKVxyXG4gICAgICAgIC8vIGJlZm9yZSBFZGdlcyBvciBuZWlnaGJvcmluZ1NpdGVzIGFyZSBhdmFpbGFibGVcclxuICAgICAgICBfKHB1Yi5jZW50ZXJzKS5lYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHZvcm9ub2kucmVnaW9uKHAucG9pbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgICAvLyBUaGUgVm9yb25vaSBsaWJyYXJ5IGdlbmVyYXRlcyBtdWx0aXBsZSBQb2ludCBvYmplY3RzIGZvclxyXG4gICAgICAgIC8vIGNvcm5lcnMsIGFuZCB3ZSBuZWVkIHRvIGNhbm9uaWNhbGl6ZSB0byBvbmUgQ29ybmVyIG9iamVjdC5cclxuICAgICAgICAvLyBUbyBtYWtlIGxvb2t1cCBmYXN0LCB3ZSBrZWVwIGFuIGFycmF5IG9mIFBvaW50cywgYnVja2V0ZWQgYnlcclxuICAgICAgICAvLyB4IHZhbHVlLCBhbmQgdGhlbiB3ZSBvbmx5IGhhdmUgdG8gbG9vayBhdCBvdGhlciBQb2ludHMgaW5cclxuICAgICAgICAvLyBuZWFyYnkgYnVja2V0cy4gV2hlbiB3ZSBmYWlsIHRvIGZpbmQgb25lLCB3ZSdsbCBjcmVhdGUgYSBuZXdcclxuICAgICAgICAvLyBDb3JuZXIgb2JqZWN0LlxyXG4gICAgICAgIHZhciBfY29ybmVyTWFwID0gW107XHJcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNvcm5lcihwb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgcTtcclxuICAgICAgICAgICAgaWYgKHBvaW50ID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XHJcbiAgICAgICAgICAgIHZhciBidWNrZXQ7XHJcbiAgICAgICAgICAgIGZvciAoYnVja2V0ID0gY29yZS50b0ludChwb2ludC54KSAtIDE7IGJ1Y2tldCA8IGNvcmUudG9JbnQocG9pbnQueCkgKyAyOyBidWNrZXQrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKF9jb3JuZXJNYXBbYnVja2V0XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB6ID0gMDsgeiA8IF9jb3JuZXJNYXBbYnVja2V0XS5sZW5ndGg7IHorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gX2Nvcm5lck1hcFtidWNrZXRdW3pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBwb2ludC54IC0gcS5wb2ludC54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSBwb2ludC55IC0gcS5wb2ludC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPCAxZS02KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidWNrZXQgPSBjb3JlLnRvSW50KHBvaW50LngpO1xyXG4gICAgICAgICAgICBpZiAoY29yZS5pc1VuZGVmaW5lZE9yTnVsbChfY29ybmVyTWFwW2J1Y2tldF0pKSB7IF9jb3JuZXJNYXBbYnVja2V0XSA9IFtdOyB9XHJcbiAgICAgICAgICAgIHEgPSBjb3JuZXJNb2R1bGUoKTtcclxuICAgICAgICAgICAgcS5pbmRleCA9IHB1Yi5jb3JuZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgcHViLmNvcm5lcnMucHVzaChxKTtcclxuICAgICAgICAgICAgcS5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICBxLmJvcmRlciA9IChwb2ludC54ID09PSAwIHx8IHBvaW50LnggPT09IHB1Yi5TSVpFLndpZHRoIHx8IHBvaW50LnkgPT09IDAgfHwgcG9pbnQueSA9PT0gcHViLlNJWkUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgcS50b3VjaGVzID0gW107XHJcbiAgICAgICAgICAgIHEucHJvdHJ1ZGVzID0gW107XHJcbiAgICAgICAgICAgIHEuYWRqYWNlbnQgPSBbXTtcclxuICAgICAgICAgICAgX2Nvcm5lck1hcFtidWNrZXRdLnB1c2gocSk7XHJcbiAgICAgICAgICAgIHJldHVybiBxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgXyhsaWJlZGdlcykuZWFjaChmdW5jdGlvbiAobGliZWRnZSkge1xyXG4gICAgICAgICAgICB2YXIgZGVkZ2UgPSBsaWJlZGdlLmRlbGF1bmF5TGluZSgpO1xyXG4gICAgICAgICAgICB2YXIgdmVkZ2UgPSBsaWJlZGdlLnZvcm9ub2lFZGdlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaWxsIHRoZSBncmFwaCBkYXRhLiBNYWtlIGFuIEVkZ2Ugb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG9cclxuICAgICAgICAgICAgLy8gdGhlIGVkZ2UgZnJvbSB0aGUgdm9yb25vaSBsaWJyYXJ5LlxyXG4gICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VNb2R1bGUoKTtcclxuICAgICAgICAgICAgZWRnZS5pbmRleCA9IHB1Yi5lZGdlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGVkZ2Uucml2ZXIgPSAwO1xyXG4gICAgICAgICAgICBwdWIuZWRnZXMucHVzaChlZGdlKTtcclxuICAgICAgICAgICAgZWRnZS5taWRwb2ludCA9ICh2ZWRnZS5wMCAhPT0gbnVsbCAmJiB2ZWRnZS5wMSAhPT0gbnVsbCkgPyBwYy5pbnRlcnBvbGF0ZSh2ZWRnZS5wMCwgdmVkZ2UucDEsIDAuNSkgOiBudWxsO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIEVkZ2VzIHBvaW50IHRvIGNvcm5lcnMuIEVkZ2VzIHBvaW50IHRvIGNlbnRlcnMuIFxyXG4gICAgICAgICAgICBlZGdlLnYwID0gbWFrZUNvcm5lcih2ZWRnZS5wMCk7XHJcbiAgICAgICAgICAgIGVkZ2UudjEgPSBtYWtlQ29ybmVyKHZlZGdlLnAxKTtcclxuICAgICAgICAgICAgZWRnZS5kMCA9IGNlbnRlckxvb2t1cFtwYy5oYXNoKGRlZGdlLnAwKV07XHJcbiAgICAgICAgICAgIGVkZ2UuZDEgPSBjZW50ZXJMb29rdXBbcGMuaGFzaChkZWRnZS5wMSldO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2VudGVycyBwb2ludCB0byBlZGdlcy4gQ29ybmVycyBwb2ludCB0byBlZGdlcy5cclxuICAgICAgICAgICAgaWYgKGVkZ2UuZDAgIT09IG51bGwpIHsgZWRnZS5kMC5ib3JkZXJzLnB1c2goZWRnZSk7IH1cclxuICAgICAgICAgICAgaWYgKGVkZ2UuZDEgIT09IG51bGwpIHsgZWRnZS5kMS5ib3JkZXJzLnB1c2goZWRnZSk7IH1cclxuICAgICAgICAgICAgaWYgKGVkZ2UudjAgIT09IG51bGwpIHsgZWRnZS52MC5wcm90cnVkZXMucHVzaChlZGdlKTsgfVxyXG4gICAgICAgICAgICBpZiAoZWRnZS52MSAhPT0gbnVsbCkgeyBlZGdlLnYxLnByb3RydWRlcy5wdXNoKGVkZ2UpOyB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRUb0Nvcm5lckxpc3QodiwgeCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgdi5pbmRleE9mKHgpIDwgMCkgeyB2LnB1c2goeCk7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRUb0NlbnRlckxpc3QodiwgeCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHggIT09IG51bGwgJiYgdi5pbmRleE9mKHgpIDwgMCkgeyB2LnB1c2goeCk7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENlbnRlcnMgcG9pbnQgdG8gY2VudGVycy5cclxuICAgICAgICAgICAgaWYgKGVkZ2UuZDAgIT09IG51bGwgJiYgZWRnZS5kMSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYWRkVG9DZW50ZXJMaXN0KGVkZ2UuZDAubmVpZ2hib3JzLCBlZGdlLmQxKTtcclxuICAgICAgICAgICAgICAgIGFkZFRvQ2VudGVyTGlzdChlZGdlLmQxLm5laWdoYm9ycywgZWRnZS5kMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvcm5lcnMgcG9pbnQgdG8gY29ybmVyc1xyXG4gICAgICAgICAgICBpZiAoZWRnZS52MCAhPT0gbnVsbCAmJiBlZGdlLnYxICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRUb0Nvcm5lckxpc3QoZWRnZS52MC5hZGphY2VudCwgZWRnZS52MSk7XHJcbiAgICAgICAgICAgICAgICBhZGRUb0Nvcm5lckxpc3QoZWRnZS52MS5hZGphY2VudCwgZWRnZS52MCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENlbnRlcnMgcG9pbnQgdG8gY29ybmVyc1xyXG4gICAgICAgICAgICBpZiAoZWRnZS5kMCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYWRkVG9Db3JuZXJMaXN0KGVkZ2UuZDAuY29ybmVycywgZWRnZS52MCk7XHJcbiAgICAgICAgICAgICAgICBhZGRUb0Nvcm5lckxpc3QoZWRnZS5kMC5jb3JuZXJzLCBlZGdlLnYxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZWRnZS5kMSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYWRkVG9Db3JuZXJMaXN0KGVkZ2UuZDEuY29ybmVycywgZWRnZS52MCk7XHJcbiAgICAgICAgICAgICAgICBhZGRUb0Nvcm5lckxpc3QoZWRnZS5kMS5jb3JuZXJzLCBlZGdlLnYxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29ybmVycyBwb2ludCB0byBjZW50ZXJzXHJcbiAgICAgICAgICAgIGlmIChlZGdlLnYwICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRUb0NlbnRlckxpc3QoZWRnZS52MC50b3VjaGVzLCBlZGdlLmQwKTtcclxuICAgICAgICAgICAgICAgIGFkZFRvQ2VudGVyTGlzdChlZGdlLnYwLnRvdWNoZXMsIGVkZ2UuZDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlZGdlLnYxICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRUb0NlbnRlckxpc3QoZWRnZS52MS50b3VjaGVzLCBlZGdlLmQwKTtcclxuICAgICAgICAgICAgICAgIGFkZFRvQ2VudGVyTGlzdChlZGdlLnYxLnRvdWNoZXMsIGVkZ2UuZDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lIGVsZXZhdGlvbnMgYW5kIHdhdGVyIGF0IFZvcm9ub2kgY29ybmVycy4gQnlcclxuICAgICAqIGNvbnN0cnVjdGlvbiwgd2UgaGF2ZSBubyBsb2NhbCBtaW5pbWEuIFRoaXMgaXMgaW1wb3J0YW50IGZvclxyXG4gICAgICogdGhlIGRvd25zbG9wZSB2ZWN0b3JzIGxhdGVyLCB3aGljaCBhcmUgdXNlZCBpbiB0aGUgcml2ZXJcclxuICAgICAqIGNvbnN0cnVjdGlvbiBhbGdvcml0aG0uIEFsc28gYnkgY29uc3RydWN0aW9uLCBpbmxldHMvYmF5c1xyXG4gICAgICogcHVzaCBsb3cgZWxldmF0aW9uIGFyZWFzIGlubGFuZCwgd2hpY2ggbWVhbnMgbWFueSByaXZlcnMgZW5kXHJcbiAgICAgKiB1cCBmbG93aW5nIG91dCB0aHJvdWdoIHRoZW0uIEFsc28gYnkgY29uc3RydWN0aW9uLCBsYWtlc1xyXG4gICAgICogb2Z0ZW4gZW5kIHVwIG9uIHJpdmVyIHBhdGhzIGJlY2F1c2UgdGhleSBkb24ndCByYWlzZSB0aGVcclxuICAgICAqIGVsZXZhdGlvbiBhcyBtdWNoIGFzIG90aGVyIHRlcnJhaW4gZG9lcy5cclxuICAgICAqL1xyXG4gICAgcHViLmFzc2lnbkNvcm5lckVsZXZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHF1ZXVlID0gW107IC8vIEFycmF5PENvcm5lcj5cclxuICAgICAgXHJcbiAgICAgICAgXyhwdWIuY29ybmVycykuZWFjaChmdW5jdGlvbiAocSkge1xyXG4gICAgICAgICAgICBxLndhdGVyID0gIXB1Yi5pbnNpZGUocS5wb2ludCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIF8ocHViLmNvcm5lcnMpLmVhY2goZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGVkZ2VzIG9mIHRoZSBtYXAgYXJlIGVsZXZhdGlvbiAwXHJcbiAgICAgICAgICAgIGlmIChxLmJvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgcS5lbGV2YXRpb24gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcS5lbGV2YXRpb24gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGggYW5kIGFzc2lnbiBlbGV2YXRpb25zIHRvIGVhY2ggcG9pbnQuIEFzIHdlXHJcbiAgICAgICAgLy8gbW92ZSBhd2F5IGZyb20gdGhlIG1hcCBib3JkZXIsIGluY3JlYXNlIHRoZSBlbGV2YXRpb25zLiBUaGlzXHJcbiAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGF0IHJpdmVycyBhbHdheXMgaGF2ZSBhIHdheSBkb3duIHRvIHRoZSBjb2FzdCBieVxyXG4gICAgICAgIC8vIGdvaW5nIGRvd25oaWxsIChubyBsb2NhbCBtaW5pbWEpLlxyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBxID0gcXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgYWRqYWNlbnRJbmRleCA9IDA7IGFkamFjZW50SW5kZXggPCBxLmFkamFjZW50Lmxlbmd0aDsgYWRqYWNlbnRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHEuYWRqYWNlbnRbYWRqYWNlbnRJbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXZlcnkgc3RlcCB1cCBpcyBlcHNpbG9uIG92ZXIgd2F0ZXIgb3IgMSBvdmVyIGxhbmQuIFRoZVxyXG4gICAgICAgICAgICAgICAgLy8gbnVtYmVyIGRvZXNuJ3QgbWF0dGVyIGJlY2F1c2Ugd2UnbGwgcmVzY2FsZSB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGVsZXZhdGlvbnMgbGF0ZXIuXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3RWxldmF0aW9uID0gMC4wMSArIHEuZWxldmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFxLndhdGVyICYmICFzLndhdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RWxldmF0aW9uICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBwb2ludCBjaGFuZ2VkLCB3ZSdsbCBhZGQgaXQgdG8gdGhlIHF1ZXVlIHNvXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHdlIGNhbiBwcm9jZXNzIGl0cyBuZWlnaGJvcnMgdG9vLlxyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0VsZXZhdGlvbiA8IHMuZWxldmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5lbGV2YXRpb24gPSBuZXdFbGV2YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIG92ZXJhbGwgZGlzdHJpYnV0aW9uIG9mIGVsZXZhdGlvbnMgc28gdGhhdCBsb3dlclxyXG4gICAgICogZWxldmF0aW9ucyBhcmUgbW9yZSBjb21tb24gdGhhbiBoaWdoZXJcclxuICAgICAqIGVsZXZhdGlvbnMuIFNwZWNpZmljYWxseSwgd2Ugd2FudCBlbGV2YXRpb24gWCB0byBoYXZlIGZyZXF1ZW5jeVxyXG4gICAgICogKDEtWCkuICBUbyBkbyB0aGlzIHdlIHdpbGwgc29ydCB0aGUgY29ybmVycywgdGhlbiBzZXQgZWFjaFxyXG4gICAgICogY29ybmVyIHRvIGl0cyBkZXNpcmVkIGVsZXZhdGlvbi5cclxuICAgICAqL1xyXG4gICAgcHViLnJlZGlzdHJpYnV0ZUVsZXZhdGlvbnMgPSBmdW5jdGlvbiAobG9jYXRpb25zKSB7XHJcbiAgICAgICAgLy8gU0NBTEVfRkFDVE9SIGluY3JlYXNlcyB0aGUgbW91bnRhaW4gYXJlYS4gQXQgMS4wIHRoZSBtYXhpbXVtXHJcbiAgICAgICAgLy8gZWxldmF0aW9uIGJhcmVseSBzaG93cyB1cCBvbiB0aGUgbWFwLCBzbyB3ZSBzZXQgaXQgdG8gMS4xLlxyXG4gICAgICAgIHZhciBTQ0FMRV9GQUNUT1IgPSAxLjE7XHJcbiAgICAgICAgdmFyIGksIHksIHg7XHJcblxyXG4gICAgICAgIC8vSmF2YVNjcmlwdCBwb3J0XHJcbiAgICAgICAgLy9sb2NhdGlvbnMuc29ydE9uKCdlbGV2YXRpb24nLCBBcnJheS5OVU1FUklDKTtcclxuICAgICAgICBsb2NhdGlvbnMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XHJcbiAgICAgICAgICAgIGlmIChjMS5lbGV2YXRpb24gPiBjMi5lbGV2YXRpb24pIHsgcmV0dXJuIDE7IH1cclxuICAgICAgICAgICAgaWYgKGMxLmVsZXZhdGlvbiA8IGMyLmVsZXZhdGlvbikgeyByZXR1cm4gLTE7IH1cclxuICAgICAgICAgICAgaWYgKGMxLmluZGV4ID4gYzIuaW5kZXgpIHsgcmV0dXJuIDE7IH1cclxuICAgICAgICAgICAgaWYgKGMxLmluZGV4IDwgYzIuaW5kZXgpIHsgcmV0dXJuIC0xOyB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIExldCB5KHgpIGJlIHRoZSB0b3RhbCBhcmVhIHRoYXQgd2Ugd2FudCBhdCBlbGV2YXRpb24gPD0geC5cclxuICAgICAgICAgICAgLy8gV2Ugd2FudCB0aGUgaGlnaGVyIGVsZXZhdGlvbnMgdG8gb2NjdXIgbGVzcyB0aGFuIGxvd2VyXHJcbiAgICAgICAgICAgIC8vIG9uZXMsIGFuZCBzZXQgdGhlIGFyZWEgdG8gYmUgeSh4KSA9IDEgLSAoMS14KV4yLlxyXG4gICAgICAgICAgICB5ID0gaSAvIChsb2NhdGlvbnMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIHRvIHNvbHZlIGZvciB4LCBnaXZlbiB0aGUga25vd24geS5cclxuICAgICAgICAgICAgLy8gICogIHkgPSAxIC0gKDEteCleMlxyXG4gICAgICAgICAgICAvLyAgKiAgeSA9IDEgLSAoMSAtIDJ4ICsgeF4yKVxyXG4gICAgICAgICAgICAvLyAgKiAgeSA9IDJ4IC0geF4yXHJcbiAgICAgICAgICAgIC8vICAqICB4XjIgLSAyeCArIHkgPSAwXHJcbiAgICAgICAgICAgIC8vIEZyb20gdGhpcyB3ZSBjYW4gdXNlIHRoZSBxdWFkcmF0aWMgZXF1YXRpb24gdG8gZ2V0OlxyXG4gICAgICAgICAgICB4ID0gTWF0aC5zcXJ0KFNDQUxFX0ZBQ1RPUikgLSBNYXRoLnNxcnQoU0NBTEVfRkFDVE9SICogKDEgLSB5KSk7XHJcbiAgICAgICAgICAgIGlmICh4ID4gMS4wKSB7IHggPSAxLjA7IH0gIC8vIFRPRE86IGRvZXMgdGhpcyBicmVhayBkb3duc2xvcGVzP1xyXG4gICAgICAgICAgICBsb2NhdGlvbnNbaV0uZWxldmF0aW9uID0geDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIHRoZSBvdmVyYWxsIGRpc3RyaWJ1dGlvbiBvZiBtb2lzdHVyZSB0byBiZSBldmVubHkgZGlzdHJpYnV0ZWQuXHJcbiAgICAgKi9cclxuICAgIHB1Yi5yZWRpc3RyaWJ1dGVNb2lzdHVyZSA9IGZ1bmN0aW9uIChsb2NhdGlvbnMpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgXHJcbiAgICAgICAgbG9jYXRpb25zLnNvcnQoZnVuY3Rpb24gKGMxLCBjMikge1xyXG4gICAgICAgICAgICBpZiAoYzEubW9pc3R1cmUgPiBjMi5tb2lzdHVyZSkgeyByZXR1cm4gMTsgfVxyXG4gICAgICAgICAgICBpZiAoYzEubW9pc3R1cmUgPCBjMi5tb2lzdHVyZSkgeyByZXR1cm4gLTE7IH1cclxuICAgICAgICAgICAgaWYgKGMxLmluZGV4ID4gYzIuaW5kZXgpIHsgcmV0dXJuIDE7IH1cclxuICAgICAgICAgICAgaWYgKGMxLmluZGV4IDwgYzIuaW5kZXgpIHsgcmV0dXJuIC0xOyB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uc1tpXS5tb2lzdHVyZSA9IGkgLyAobG9jYXRpb25zLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmUgcG9seWdvbiBhbmQgY29ybmVyIHR5cGVzOiBvY2VhbiwgY29hc3QsIGxhbmQuXHJcbiAgICAgKi9cclxuICAgIHB1Yi5hc3NpZ25PY2VhbkNvYXN0QW5kTGFuZCA9IGZ1bmN0aW9uIChsYWtlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgLy8gQ29tcHV0ZSBwb2x5Z29uIGF0dHJpYnV0ZXMgJ29jZWFuJyBhbmQgJ3dhdGVyJyBiYXNlZCBvbiB0aGVcclxuICAgICAgICAvLyBjb3JuZXIgYXR0cmlidXRlcy4gQ291bnQgdGhlIHdhdGVyIGNvcm5lcnMgcGVyXHJcbiAgICAgICAgLy8gcG9seWdvbi4gT2NlYW5zIGFyZSBhbGwgcG9seWdvbnMgY29ubmVjdGVkIHRvIHRoZSBlZGdlIG9mIHRoZVxyXG4gICAgICAgIC8vIG1hcC4gSW4gdGhlIGZpcnN0IHBhc3MsIG1hcmsgdGhlIGVkZ2VzIG9mIHRoZSBtYXAgYXMgb2NlYW47XHJcbiAgICAgICAgLy8gaW4gdGhlIHNlY29uZCBwYXNzLCBtYXJrIGFueSB3YXRlci1jb250YWluaW5nIHBvbHlnb25cclxuICAgICAgICAvLyBjb25uZWN0ZWQgYW4gb2NlYW4gYXMgb2NlYW4uXHJcbiAgICAgICAgdmFyIHF1ZXVlID0gW107IC8vIEFycmF5PENlbnRlcj5cclxuICAgICAgICB2YXIgcCwgbnVtV2F0ZXI7XHJcbiAgICAgIFxyXG4gICAgICAgIF8ocHViLmNlbnRlcnMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgbnVtV2F0ZXIgPSAwO1xyXG4gICAgICAgICAgICBfKHAuY29ybmVycykuZWFjaChmdW5jdGlvbiAocSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHEuYm9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcC5ib3JkZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHAub2NlYW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHEud2F0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocS53YXRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bVdhdGVyICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwLndhdGVyID0gKHAub2NlYW4gfHwgbnVtV2F0ZXIgPj0gcC5jb3JuZXJzLmxlbmd0aCAqIGxha2VUaHJlc2hvbGQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHAgPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuZWlnaGJvdXJJbmRleCA9IDA7IG5laWdoYm91ckluZGV4IDwgcC5uZWlnaGJvcnMubGVuZ3RoOyBuZWlnaGJvdXJJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHAubmVpZ2hib3JzW25laWdoYm91ckluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChyLndhdGVyICYmICFyLm9jZWFuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgci5vY2VhbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgXHJcbiAgICAgICAgLy8gU2V0IHRoZSBwb2x5Z29uIGF0dHJpYnV0ZSAnY29hc3QnIGJhc2VkIG9uIGl0cyBuZWlnaGJvcnMuIElmXHJcbiAgICAgICAgLy8gaXQgaGFzIGF0IGxlYXN0IG9uZSBvY2VhbiBhbmQgYXQgbGVhc3Qgb25lIGxhbmQgbmVpZ2hib3IsXHJcbiAgICAgICAgLy8gdGhlbiB0aGlzIGlzIGEgY29hc3RhbCBwb2x5Z29uLlxyXG4gICAgICAgIF8ocHViLmNlbnRlcnMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgdmFyIG51bU9jZWFuID0gMDtcclxuICAgICAgICAgICAgdmFyIG51bUxhbmQgPSAwO1xyXG4gICAgICAgICAgICBfKHAubmVpZ2hib3JzKS5lYWNoKGZ1bmN0aW9uIChyKSB7XHJcbiAgICAgICAgICAgICAgICBudW1PY2VhbiArPSBjb252ZXJ0LmludEZyb21Cb29sZWFuKHIub2NlYW4pO1xyXG4gICAgICAgICAgICAgICAgbnVtTGFuZCArPSBjb252ZXJ0LmludEZyb21Cb29sZWFuKCFyLndhdGVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHAuY29hc3QgPSAobnVtT2NlYW4gPiAwKSAmJiAobnVtTGFuZCA+IDApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBjb3JuZXIgYXR0cmlidXRlcyBiYXNlZCBvbiB0aGUgY29tcHV0ZWQgcG9seWdvblxyXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMuIElmIGFsbCBwb2x5Z29ucyBjb25uZWN0ZWQgdG8gdGhpcyBjb3JuZXIgYXJlXHJcbiAgICAgICAgLy8gb2NlYW4sIHRoZW4gaXQncyBvY2VhbjsgaWYgYWxsIGFyZSBsYW5kLCB0aGVuIGl0J3MgbGFuZDtcclxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBjb2FzdC5cclxuICAgICAgICBfKHB1Yi5jb3JuZXJzKS5lYWNoKGZ1bmN0aW9uIChxKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1PY2VhbiA9IDA7XHJcbiAgICAgICAgICAgIHZhciBudW1MYW5kID0gMDtcclxuICAgICAgICAgICAgXyhxLnRvdWNoZXMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIG51bU9jZWFuICs9IGNvbnZlcnQuaW50RnJvbUJvb2xlYW4ocC5vY2Vhbik7XHJcbiAgICAgICAgICAgICAgICBudW1MYW5kICs9IGNvbnZlcnQuaW50RnJvbUJvb2xlYW4oIXAud2F0ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcS5vY2VhbiA9IChudW1PY2VhbiA9PT0gcS50b3VjaGVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHEuY29hc3QgPSAobnVtT2NlYW4gPiAwKSAmJiAobnVtTGFuZCA+IDApO1xyXG4gICAgICAgICAgICBxLndhdGVyID0gcS5ib3JkZXIgfHwgKChudW1MYW5kICE9PSBxLnRvdWNoZXMubGVuZ3RoKSAmJiAhcS5jb2FzdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9seWdvbiBlbGV2YXRpb25zIGFyZSB0aGUgYXZlcmFnZSBvZiB0aGUgZWxldmF0aW9ucyBvZiB0aGVpciBjb3JuZXJzLlxyXG4gICAgICovXHJcbiAgICBwdWIuYXNzaWduUG9seWdvbkVsZXZhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN1bUVsZXZhdGlvbjtcclxuICAgICAgICBfKHB1Yi5jZW50ZXJzKS5lYWNoKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHN1bUVsZXZhdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgXyhwLmNvcm5lcnMpLmVhY2goZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICAgICAgICAgIHN1bUVsZXZhdGlvbiArPSBxLmVsZXZhdGlvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHAuZWxldmF0aW9uID0gc3VtRWxldmF0aW9uIC8gcC5jb3JuZXJzLmxlbmd0aDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgZG93bnNsb3BlIHBvaW50ZXJzLiAgQXQgZXZlcnkgcG9pbnQsIHdlIHBvaW50IHRvIHRoZVxyXG4gICAgICogcG9pbnQgZG93bnN0cmVhbSBmcm9tIGl0LCBvciB0byBpdHNlbGYuICBUaGlzIGlzIHVzZWQgZm9yXHJcbiAgICAgKiBnZW5lcmF0aW5nIHJpdmVycyBhbmQgd2F0ZXJzaGVkcy5cclxuICAgICAqL1xyXG4gICAgcHViLmNhbGN1bGF0ZURvd25zbG9wZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHI7XHJcbiAgICAgIFxyXG4gICAgICAgIF8ocHViLmNvcm5lcnMpLmVhY2goZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICAgICAgciA9IHE7XHJcbiAgICAgICAgICAgIF8ocS5hZGphY2VudCkuZWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHMuZWxldmF0aW9uIDw9IHIuZWxldmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBxLmRvd25zbG9wZSA9IHI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSB3YXRlcnNoZWQgb2YgZXZlcnkgbGFuZCBwb2ludC4gVGhlIHdhdGVyc2hlZCBpc1xyXG4gICAgICogdGhlIGxhc3QgZG93bnN0cmVhbSBsYW5kIHBvaW50IGluIHRoZSBkb3duc2xvcGUgZ3JhcGguIFRPRE86XHJcbiAgICAgKiB3YXRlcnNoZWRzIGFyZSBjdXJyZW50bHkgY2FsY3VsYXRlZCBvbiBjb3JuZXJzLCBidXQgaXQnZCBiZVxyXG4gICAgICogbW9yZSB1c2VmdWwgdG8gY29tcHV0ZSB0aGVtIG9uIHBvbHlnb24gY2VudGVycyBzbyB0aGF0IGV2ZXJ5XHJcbiAgICAgKiBwb2x5Z29uIGNhbiBiZSBtYXJrZWQgYXMgYmVpbmcgaW4gb25lIHdhdGVyc2hlZC5cclxuICAgICAqL1xyXG4gICAgcHViLmNhbGN1bGF0ZVdhdGVyc2hlZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHIsIGksIGNoYW5nZWQ7XHJcbiAgICAgIFxyXG4gICAgICAgIC8vIEluaXRpYWxseSB0aGUgd2F0ZXJzaGVkIHBvaW50ZXIgcG9pbnRzIGRvd25zbG9wZSBvbmUgc3RlcC4gICAgICBcclxuICAgICAgICBfKHB1Yi5jb3JuZXJzKS5lYWNoKGZ1bmN0aW9uIChxKSB7XHJcbiAgICAgICAgICAgIHEud2F0ZXJzaGVkID0gcTtcclxuICAgICAgICAgICAgaWYgKCFxLm9jZWFuICYmICFxLmNvYXN0KSB7XHJcbiAgICAgICAgICAgICAgICBxLndhdGVyc2hlZCA9IHEuZG93bnNsb3BlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRm9sbG93IHRoZSBkb3duc2xvcGUgcG9pbnRlcnMgdG8gdGhlIGNvYXN0LiBMaW1pdCB0byAxMDBcclxuICAgICAgICAvLyBpdGVyYXRpb25zIGFsdGhvdWdoIG1vc3Qgb2YgdGhlIHRpbWUgd2l0aCBOVU1fUE9JTlRTPTIwMDAgaXRcclxuICAgICAgICAvLyBvbmx5IHRha2VzIDIwIGl0ZXJhdGlvbnMgYmVjYXVzZSBtb3N0IHBvaW50cyBhcmUgbm90IGZhciBmcm9tXHJcbiAgICAgICAgLy8gYSBjb2FzdC4gIFRPRE86IGNhbiBydW4gZmFzdGVyIGJ5IGxvb2tpbmcgYXRcclxuICAgICAgICAvLyBwLndhdGVyc2hlZC53YXRlcnNoZWQgaW5zdGVhZCBvZiBwLmRvd25zbG9wZS53YXRlcnNoZWQuXHJcbiAgICAgICAgdmFyIGNvcm5lckluZGV4LCBxO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDA7IGkrKykge1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoY29ybmVySW5kZXggPSAwOyBjb3JuZXJJbmRleCA8IHB1Yi5jb3JuZXJzLmxlbmd0aDsgY29ybmVySW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgcSA9IHB1Yi5jb3JuZXJzW2Nvcm5lckluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICghcS5vY2VhbiAmJiAhcS5jb2FzdCAmJiAhcS53YXRlcnNoZWQuY29hc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByID0gcS5kb3duc2xvcGUud2F0ZXJzaGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghci5vY2VhbikgeyBxLndhdGVyc2hlZCA9IHI7IH1cclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNoYW5nZWQpIHsgYnJlYWs7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSG93IGJpZyBpcyBlYWNoIHdhdGVyc2hlZD9cclxuICAgICAgICBmb3IgKGNvcm5lckluZGV4ID0gMDsgY29ybmVySW5kZXggPCBwdWIuY29ybmVycy5sZW5ndGg7IGNvcm5lckluZGV4KyspIHtcclxuICAgICAgICAgICAgcSA9IHB1Yi5jb3JuZXJzW2Nvcm5lckluZGV4XTtcclxuICAgICAgICAgICAgciA9IHEud2F0ZXJzaGVkO1xyXG4gICAgICAgICAgICByLndhdGVyc2hlZFNpemUgPSAxICsgKHIud2F0ZXJzaGVkU2l6ZSB8fCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHJpdmVycyBhbG9uZyBlZGdlcy4gUGljayBhIHJhbmRvbSBjb3JuZXIgcG9pbnQsXHJcbiAgICAgKiB0aGVuIG1vdmUgZG93bnNsb3BlLiBNYXJrIHRoZSBlZGdlcyBhbmQgY29ybmVycyBhcyByaXZlcnMuXHJcbiAgICAgKiBAcGFyYW0gICByaXZlckNoYW5jZSBIaWdoZXIgPSBtb3JlIHJpdmVycy5cclxuICAgICAqL1xyXG4gICAgcHViLmNyZWF0ZVJpdmVycyA9IGZ1bmN0aW9uIChyaXZlckNoYW5jZSkge1xyXG4gICAgICAgIHJpdmVyQ2hhbmNlID0gY29yZS5jb2FsZXNjZShyaXZlckNoYW5jZSwgY29yZS50b0ludCgocHViLlNJWkUud2lkdGggKyBwdWIuU0laRS5oZWlnaHQpIC8gNCkpO1xyXG5cclxuICAgICAgICB2YXIgaSwgcSwgZWRnZTtcclxuICAgICAgXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJpdmVyQ2hhbmNlOyBpKyspIHtcclxuICAgICAgICAgICAgcSA9IHB1Yi5jb3JuZXJzW3B1Yi5tYXBSYW5kb20ubmV4dEludFJhbmdlKDAsIHB1Yi5jb3JuZXJzLmxlbmd0aCAtIDEpXTtcclxuICAgICAgICAgICAgaWYgKHEub2NlYW4gfHwgcS5lbGV2YXRpb24gPCAwLjMgfHwgcS5lbGV2YXRpb24gPiAwLjkpIHsgY29udGludWU7IH1cclxuICAgICAgICAgICAgLy8gQmlhcyByaXZlcnMgdG8gZ28gd2VzdDogaWYgKHEuZG93bnNsb3BlLnggPiBxLngpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB3aGlsZSAoIXEuY29hc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChxID09PSBxLmRvd25zbG9wZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWRnZSA9IHB1Yi5sb29rdXBFZGdlRnJvbUNvcm5lcihxLCBxLmRvd25zbG9wZSk7XHJcbiAgICAgICAgICAgICAgICBlZGdlLnJpdmVyID0gZWRnZS5yaXZlciArIDE7XHJcbiAgICAgICAgICAgICAgICBxLnJpdmVyID0gKHEucml2ZXIgfHwgMCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgcS5kb3duc2xvcGUucml2ZXIgPSAocS5kb3duc2xvcGUucml2ZXIgfHwgMCkgKyAxOyAgLy8gVE9ETzogZml4IGRvdWJsZSBjb3VudFxyXG4gICAgICAgICAgICAgICAgcSA9IHEuZG93bnNsb3BlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBtb2lzdHVyZS4gRnJlc2h3YXRlciBzb3VyY2VzIHNwcmVhZCBtb2lzdHVyZTogcml2ZXJzXHJcbiAgICAgKiBhbmQgbGFrZXMgKG5vdCBvY2VhbnMpLiBTYWx0d2F0ZXIgc291cmNlcyBoYXZlIG1vaXN0dXJlIGJ1dCBkb1xyXG4gICAgICogbm90IHNwcmVhZCBpdCAod2Ugc2V0IGl0IGF0IHRoZSBlbmQsIGFmdGVyIHByb3BhZ2F0aW9uKS5cclxuICAgICAqL1xyXG4gICAgcHViLmFzc2lnbkNvcm5lck1vaXN0dXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBxLCBuZXdNb2lzdHVyZTtcclxuICAgICAgICB2YXIgcXVldWUgPSBbXTsgLy8gQXJyYXk8Q29ybmVyPlxyXG4gICAgICAgIC8vIEZyZXNoIHdhdGVyXHJcbiAgICAgICAgXyhwdWIuY29ybmVycykuZWFjaChmdW5jdGlvbiAocSkge1xyXG4gICAgICAgICAgICBpZiAoKHEud2F0ZXIgfHwgcS5yaXZlciA+IDApICYmICFxLm9jZWFuKSB7XHJcbiAgICAgICAgICAgICAgICBxLm1vaXN0dXJlID0gcS5yaXZlciA+IDAgPyBNYXRoLm1pbigzLjAsICgwLjIgKiBxLnJpdmVyKSkgOiAxLjA7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcS5tb2lzdHVyZSA9IDAuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHEgPSBxdWV1ZS5zaGlmdCgpO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgYWRqYWNlbnRJbmRleCA9IDA7IGFkamFjZW50SW5kZXggPCBxLmFkamFjZW50Lmxlbmd0aDsgYWRqYWNlbnRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHEuYWRqYWNlbnRbYWRqYWNlbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBuZXdNb2lzdHVyZSA9IHEubW9pc3R1cmUgKiAwLjk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3TW9pc3R1cmUgPiByLm1vaXN0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgci5tb2lzdHVyZSA9IG5ld01vaXN0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2FsdCB3YXRlclxyXG4gICAgICAgIF8ocHViLmNvcm5lcnMpLmVhY2goZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICAgICAgaWYgKHEub2NlYW4gfHwgcS5jb2FzdCkge1xyXG4gICAgICAgICAgICAgICAgcS5tb2lzdHVyZSA9IDEuMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvbHlnb24gbW9pc3R1cmUgaXMgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG1vaXN0dXJlIGF0IGNvcm5lcnNcclxuICAgICAqL1xyXG4gICAgcHViLmFzc2lnblBvbHlnb25Nb2lzdHVyZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3VtTW9pc3R1cmU7XHJcbiAgICAgICAgXyhwdWIuY2VudGVycykuZWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICBzdW1Nb2lzdHVyZSA9IDAuMDtcclxuICAgICAgICAgICAgXyhwLmNvcm5lcnMpLmVhY2goZnVuY3Rpb24gKHEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChxLm1vaXN0dXJlID4gMS4wKSB7IHEubW9pc3R1cmUgPSAxLjA7IH1cclxuICAgICAgICAgICAgICAgIHN1bU1vaXN0dXJlICs9IHEubW9pc3R1cmU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwLm1vaXN0dXJlID0gc3VtTW9pc3R1cmUgLyBwLmNvcm5lcnMubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWIuYXNzaWduQmlvbWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF8ocHViLmNlbnRlcnMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgcC5iaW9tZSA9IGV4cG9ydHMuZ2V0QmlvbWUocCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9vayB1cCBhIFZvcm9ub2kgRWRnZSBvYmplY3QgZ2l2ZW4gdHdvIGFkamFjZW50IFZvcm9ub2lcclxuICAgICAqIHBvbHlnb25zLCBvciB0d28gYWRqYWNlbnQgVm9yb25vaSBjb3JuZXJzXHJcbiAgICAgKi9cclxuICAgIHB1Yi5sb29rdXBFZGdlRnJvbUNlbnRlciA9IGZ1bmN0aW9uIChwLCByKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmJvcmRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGVkZ2UgPSBwLmJvcmRlcnNbaV07XHJcbiAgICAgICAgICAgIGlmIChlZGdlLmQwID09PSByIHx8IGVkZ2UuZDEgPT09IHIpIHsgcmV0dXJuIGVkZ2U7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1Yi5sb29rdXBFZGdlRnJvbUNvcm5lciA9IGZ1bmN0aW9uIChxLCBzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLnByb3RydWRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZWRnZSA9IHEucHJvdHJ1ZGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAoZWRnZS52MCA9PT0gcyB8fCBlZGdlLnYxID09PSBzKSB7IHJldHVybiBlZGdlOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gcG9pbnQgc2hvdWxkIGJlIG9uIHRoZSBpc2xhbmQgb3IgaW4gdGhlIHdhdGVyLlxyXG4gICAgICovXHJcbiAgICBwdWIuaW5zaWRlID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gcHViLmlzbGFuZFNoYXBlKHsgeDogMiAqIChwLnggLyBwdWIuU0laRS53aWR0aCAtIDAuNSksIHk6IDIgKiAocC55IC8gcHViLlNJWkUuaGVpZ2h0IC0gMC41KSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHViLnJlc2V0KCk7XHJcblxyXG4gICAgcmV0dXJuIHB1YjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBc3NpZ24gYSBiaW9tZSB0eXBlIHRvIGVhY2ggcG9seWdvbi4gSWYgaXQgaGFzXHJcbiAqIG9jZWFuL2NvYXN0L3dhdGVyLCB0aGVuIHRoYXQncyB0aGUgYmlvbWU7IG90aGVyd2lzZSBpdCBkZXBlbmRzXHJcbiAqIG9uIGxvdy9oaWdoIGVsZXZhdGlvbiBhbmQgbG93L21lZGl1bS9oaWdoIG1vaXN0dXJlLiBUaGlzIGlzXHJcbiAqIHJvdWdobHkgYmFzZWQgb24gdGhlIFdoaXR0YWtlciBkaWFncmFtIGJ1dCBhZGFwdGVkIHRvIGZpdCB0aGVcclxuICogbmVlZHMgb2YgdGhlIGlzbGFuZCBtYXAgZ2VuZXJhdG9yLlxyXG4gKi9cclxuZXhwb3J0cy5nZXRCaW9tZSA9IGZ1bmN0aW9uIChwKSB7XHJcbiAgICBpZiAocC5vY2Vhbikge1xyXG4gICAgICAgIHJldHVybiAnT0NFQU4nO1xyXG4gICAgfSBlbHNlIGlmIChwLndhdGVyKSB7XHJcbiAgICAgICAgaWYgKHAuZWxldmF0aW9uIDwgMC4xKSB7IHJldHVybiAnTUFSU0gnOyB9XHJcbiAgICAgICAgaWYgKHAuZWxldmF0aW9uID4gMC44KSB7IHJldHVybiAnSUNFJzsgfVxyXG4gICAgICAgIHJldHVybiAnTEFLRSc7XHJcbiAgICB9IGVsc2UgaWYgKHAuY29hc3QpIHtcclxuICAgICAgICByZXR1cm4gJ0JFQUNIJztcclxuICAgIH0gZWxzZSBpZiAocC5lbGV2YXRpb24gPiAwLjgpIHtcclxuICAgICAgICBpZiAocC5tb2lzdHVyZSA+IDAuNTApIHsgcmV0dXJuICdTTk9XJzsgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubW9pc3R1cmUgPiAwLjMzKSB7IHJldHVybiAnVFVORFJBJzsgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubW9pc3R1cmUgPiAwLjE2KSB7IHJldHVybiAnQkFSRSc7IH1cclxuICAgICAgICBlbHNlIHsgcmV0dXJuICdTQ09SQ0hFRCc7IH1cclxuICAgIH0gZWxzZSBpZiAocC5lbGV2YXRpb24gPiAwLjYpIHtcclxuICAgICAgICBpZiAocC5tb2lzdHVyZSA+IDAuNjYpIHsgcmV0dXJuICdUQUlHQSc7IH1cclxuICAgICAgICBlbHNlIGlmIChwLm1vaXN0dXJlID4gMC4zMykgeyByZXR1cm4gJ1NIUlVCTEFORCc7IH1cclxuICAgICAgICBlbHNlIHsgcmV0dXJuICdURU1QRVJBVEVfREVTRVJUJzsgfVxyXG4gICAgfSBlbHNlIGlmIChwLmVsZXZhdGlvbiA+IDAuMykge1xyXG4gICAgICAgIGlmIChwLm1vaXN0dXJlID4gMC44MykgeyByZXR1cm4gJ1RFTVBFUkFURV9SQUlOX0ZPUkVTVCc7IH1cclxuICAgICAgICBlbHNlIGlmIChwLm1vaXN0dXJlID4gMC41MCkgeyByZXR1cm4gJ1RFTVBFUkFURV9ERUNJRFVPVVNfRk9SRVNUJzsgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubW9pc3R1cmUgPiAwLjE2KSB7IHJldHVybiAnR1JBU1NMQU5EJzsgfVxyXG4gICAgICAgIGVsc2UgeyByZXR1cm4gJ1RFTVBFUkFURV9ERVNFUlQnOyB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChwLm1vaXN0dXJlID4gMC42NikgeyByZXR1cm4gJ1RST1BJQ0FMX1JBSU5fRk9SRVNUJzsgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubW9pc3R1cmUgPiAwLjMzKSB7IHJldHVybiAnVFJPUElDQUxfU0VBU09OQUxfRk9SRVNUJzsgfVxyXG4gICAgICAgIGVsc2UgaWYgKHAubW9pc3R1cmUgPiAwLjE2KSB7IHJldHVybiAnR1JBU1NMQU5EJzsgfVxyXG4gICAgICAgIGVsc2UgeyByZXR1cm4gJ1NVQlRST1BJQ0FMX0RFU0VSVCc7IH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmljaGFyZCBKYW5pY2VrJ3MgRXh0ZW5zaW9uc1xyXG5cclxuZXhwb3J0cy5jb3VudExhbmRzID0gZnVuY3Rpb24gKGNlbnRlcnMpIHtcclxuICAgIHJldHVybiBfKF8oY2VudGVycykuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhYy53YXRlcjsgfSkpLnNpemUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWJ1aWxkcyB0aGUgbWFwIHZhcnlpbmcgdGhlIG51bWJlciBvZiBwb2ludHMgdW50aWwgZGVzaXJlZCBudW1iZXIgb2YgbGFuZCBjZW50ZXJzIGFyZSBnZW5lcmF0ZWQgb3IgdGltZW91dCBpcyByZWFjaGVkLlxyXG4gKiBOb3QgYW4gZWZmaWNpZW50IGFsZ29yaXRoaW0sIGJ1dCBnZXRzIHRoZSBqb2IgZG9uZS5cclxuICovXHJcbmV4cG9ydHMudHJ5TXV0YXRlTWFwUG9pbnRzVG9HZXROdW1iZXJMYW5kcyA9IGZ1bmN0aW9uIChtYXAsIG51bWJlck9mTGFuZHMsIHRpbWVvdXRNaWxsaXNlY29uZHMsIGluaXRpYWxOdW1iZXJPZlBvaW50cywgbnVtTGxveWRJdGVyYXRpb25zLCBsYWtlVGhyZXNob2xkKSB7XHJcbiAgICB0aW1lb3V0TWlsbGlzZWNvbmRzID0gY29yZS5kZWYodGltZW91dE1pbGxpc2Vjb25kcywgMTAgKiAxMDAwKTtcclxuICAgIGluaXRpYWxOdW1iZXJPZlBvaW50cyA9IGNvcmUuZGVmKGluaXRpYWxOdW1iZXJPZlBvaW50cywgZXhwb3J0cy5ERUZBVUxUX05VTUJFUl9PRl9QT0lOVFMpO1xyXG4gICAgbnVtTGxveWRJdGVyYXRpb25zID0gY29yZS5kZWYobnVtTGxveWRJdGVyYXRpb25zLCBleHBvcnRzLkRFRkFVTFRfTExPWURfSVRFUkFUSU9OUyk7XHJcbiAgICBsYWtlVGhyZXNob2xkID0gY29yZS5kZWYobGFrZVRocmVzaG9sZCwgZXhwb3J0cy5ERUZBVUxUX0xBS0VfVEhSRVNIT0xEKTtcclxuXHJcbiAgICB2YXIgcG9pbnRDb3VudCA9IGluaXRpYWxOdW1iZXJPZlBvaW50cztcclxuICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgdmFyIHRhcmdldExhbmRDb3VudEZvdW5kID0gZmFsc2U7XHJcbiAgICBkbyB7XHJcbiAgICAgICAgbWFwLmdvMFBsYWNlUG9pbnRzKHBvaW50Q291bnQpO1xyXG4gICAgICAgIG1hcC5nbzFJbXByb3ZlUG9pbnRzKG51bUxsb3lkSXRlcmF0aW9ucyk7XHJcbiAgICAgICAgbWFwLmdvMkJ1aWxkR3JhcGgoKTtcclxuICAgICAgICBtYXAuZ28zQXNzaWduRWxldmF0aW9ucyhsYWtlVGhyZXNob2xkKTtcclxuICAgICAgICB2YXIgbGFuZHMgPSBleHBvcnRzLmNvdW50TGFuZHMobWFwLmNlbnRlcnMpO1xyXG4gICAgICAgIGlmIChsYW5kcyA9PT0gbnVtYmVyT2ZMYW5kcykge1xyXG4gICAgICAgICAgICB0YXJnZXRMYW5kQ291bnRGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwb2ludENvdW50ICs9IChsYW5kcyA8IG51bWJlck9mTGFuZHMgPyAxIDogLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH0gd2hpbGUgKCF0YXJnZXRMYW5kQ291bnRGb3VuZCAmJiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dE1pbGxpc2Vjb25kcyk7XHJcbiAgICBcclxuICAgIHJldHVybiBtYXA7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcclxudmFyIGNvbnZlcnQgPSByZXF1aXJlKCcuLi9hczMvY29udmVyc2lvbi1jb3JlJyk7XHJcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vamFuaWNlay9jb3JlJyk7XHJcbnZhciBwYyA9IHJlcXVpcmUoJy4uL2FzMy9wb2ludC1jb3JlJyk7XHJcbnZhciBwcm5nID0gcmVxdWlyZSgnLi4vamFuaWNlay9wc2V1ZG8tcmFuZG9tLW51bWJlci1nZW5lcmF0b3JzJyk7XHJcblxyXG5leHBvcnRzLm1ha2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHViID0ge307XHJcblxyXG4gICAgcHViLnBhdGgwID0gW107IC8vIEFycmF5PFZlY3RvcjxQb2ludD4+IC8vIGVkZ2UgaW5kZXggLT4gVmVjdG9yLjxQb2ludD5cclxuICAgIHB1Yi5wYXRoMSA9IFtdOyAvLyBBcnJheTxWZWN0b3I8UG9pbnQ+PiAvLyBlZGdlIGluZGV4IC0+IFZlY3Rvci48UG9pbnQ+XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBub2lzeSBsaW5lIHBhdGhzIGZvciBlYWNoIG9mIHRoZSBWb3Jvbm9pIGVkZ2VzLiBUaGVyZSBhcmVcclxuICAgICAqIHR3byBub2lzeSBsaW5lIHBhdGhzIGZvciBlYWNoIGVkZ2UsIGVhY2ggY292ZXJpbmcgaGFsZiB0aGVcclxuICAgICAqIGRpc3RhbmNlOiBwYXRoMCBpcyBmcm9tIHYwIHRvIHRoZSBtaWRwb2ludCBhbmQgcGF0aDEgaXMgZnJvbSB2MVxyXG4gICAgICogdG8gdGhlIG1pZHBvaW50LiBXaGVuIGRyYXdpbmcgdGhlIHBvbHlnb25zLCBvbmUgb3IgdGhlIG90aGVyXHJcbiAgICAgKiBtdXN0IGJlIGRyYXduIGluIHJldmVyc2Ugb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gbm9pc3lMaW5lVHJhZGVvZmYgbG93OiBqYWdnZWQgdmVkZ2U7IGhpZ2g6IGphZ2dlZCBkZWRnZSAoZGVmYXVsdCA9IDAuNSlcclxuICAgICAqL1xyXG4gICAgcHViLmJ1aWxkTm9pc3lFZGdlcyA9IGZ1bmN0aW9uIChtYXAsIGxhdmEsIHNlZWQsIG5vaXN5TGluZVRyYWRlb2ZmKSB7XHJcbiAgICAgICAgbm9pc3lMaW5lVHJhZGVvZmYgPSBjb3JlLmRlZihub2lzeUxpbmVUcmFkZW9mZiwgMC41KTtcclxuICAgICAgICB2YXIgZ2VuID0gcHJuZy5yYW5kb21HZW5lcmF0b3Ioc2VlZCwgcHJuZy5uZXh0UGFya01pbGxlcik7XHJcbiAgICAgICAgXyhtYXAuY2VudGVycykuZWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICBfKHAuYm9yZGVycykuZWFjaChmdW5jdGlvbiAoZWRnZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKGVkZ2UuZDApICYmICFjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKGVkZ2UuZDEpICYmICFjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKGVkZ2UudjApICYmICFjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKGVkZ2UudjEpICYmIGNvcmUuaXNVbmRlZmluZWRPck51bGwocHViLnBhdGgwW2VkZ2UuaW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gbm9pc3lMaW5lVHJhZGVvZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBwYy5pbnRlcnBvbGF0ZShlZGdlLnYwLnBvaW50LCBlZGdlLmQwLnBvaW50LCBmKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHBjLmludGVycG9sYXRlKGVkZ2UudjAucG9pbnQsIGVkZ2UuZDEucG9pbnQsIGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gcGMuaW50ZXJwb2xhdGUoZWRnZS52MS5wb2ludCwgZWRnZS5kMC5wb2ludCwgZik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBwYy5pbnRlcnBvbGF0ZShlZGdlLnYxLnBvaW50LCBlZGdlLmQxLnBvaW50LCBmKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkxlbmd0aCA9IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlLmQwLmJpb21lICE9PSBlZGdlLmQxLmJpb21lKSB7IG1pbkxlbmd0aCA9IDM7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5kMC5vY2VhbiAmJiBlZGdlLmQxLm9jZWFuKSB7IG1pbkxlbmd0aCA9IDEwMDsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlLmQwLmNvYXN0IHx8IGVkZ2UuZDEuY29hc3QpICB7IG1pbkxlbmd0aCA9IDE7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydC5ib29sZWFuRnJvbUludChlZGdlLnJpdmVyKSB8fCAhY29yZS5pc1VuZGVmaW5lZE9yTnVsbChsYXZhLmxhdmFbZWRnZS5pbmRleF0pKSB7IG1pbkxlbmd0aCA9IDE7IH1cclxuICAgICAgICAgICAgICAgICAgICBwdWIucGF0aDBbZWRnZS5pbmRleF0gPSBleHBvcnRzLmJ1aWxkTm9pc3lMaW5lU2VnbWVudHMoZ2VuKCksIGVkZ2UudjAucG9pbnQsIHQsIGVkZ2UubWlkcG9pbnQsIHEsIG1pbkxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHViLnBhdGgxW2VkZ2UuaW5kZXhdID0gZXhwb3J0cy5idWlsZE5vaXN5TGluZVNlZ21lbnRzKGdlbigpLCBlZGdlLnYxLnBvaW50LCBzLCBlZGdlLm1pZHBvaW50LCByLCBtaW5MZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHB1YjtcclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbjogYnVpbGQgYSBzaW5nbGUgbm9pc3kgbGluZSBpbiBhIHF1YWRyaWxhdGVyYWwgQS1CLUMtRCxcclxuLy8gYW5kIHN0b3JlIHRoZSBvdXRwdXQgcG9pbnRzIGluIGEgVmVjdG9yLlxyXG5leHBvcnRzLmJ1aWxkTm9pc3lMaW5lU2VnbWVudHMgPSBmdW5jdGlvbiAoc2VlZCwgQSwgQiwgQywgRCwgbWluTGVuZ3RoKSB7XHJcbiAgICB2YXIgZ2VuID0gcHJuZy5yYW5kb21HZW5lcmF0b3Ioc2VlZCwgcHJuZy5uZXh0UGFya01pbGxlcik7XHJcbiAgICB2YXIgcG9pbnRzID0gW107IC8vIFZlY3RvcjxQb2ludD5cclxuICAgIFxyXG4gICAgLy8gdmFyIGxpbWl0ID0gMTA7XHJcbiAgXHJcbiAgICBmdW5jdGlvbiBzdWJkaXZpZGUoQSwgQiwgQywgRCkge1xyXG4gICAgICAgIGlmIChwYy5kaXN0YW5jZUZyb21PcmlnaW4ocGMuc3VidHJhY3QoQSwgQykpIDwgbWluTGVuZ3RoIHx8IHBjLmRpc3RhbmNlRnJvbU9yaWdpbihwYy5zdWJ0cmFjdChCLCBEKSkgPCBtaW5MZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3ViZGl2aWRlIHRoZSBxdWFkcmlsYXRlcmFsXHJcbiAgICAgICAgdmFyIHAgPSBwcm5nLnRvRmxvYXRSYW5nZShnZW4oKSwgMC4yLCAwLjgpOyAvLyB2ZXJ0aWNhbCAoYWxvbmcgQS1EIGFuZCBCLUMpXHJcbiAgICAgICAgdmFyIHEgPSBwcm5nLnRvRmxvYXRSYW5nZShnZW4oKSwgMC4yLCAwLjgpOyAvLyBob3Jpem9udGFsIChhbG9uZyBBLUIgYW5kIEQtQylcclxuXHJcbiAgICAgICAgLy8gTWlkcG9pbnRzXHJcbiAgICAgICAgdmFyIEUgPSBwYy5pbnRlcnBvbGF0ZShBLCBELCBwKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgRiA9IHBjLmludGVycG9sYXRlKEIsIEMsIHApO1xyXG4gICAgICAgIHZhciBHID0gcGMuaW50ZXJwb2xhdGUoQSwgQiwgcSk7XHJcbiAgICAgICAgdmFyIEkgPSBwYy5pbnRlcnBvbGF0ZShELCBDLCBxKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDZW50cmFsIHBvaW50XHJcbiAgICAgICAgdmFyIEggPSBwYy5pbnRlcnBvbGF0ZShFLCBGLCBxKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBEaXZpZGUgdGhlIHF1YWQgaW50byBzdWJxdWFkcywgYnV0IG1lZXQgYXQgSFxyXG4gICAgICAgIHZhciBzID0gMS4wIC0gcHJuZy50b0Zsb2F0UmFuZ2UoZ2VuKCksIC0wLjQsIDAuNCk7IC8vcmFuZG9tLm5leHREb3VibGVSYW5nZSgtMC40LCAwLjQpO1xyXG4gICAgICAgIHZhciB0ID0gMS4wIC0gcHJuZy50b0Zsb2F0UmFuZ2UoZ2VuKCksIC0wLjQsIDAuNCk7IC8vcmFuZG9tLm5leHREb3VibGVSYW5nZSgtMC40LCAwLjQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vaWYobGltaXQtLSA+IDApIHt0cmFjZShbcCwgcSwgcywgdF0pO31cclxuICAgICAgICBcclxuICAgICAgICBzdWJkaXZpZGUoQSwgcGMuaW50ZXJwb2xhdGUoRywgQiwgcyksIEgsIHBjLmludGVycG9sYXRlKEUsIEQsIHQpKTtcclxuICAgICAgICBwb2ludHMucHVzaChIKTtcclxuICAgICAgICBzdWJkaXZpZGUoSCwgcGMuaW50ZXJwb2xhdGUoRiwgQywgcyksIEMsIHBjLmludGVycG9sYXRlKEksIEQsIHQpKTtcclxuICAgIH1cclxuXHJcbiAgICBwb2ludHMucHVzaChBKTtcclxuICAgIHN1YmRpdmlkZShBLCBCLCBDLCBEKTtcclxuICAgIHBvaW50cy5wdXNoKEMpO1xyXG4gICAgcmV0dXJuIHBvaW50cztcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG52YXIgY29yZSA9IHJlcXVpcmUoJy4uL2phbmljZWsvY29yZScpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHViID0ge307XHJcblxyXG4gICAgLy8gVGhlIHJvYWQgYXJyYXkgbWFya3MgdGhlIGVkZ2VzIHRoYXQgYXJlIHJvYWRzLiAgVGhlIG1hcmsgaXMgMSxcclxuICAgIC8vIDIsIG9yIDMsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRocmVlIGNvbnRvdXIgbGV2ZWxzLiBOb3RlIHRoYXRcclxuICAgIC8vIHRoZXNlIGFyZSBzcGFyc2UgYXJyYXlzLCBvbmx5IGZpbGxlZCBpbiB3aGVyZSB0aGVyZSBhcmUgcm9hZHMuXHJcbiAgICBwdWIucm9hZCA9IFtdOyAvLyBBcnJheTxJbnQ+IC8vIGVkZ2UgaW5kZXggLT4gaW50IGNvbnRvdXIgbGV2ZWxcclxuICAgIHB1Yi5yb2FkQ29ubmVjdGlvbnMgPSBbXTsgLy8gQXJyYXk8QXJyYXk8RWRnZT4+ICAvLyBjZW50ZXIgaW5kZXggLT4gYXJyYXkgb2YgRWRnZXMgd2l0aCByb2Fkc1xyXG5cclxuICAgIC8vIFdlIHdhbnQgdG8gbWFyayBkaWZmZXJlbnQgZWxldmF0aW9uIHpvbmVzIHNvIHRoYXQgd2UgY2FuIGRyYXdcclxuICAgIC8vIGlzbGFuZC1jaXJjbGluZyByb2FkcyB0aGF0IGRpdmlkZSB0aGUgYXJlYXMuXHJcbiAgICBwdWIuY3JlYXRlUm9hZHMgPSBmdW5jdGlvbiAobWFwLCBlbGV2YXRpb25UaHJlc2hvbGRzKSB7XHJcbiAgICAgICAgLy8gT2NlYW5zIGFuZCBjb2FzdGFsIHBvbHlnb25zIGFyZSB0aGUgbG93ZXN0IGNvbnRvdXIgem9uZVxyXG4gICAgICAgIC8vICgxKS4gQW55dGhpbmcgY29ubmVjdGVkIHRvIGNvbnRvdXIgbGV2ZWwgSywgaWYgaXQncyBiZWxvd1xyXG4gICAgICAgIC8vIGVsZXZhdGlvbiB0aHJlc2hvbGQgSywgb3IgaWYgaXQncyB3YXRlciwgZ2V0cyBjb250b3VyIGxldmVsXHJcbiAgICAgICAgLy8gSy4gICgyKSBBbnl0aGluZyBub3QgYXNzaWduZWQgYSBjb250b3VyIGxldmVsLCBhbmQgY29ubmVjdGVkXHJcbiAgICAgICAgLy8gdG8gY29udG91ciBsZXZlbCBLLCBnZXRzIGNvbnRvdXIgbGV2ZWwgSysxLlxyXG4gICAgICAgIHZhciBxdWV1ZSA9IFtdOyAvLyBBcnJheTxDZW50ZXI+XHJcbiAgICAgICAgdmFyIHAsIG5ld0xldmVsO1xyXG4gICAgICAgIC8vdmFyIGVsZXZhdGlvblRocmVzaG9sZHMgPSBbMCwgMC4wNSwgMC4zNywgMC42NF07XHJcbiAgICAgICAgdmFyIGNvcm5lckNvbnRvdXIgPSBbXTsgLy8gQXJyYXk8SW50PiAvLyBjb3JuZXIgaW5kZXggLT4gaW50IGNvbnRvdXIgbGV2ZWxcclxuICAgICAgICB2YXIgY2VudGVyQ29udG91ciA9IFtdOyAvLzpBcnJheTxJbnQ+IC8vIGNlbnRlciBpbmRleCAtPiBpbnQgY29udG91ciBsZXZlbFxyXG4gICAgXHJcbiAgICAgICAgXyhtYXAuY2VudGVycykuZWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICBpZiAocC5jb2FzdCB8fCBwLm9jZWFuKSB7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXJDb250b3VyW3AuaW5kZXhdID0gMTtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcCA9IHF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG5laWdoYm9ySW5kZXggPSAwOyBuZWlnaGJvckluZGV4IDwgcC5uZWlnaGJvcnMubGVuZ3RoOyBuZWlnaGJvckluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciByID0gcC5uZWlnaGJvcnNbbmVpZ2hib3JJbmRleF07XHJcbiAgICAgICAgICAgICAgICBuZXdMZXZlbCA9IGNvcmUuY29hbGVzY2UoY2VudGVyQ29udG91cltwLmluZGV4XSwgMCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoci5lbGV2YXRpb24gPiBlbGV2YXRpb25UaHJlc2hvbGRzW25ld0xldmVsXSAmJiAhci53YXRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IGV4dGVuZCB0aGUgY29udG91ciBsaW5lIHBhc3QgYm9kaWVzIG9mXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2F0ZXIgc28gdGhhdCByb2FkcyBkb24ndCB0ZXJtaW5hdGUgaW5zaWRlIGxha2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0xldmVsICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3TGV2ZWwgPCBjb3JlLmNvYWxlc2NlKGNlbnRlckNvbnRvdXJbci5pbmRleF0sIDk5OSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJDb250b3VyW3IuaW5kZXhdID0gbmV3TGV2ZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQSBjb3JuZXIncyBjb250b3VyIGxldmVsIGlzIHRoZSBNSU4gb2YgaXRzIHBvbHlnb25zXHJcbiAgICAgICAgXyhtYXAuY2VudGVycykuZWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICBfKHAuY29ybmVycykuZWFjaChmdW5jdGlvbiAocSkge1xyXG4gICAgICAgICAgICAgICAgY29ybmVyQ29udG91cltxLmluZGV4XSA9IGNvcmUudG9JbnQoTWF0aC5taW4oY29yZS5jb2FsZXNjZShjb3JuZXJDb250b3VyW3EuaW5kZXhdLCA5OTkpLCBjb3JlLmNvYWxlc2NlKGNlbnRlckNvbnRvdXJbcC5pbmRleF0sIDk5OSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFJvYWRzIGdvIGJldHdlZW4gcG9seWdvbnMgdGhhdCBoYXZlIGRpZmZlcmVudCBjb250b3VyIGxldmVsc1xyXG4gICAgICAgIF8obWFwLmNlbnRlcnMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgXyhwLmJvcmRlcnMpLmVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICghXy5pc051bGwoZWRnZS52MCkgJiYgIV8uaXNOdWxsKGVkZ2UudjEpICYmIGNvcm5lckNvbnRvdXJbZWRnZS52MC5pbmRleF0gIT09IGNvcm5lckNvbnRvdXJbZWRnZS52MS5pbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwdWIucm9hZFtlZGdlLmluZGV4XSA9IGNvcmUudG9JbnQoTWF0aC5taW4oY29ybmVyQ29udG91cltlZGdlLnYwLmluZGV4XSwgY29ybmVyQ29udG91cltlZGdlLnYxLmluZGV4XSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzVW5kZWZpbmVkT3JOdWxsKHB1Yi5yb2FkQ29ubmVjdGlvbnNbcC5pbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1Yi5yb2FkQ29ubmVjdGlvbnNbcC5pbmRleF0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHViLnJvYWRDb25uZWN0aW9uc1twLmluZGV4XS5wdXNoKGVkZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHB1YjtcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5leHBvcnRzLmRpc3BsYXlDb2xvcnMgPSB7XHJcbiAgICAvLyBGZWF0dXJlc1xyXG4gICAgT0NFQU46IDB4NDQ0NDdhLFxyXG4gICAgQ09BU1Q6IDB4MzMzMzVhLFxyXG4gICAgTEFLRVNIT1JFOiAweDIyNTU4OCxcclxuICAgIExBS0U6IDB4MzM2Njk5LFxyXG4gICAgUklWRVI6IDB4MjI1NTg4LFxyXG4gICAgTUFSU0g6IDB4MmY2NjY2LFxyXG4gICAgSUNFOiAweDk5ZmZmZixcclxuICAgIEJFQUNIOiAweGEwOTA3NyxcclxuICAgIFJPQUQxOiAweDQ0MjIxMSxcclxuICAgIFJPQUQyOiAweDU1MzMyMixcclxuICAgIFJPQUQzOiAweDY2NDQzMyxcclxuICAgIEJSSURHRTogMHg2ODY4NjAsXHJcbiAgICBMQVZBOiAweGNjMzMzMyxcclxuXHJcbiAgICAvLyBUZXJyYWluXHJcbiAgICBTTk9XOiAweGZmZmZmZixcclxuICAgIFRVTkRSQTogMHhiYmJiYWEsXHJcbiAgICBCQVJFOiAweDg4ODg4OCxcclxuICAgIFNDT1JDSEVEOiAweDU1NTU1NSxcclxuICAgIFRBSUdBOiAweDk5YWE3NyxcclxuICAgIFNIUlVCTEFORDogMHg4ODk5NzcsXHJcbiAgICBURU1QRVJBVEVfREVTRVJUOiAweGM5ZDI5YixcclxuICAgIFRFTVBFUkFURV9SQUlOX0ZPUkVTVDogMHg0NDg4NTUsXHJcbiAgICBURU1QRVJBVEVfREVDSURVT1VTX0ZPUkVTVDogMHg2Nzk0NTksXHJcbiAgICBHUkFTU0xBTkQ6IDB4ODhhYTU1LFxyXG4gICAgU1VCVFJPUElDQUxfREVTRVJUOiAweGQyYjk4YixcclxuICAgIFRST1BJQ0FMX1JBSU5fRk9SRVNUOiAweDMzNzc1NSxcclxuICAgIFRST1BJQ0FMX1NFQVNPTkFMX0ZPUkVTVDogMHg1NTk5NDRcclxufTtcclxuXHJcbmV4cG9ydHMuZWxldmF0aW9uR3JhZGllbnRDb2xvcnMgPSB7XHJcbiAgICBPQ0VBTjogMHgwMDg4MDAsXHJcbiAgICBHUkFESUVOVF9MT1c6IDB4MDA4ODAwLFxyXG4gICAgR1JBRElFTlRfSElHSDogMHhmZmZmMDBcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHViID0ge307XHJcbiAgICBwdWIubG93ZXN0Q29ybmVyID0gW107ICAgLy8gQXJyYXk8SW50PiAvLyBwb2x5Z29uIGluZGV4IC0+IGNvcm5lciBpbmRleFxyXG4gICAgcHViLndhdGVyc2hlZHMgPSBbXTsgICAgIC8vQXJyYXk8SW50PjsgIC8vIHBvbHlnb24gaW5kZXggLT4gY29ybmVyIGluZGV4XHJcblxyXG4gICAgLy8gV2Ugd2FudCB0byBtYXJrIGVhY2ggcG9seWdvbiB3aXRoIHRoZSBjb3JuZXIgd2hlcmUgd2F0ZXIgd291bGRcclxuICAgIC8vIGV4aXQgdGhlIGlzbGFuZC5cclxuICAgIHB1Yi5jcmVhdGVXYXRlcnNoZWRzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIHZhciBzO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHRoZSBsb3dlc3QgY29ybmVyIG9mIHRoZSBwb2x5Z29uLCBhbmQgc2V0IHRoYXQgYXMgdGhlXHJcbiAgICAgICAgLy8gZXhpdCBwb2ludCBmb3IgcmFpbiBmYWxsaW5nIG9uIHRoaXMgcG9seWdvblxyXG4gICAgICAgIF8obWFwLmNlbnRlcnMpLmVhY2goZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgcyA9IG51bGw7XHJcbiAgICAgICAgICAgIF8ocC5jb3JuZXJzKS5lYWNoKGZ1bmN0aW9uIChxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCBxLmVsZXZhdGlvbiA8IHMuZWxldmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwdWIubG93ZXN0Q29ybmVyW3AuaW5kZXhdID0gKHMgPT09IG51bGwpID8gLTEgOiBzLmluZGV4O1xyXG4gICAgICAgICAgICBwdWIud2F0ZXJzaGVkc1twLmluZGV4XSA9IChzID09PSBudWxsKSA/IC0xIDogKHMud2F0ZXJzaGVkID09PSBudWxsKSA/IC0xIDogcy53YXRlcnNoZWQuaW5kZXg7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBwdWI7XHJcbn07Il19
;